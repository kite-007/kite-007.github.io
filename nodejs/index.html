<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title># nodejs | Fr</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kite-007.github.io/favicon.ico?v=1621252045041">
<link rel="stylesheet" href="https://kite-007.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="
nodejs

一、运行脚本
二、创建应用

1. 引入模块
2. 创建服务器


三、npm

1. npm使用介绍
2. npm安装模块
3. 创建模块
4. 其他npm


四、REPL交互式解释器
五、回调函数与事件循环

1. ..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kite-007.github.io">
        <img src="https://kite-007.github.io/images/avatar.png?v=1621252045041" class="site-logo">
        <h1 class="site-title">Fr</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://kite-007.github.io/tags" class="site-nav">
            标签
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      意志坚定，持之以恒
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://kite-007.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title"># nodejs</h2>
            <div class="post-date">2021-05-17</div>
            
            <div class="post-content" v-pre>
              <p><ul class="markdownIt-TOC">
<li><a href="#nodejs">nodejs</a>
<ul>
<li><a href="#%E4%B8%80-%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">一、运行脚本</a></li>
<li><a href="#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8">二、创建应用</a>
<ul>
<li><a href="#1-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97">1. 引入模块</a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8">2. 创建服务器</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-npm">三、npm</a>
<ul>
<li><a href="#1-npm%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">1. npm使用介绍</a></li>
<li><a href="#2-npm%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97">2. npm安装模块</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">3. 创建模块</a></li>
<li><a href="#4-%E5%85%B6%E4%BB%96npm">4. 其他npm</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-repl%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8">四、REPL交互式解释器</a></li>
<li><a href="#%E4%BA%94-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">五、回调函数与事件循环</a>
<ul>
<li><a href="#1-%E5%9B%9E%E8%B0%83">1. 回调</a></li>
<li><a href="#2-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">2. 事件循环</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-eventemitter">六、EventEmitter</a>
<ul>
<li><a href="#error%E4%BA%8B%E4%BB%B6">error事件</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF-eventemitter">继承 EventEmitter</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-buffer%E7%BC%93%E5%86%B2%E5%8C%BA">七、Buffer(缓冲区)</a>
<ul>
<li><a href="#buffer%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">Buffer与字符编码</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F">八、模块系统</a></li>
<li><a href="#%E4%B9%9D-%E5%87%BD%E6%95%B0">九、函数</a></li>
<li><a href="#%E5%8D%81-%E8%B7%AF%E7%94%B1">十、路由</a></li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">十一、全局变量</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C-%E6%96%87%E4%BB%B6-%E5%BC%82%E6%AD%A5">十二、文件-异步</a></li>
<li><a href="#%E5%8D%81%E4%B8%89-getpost%E8%AF%B7%E6%B1%82">十三、GET/POST请求</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B-express%E6%A1%86%E6%9E%B6">十四、Express框架</a></li>
<li><a href="#%E5%8D%81%E4%BA%94-%E8%BF%9E%E6%8E%A5-mysql">十五、连接 MySQL</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8">安装驱动</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93">连接数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-curd">数据库操作( CURD )</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">查询数据</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">插入数据</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">更新数据</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">删除数据</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="nodejs">nodejs</h1>
<ol>
<li>
<p>介绍：</p>
<p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<p>Node.js的作用类似于Apache，是建立一个可以运行JavaScript的服务端，JavaScript之于Node.js就像PHP之于Apache一样。</p>
</li>
</ol>
<h2 id="一-运行脚本">一、运行脚本</h2>
<p>目的：编写简单的一个脚本并运行 了解nodejs</p>
<pre><code>console.log(&quot;hello world!&quot;)
# 保存为helloworld.js文件
# 注意中间不能有任何的空格
</code></pre>
<p>终端到此目录，<code>node helloworld.js</code></p>
<p>查找命令node -h</p>
<p>在终端下输入node进入nodejs的命令模式（交互式解释器），有点类似于python。</p>
<h2 id="二-创建应用">二、创建应用</h2>
<p>使用php编写后端代码后 部署需要Apache或Nginx 并且要有mod_php和php_cgi才能成功解析php，从这点来看，整个&quot;接收 HTTP 请求并提供 Web 页面&quot;的需求就不需要 PHP 来处理。</p>
<p>nodejs不仅能充当上述服务器的作用 还能实现一个应用。</p>
<p>就上例而言 nodejs的应用由<strong>引入 required 模块</strong>、<strong>创建服务器</strong>、<strong>接收请求与响应请求</strong>这几部分组成。</p>
<h3 id="1-引入模块">1. 引入模块</h3>
<p>使用require载入http模块 把实例化的HTTP服务赋值给变量http 其中require是nodejs自带的http模块<br>
<code>var http = require(&quot;http&quot;);</code></p>
<h3 id="2-创建服务器">2. 创建服务器</h3>
<p>在http模块中提供一函数creatServer，函数会返回一个对象 可以通过listen的方法截获并绑定端口8888，在里面使用request和response来接收和响应数据</p>
<p>http.creatServe()方法创建服务器</p>
<pre><code>//httpserver.js
var http = require('http');

http.createServer(function(request,response){
    response.writeHead(200,{'Content-Type':'text/plain'});//http头 状态码 内容类型
    response.end(&quot;The js had been called!\n&quot;)
}).listen(8080)//监听8080端口

console.log('Server running at http://127.0.0.1:8080')
</code></pre>
<pre><code>//server.js
var http = require('http');

http.createServer(function (request, response) {

    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});

    // 发送响应数据 &quot;Hello World&quot;
    response.end('Hello World\n');
}).listen(8888);

// 终端打印如下信息
console.log('Server running at http://127.0.0.1:8888/');
</code></pre>
<p>配合index.html</p>
<h2 id="三-npm">三、npm</h2>
<h3 id="1-npm使用介绍">1. npm使用介绍</h3>
<p>npm是nodejs(随同nodejs一起安装)的包管理工具，新版的nodejs已经带有npm，能解决NodeJS代码部署上的很多问题。</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>但通常要升级<code>npm install npm -g(全局安装)</code><br>
也需要配置镜像<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<h3 id="2-npm安装模块">2. npm安装模块</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210504213826.png" alt="QQ截图20210504213826" loading="lazy"></figure>
<p>安装模块分为本地安装和全局安装</p>
<ul>
<li>
<p>本地安装（npm install express ）</p>
<ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
</li>
<li>
<p>全局安装（npm install express -g）</p>
<ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ol>
</li>
<li>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 <strong>npm link</strong>。安装过程输出内容，第一行输出了模块的版本号及安装位置。</p>
</li>
<li>
<p>如果安装出现错误：npm err! Error: connect ECONNREFUSED 127.0.0.1:8087</p>
<pre><code>npm config set proxy null
</code></pre>
</li>
</ul>
<p>本地安装<code>npm install npm</code><br>
全局安装<code>npm install npm -g</code><br>
卸载模块<code>npm uninstall npm</code><br>
查看安装的模块包<code>npm ls</code><br>
升级或更新模块<code>npm update npm</code><br>
查看所有全局安装的模块的安装信息<code>npm list -g</code><br>
查看模块版本号<code>npm list grunt</code><br>
搜索模块<code>npm search npm</code></p>
<h3 id="3-创建模块">3. 创建模块</h3>
<p>首先来看一个包的json 位于node_modules/npm的package.json的属性说明</p>
<pre><code>name - 包名。

version - 包的版本号。

description - 包的描述。

homepage - 包的官网 url 。

author - 包的作者姓名。

contributors - 包的其他贡献者姓名。

dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。

repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。

main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。

keywords - 关键字
</code></pre>
<p>npm init(目录下无package.json 否则会修改当前的package.json文件)</p>
<p>信息需要自己输入，可参考菜鸟教程</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/npminit.png" alt="" loading="lazy"></figure>
<p>接着使用npm来发布模块(不演示)</p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7981998"> 首先在npm资源库注册用户<label class="task-list-item-label" for="task-item-7981998"> 首先在npm资源库注册用户``npm adduser``</label></p>
<pre><code>$ npm adduser
Username: mcmohd
Password:
Email: (this IS public) mcmohd@gmail.com
</code></pre>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2548695"> 之后可以发布模块<label class="task-list-item-label" for="task-item-2548695"> 之后可以发布模块``npm publish``</label></p>
<pre><code>$ npm publish
</code></pre>
</li>
</ul>
<h3 id="4-其他npm">4. 其他npm</h3>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210505140452-1620194789830.png" alt="QQ截图20210505140452" loading="lazy"></figure>
<h2 id="四-repl交互式解释器">四、REPL交互式解释器</h2>
<p>终端下输入node来启动node的终端，启动之后如下图。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/PERl.png" alt="" loading="lazy"></figure>
<p>REPL作用：</p>
<ul>
<li><strong>读取</strong> - 读取用户输入，解析输入的 Javascript 数据结构并存储在内存中。</li>
<li><strong>执行</strong> - 执行输入的数据结构</li>
<li><strong>打印</strong> - 输出结果</li>
<li><strong>循环</strong> - 循环操作以上步骤直到用户两次按下 <strong>ctrl-c</strong> 按钮退出。</li>
<li><strong>调试</strong> - 交互式解释器可以很好的调试 Javascript 代码。</li>
</ul>
<p>（表达式计算，使用变量，多行表达式，下划线(_)变量）</p>
<pre><code>   1. 可以不声明变量 但会直接计算结果并输出。
   2. 可以将数据储存在变量中，使用var关键字声明变量，不使用则会被直接打印，使用 **var** 关键字的变量可以使用 console.log() 来输出变量。
   3. 可以使用{}来进行一个多行的表达式，类似于函数，循环等等。
   4. 可以使用下划线(_)获取上一个表达式的运算结果。
</code></pre>
<p>​    node中ctrl+c一次退出当前 两次退出解释器 ctrl+d直接退出解释器。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210505142446.png" alt="" loading="lazy"></figure>
<h2 id="五-回调函数与事件循环">五、回调函数与事件循环</h2>
<h3 id="1-回调">1. 回调</h3>
<p>先来看两个例子</p>
<ul>
<li>阻塞 1.js</li>
</ul>
<p><code>var data = fs.readFileSync('input.txt');</code></p>
<p>读取完文件 执行程序</p>
<ul>
<li>非阻塞 2.js</li>
</ul>
<pre><code>fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
</code></pre>
<p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>
<p>读取文件的同时执行后面的代码 因此提高了程序的性能 从而我们可以把需要处理回调函数的参数写在回调函数内</p>
<p>即 ：阻塞是按顺序执行代码的 非阻塞可以不按照顺序执行</p>
<h3 id="2-事件循环">2. 事件循环</h3>
<p>Node.js 异步编程的直接体现就是回调。</p>
<p>异步编程依托于回调来实现 但不能说使用了回调后程序就异步化了。</p>
<p>nodejs是单线程应用程序 而V8引擎提供的异步执行回调接口就可以处理大量的并发 从而极大的提升了性能。</p>
<p>nodejs的几乎每个API接口都支持回调函数 所有事件均是上帝视角 当事件被检测到就会触发回调函数 。<br>
Node.js 使用事件驱动模型，webserver一直接收请求而不等待读写操作（非阻塞式IO或事件驱动IO） 然后去服务下一个web请求 当这个请求完成 它被放回处理队列 当到达队列开头 这个结果被返回给用户 这种模型非常高效可扩展性也非常强。<br>
<img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/event_loop.jpg" alt="" loading="lazy"></p>
<p>回到开头的引言 我们了解了回调函数以及事件循环 就能执行异步操作了<br>
下面是 将执行异步操作的函数写在回调函数的最后一个参数中 回调函数接收错误对象则作为第一个参数</p>
<p>执行3.js-&gt;删除input.txt-&gt;执行3.js</p>
<pre><code>var fs = require(&quot;fs&quot;);

fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log(&quot;程序执行完毕&quot;);
</code></pre>
<p>readFile函数读取文件，如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。<br>
如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出，此时就是一次异步操作。</p>
<h2 id="六-eventemitter">六、EventEmitter</h2>
<p>events模块只提供一个对象：events.EventEmitter，EventEnitter的核心是事件触发和事件监听的封装。EventEmitter对象中有多个属性on绑定事件函数 emit属性触发事件</p>
<ol>
<li>可以通过require(&quot;events&quot;);来访问该模块。</li>
</ol>
<pre><code>// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre>
<ol start="2">
<li>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p>
</li>
</ol>
<pre><code>//event.js 文件
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() { 
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() { 
    event.emit('some_event'); 
}, 1000); 
</code></pre>
<p>​	执行结果如下：</p>
<p>​	运行这段代码，1 秒后控制台输出了 <strong>'some_event 事件触发'</strong>。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/EventEmitter.png" alt="" loading="lazy"></figure>
<h3 id="error事件">error事件</h3>
<p>​	EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>​	当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>​	我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<p>​	一个事件发生错误时没有监听器时会报错 一般要对其设置error事件的监听器。</p>
<h3 id="继承-eventemitter">继承 EventEmitter</h3>
<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<h2 id="七-buffer缓冲区">七、Buffer(缓冲区)</h2>
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js  带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用  Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<h3 id="buffer与字符编码">Buffer与字符编码</h3>
<p>​	Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<pre><code>const buf = Buffer.from('runoob', 'ascii');

// 输出 72756e6f6f62
console.log(buf.toString('hex'));

// 输出 cnVub29i
console.log(buf.toString('base64'))
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210505155516.png" alt="QQ截图20210505155516" loading="lazy"></figure>
<p>创建Buffer类</p>
<blockquote>
<p>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
<p>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
<p>Buffer.allocUnsafeSlow(size)</p>
<p>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>
<p>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
<p>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>
<p>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</p>
</blockquote>
<p>写入缓冲区</p>
<blockquote>
<p>buf.write(string[, offset[, length]][, encoding])</p>
</blockquote>
<p>从缓冲区读取</p>
<blockquote>
<p>buf.toString([encoding[, start[, end]]])</p>
</blockquote>
<p>将buffer转换为json对象</p>
<blockquote>
<p>buf.toJSON()</p>
</blockquote>
<p>合并缓冲区</p>
<blockquote>
<p>Buffer.concat(list[, totalLength])</p>
</blockquote>
<p>比较缓冲区</p>
<blockquote>
<p>buf.compare(otherBuffer);</p>
</blockquote>
<p>拷贝缓冲区</p>
<blockquote>
<p>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</p>
</blockquote>
<p>裁剪缓冲区</p>
<blockquote>
<p>buf.slice([start[, end]])</p>
</blockquote>
<p>计算缓冲区长度</p>
<blockquote>
<p>buf.length;</p>
</blockquote>
<h2 id="八-模块系统">八、模块系统</h2>
<p>前面介绍过了 引入模块使用require+模块文件<br>
<img src="D:%5CPicGo%5Cimage%5Crequire.jpg" alt="" loading="lazy"><br>
require接收http、fs等原生模块以及某路径下的文件模块，还有mod非原生模块</p>
<h2 id="九-函数">九、函数</h2>
<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, &quot;Hello&quot;);
</code></pre>
<p>say是一个函数 execute函数的第一个参数就是say本身(不是它的返回值) 而say中有一个参数 所以用本地变量someFunction来传递变量</p>
<ul>
<li>匿名函数<br>
一般我们函数使用是先声明后定义使用<br>
即使我们不急着定义函数体 但在对应域前必须声明了 我们才能调用 而这我们可在函数体内——在参数表中使用本地变量someFunction 在函数体内直接使用 甚至都不用给函数名字</li>
</ul>
<pre><code>function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, &quot;Hello&quot;);
</code></pre>
<h2 id="十-路由">十、路由</h2>
<p>url请求 GET POSt参数在前面搭建简单应用时没有提及 作为后端处理这些请求就要有相应的服务器的功能<br>
router下有个index.js文件 里面可以设置数据库 引入其他模块 同样可以写一个服务的serve.js 引入http url等模块 启动后充当服务器<br>
然后用到一个router.js的文件 写一个路由函数作为参数传给server.js<br>
至此可以访问url</p>
<h2 id="十一-全局变量">十一、全局变量</h2>
<p>列出一丢丢：</p>
<p>_filename 当前脚本文件名 输出其绝对路径</p>
<p>_dirname 当前脚本所在路径</p>
<p>setTimeour(function(),ms) 全局函数 在指定毫秒后执行一次函数</p>
<p>clearTimeout(t) 清除setTimeout()</p>
<pre><code>function printHello(){
   console.log( &quot;Hello, World!&quot;);
}
// 两秒后执行以上函数
var t = setTimeout(printHello, 2000);

// 清除定时器
clearTimeout(t);
</code></pre>
<p>setlnterval(function(),ms)<br>
clearlnterval(t)<br>
和上面的两个一样 不同的是 setlntercal会一直调用函数 直至clearlnterval调用或窗口关闭</p>
<p>process是global的属性 也是全局变量有四个事件<br>
exit before uncaughException Signal</p>
<h2 id="十二-文件-异步">十二、文件-异步</h2>
<p>导入文件系统模块<br>
<code>var fs = require(&quot;fs&quot;)</code></p>
<ul>
<li>读取input.txt</li>
</ul>
<pre><code>fs.readFile('input.txt', function (err, data) {
   if (err) {
       return console.error(err);
   }
   console.log(&quot;异步读取: &quot; + data.toString());
});
</code></pre>
<p>类似地有函数：</p>
<pre><code>打开
fs.open(path, flags[, mode], callback)//(flags:r r+ a a+ ......)

写入
fs.writeFile(file, data[, options], callback)

读取
fs.read(fd, buffer, offset, length, position, callback)

关闭
fs.close(fd, callback)

删除 
fs.unlink(path, callback)

还有目录...
</code></pre>
<h2 id="十三-getpost请求">十三、GET/POST请求</h2>
<p>获取get请求的参数</p>
<pre><code>var http = require('http');
var url = require('url');
var util = require('util');
 
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);
</code></pre>
<p>获取url的参数</p>
<pre><code>var http = require('http');
var url = require('url');
var util = require('util');
 
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain'});
 
    // 解析 url 参数
    var params = url.parse(req.url, true).query;
    res.write(&quot;网站名：&quot; + params.name);
    res.write(&quot;\n&quot;);
    res.write(&quot;网站 URL：&quot; + params.url);
    res.end();
 
}).listen(3000);
</code></pre>
<p>获取post的内容</p>
<pre><code>var http = require('http');
var querystring = require('querystring');
var util = require('util');
 
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
 
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
 
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(3000);
</code></pre>
<p>提交post表单</p>
<pre><code>var http = require('http');
var querystring = require('querystring');
 
var postHTML = 
  '&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Node.js 实例&lt;/title&gt;&lt;/head&gt;' +
  '&lt;body&gt;' +
  '&lt;form method=&quot;post&quot;&gt;' +
  '网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;' +
  '网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;' +
  '&lt;input type=&quot;submit&quot;&gt;' +
  '&lt;/form&gt;' +
  '&lt;/body&gt;&lt;/html&gt;';
 
http.createServer(function (req, res) {
  var body = &quot;&quot;;
  req.on('data', function (chunk) {
    body += chunk;
  });
  req.on('end', function () {
    // 解析参数
    body = querystring.parse(body);
    // 设置响应头部信息及编码
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf8'});
 
    if(body.name &amp;&amp; body.url) { // 输出提交的数据
        res.write(&quot;网站名：&quot; + body.name);
        res.write(&quot;&lt;br&gt;&quot;);
        res.write(&quot;网站 URL：&quot; + body.url);
    } else {  // 输出表单
        res.write(postHTML);
    }
    res.end();
  });
}).listen(3000);
</code></pre>
<h2 id="十四-express框架">十四、Express框架</h2>
<p>利用Express框架<br>
实现GEt方法提交两个参数和POST方法提交两个参数<br>
完成文件上传 要本地安装multer模块  在目录下能看到上传的文件<br>
对cookie进行管理  要本地安装cookie-parser模块 在服务终端能看到cookie信息</p>
<h2 id="十五-连接-mysql">十五、连接 MySQL</h2>
<p>介绍如何使用 Node.js 来连接 MySQL，并对数据库进行操作。</p>
<h3 id="安装驱动">安装驱动</h3>
<p>本教程使用了<a href="https://www.runoob.com/nodejs/nodejs-npm.html#taobaonpm">淘宝定制的 cnpm 命令</a>进行安装：</p>
<pre><code>$ cnpm install mysql
</code></pre>
<h3 id="连接数据库">连接数据库</h3>
<p>在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：</p>
<p>test.js 文件代码：</p>
<pre><code class="language-javascript">var mysql      = require('mysql');
var connection = mysql.createConnection({
  host     : 'localhost',
  user     : 'root',
  password : '123456',
  database : 'test'
});
 
connection.connect();
 
connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});
</code></pre>
<p>执行以下命令输出结果为：</p>
<p>$ node test.js<br>
The solution is: 2</p>
<h3 id="数据库操作-curd">数据库操作( CURD )</h3>
<p>在进行数据库操作前，你需要将本站提供的 Websites 表 SQL 文件<a href="https://static.runoob.com/download/websites.sql">websites.sql</a> 导入到你的 MySQL 数据库中。</p>
<p>本教程测试的 MySQL 用户名为 root，密码为 123456，数据库为 test，你需要根据自己配置情况修改。</p>
<h4 id="查询数据">查询数据</h4>
<p>将上面我们提供的 SQL 文件导入数据库后，执行以下代码即可查询出数据：</p>
<p>查询数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var  sql = 'SELECT * FROM websites';
//查
connection.query(sql,function (err, result) {
        if(err){
          console.log('[SELECT ERROR] - ',err.message);
          return;
        }
 
       console.log('------SELECT------');
       console.log(result);
       console.log('------------------');  
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>$ node test.js
--------------------------SELECT----------------------------
[ RowDataPacket {
    id: 1,
    name: 'Google',
    url: 'https://www.google.cm/',
    alexa: 1,
    country: 'USA' },
  RowDataPacket {
    id: 2,
    name: '淘宝',
    url: 'https://www.taobao.com/',
    alexa: 13,
    country: 'CN' }
]
------------------------------------------------------------
</code></pre>
<h4 id="插入数据">插入数据</h4>
<p>我们可以向数据表 websties 插入数据：</p>
<p>插入数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var  addSql = 'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)';
var  addSqlParams = ['工具', 'https://c.sxb.com','23453', 'CN'];
//增
connection.query(addSql,addSqlParams,function (err, result) {
        if(err){
         console.log('[INSERT ERROR] - ',err.message);
         return;
        }        
 
       console.log('------INSERT------');
       //console.log('INSERT ID:',result.insertId);        
       console.log('INSERT ID:',result);        
       console.log('--------------\n\n');  
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>$ node test.js
--------------------------INSERT----------------------------
INSERT ID: OkPacket {
  fieldCount: 0,
  affectedRows: 1,
  insertId: 6,
  serverStatus: 2,
  warningCount: 0,
  message: '',
  protocol41: true,
  changedRows: 0 }
-----------------------------------------------------------------
</code></pre>
<p>执行成功后，查看数据表，即可以看到添加的数据</p>
<h4 id="更新数据">更新数据</h4>
<p>我们也可以对数据库的数据进行修改：</p>
<p>更新数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var modSql = 'UPDATE websites SET name = ?,url = ? WHERE Id = ?';
var modSqlParams = ['移动站', 'https://m.sxt.com',6];
//改
connection.query(modSql,modSqlParams,function (err, result) {
   if(err){
         console.log('[UPDATE ERROR] - ',err.message);
         return;
   }        
  console.log('--------UPDATE--------');
  console.log('UPDATE affectedRows',result.affectedRows);
  console.log('----------\n\n');
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>--------------------------UPDATE----------------------------
UPDATE affectedRows 1
-----------------------------------------------------------------
</code></pre>
<p>执行成功后，查看数据表</p>
<h4 id="删除数据">删除数据</h4>
<p>我们可以使用以下代码来删除 id 为 6 的数据:</p>
<p>删除数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var delSql = 'DELETE FROM websites where id=6';
//删
connection.query(delSql,function (err, result) {
        if(err){
          console.log('[DELETE ERROR] - ',err.message);
          return;
        }        
 
       console.log('-----DELETE-------');
       console.log('DELETE affectedRows',result.affectedRows);
       console.log('----------------\n\n');  
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>--------------------------DELETE----------------------------
DELETE affectedRows 1
-----------------------------------------------------------------
</code></pre>
<p>执行成功后，查看数据表</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kite-007.github.io/kali-zhu-dong-xin-xi-shou-ji/">
                  <h3 class="post-title">
                    # KALI 主动信息收集
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
